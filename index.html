<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>TWIST | Kernel + Pole + Náboj + Tlak + Čas</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body{
    background:#06060a; color:#8a8a8a;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    height:100vh; overflow:hidden;
    overscroll-behavior:none; touch-action:none;
  }
  .top{
    height:44px; display:flex; align-items:baseline; gap:18px;
    padding:10px 16px; border-bottom:1px solid #141418; background:#06060a;
  }
  .top .t{ color:#00d2ff; letter-spacing:3px; font-size:12px; }
  .top .a{ color:#4a4a4a; font-size:11px; }
  .wrap{ position:relative; width:100%; height:calc(100vh - 44px); }
  canvas{ width:100%; height:100%; display:block; cursor:crosshair; touch-action:none; }
  .hud{
    position:absolute; top:14px; right:14px;
    font-size:11px; text-align:right; color:#4a4a4a; pointer-events:none;
  }
  .hud .v{ color:#00d2ff; }
  .panel{
    position:absolute; left:14px; bottom:14px;
    display:flex; flex-direction:column; gap:10px; pointer-events:auto;
    max-height:calc(100% - 28px); overflow-y:auto; overflow-x:hidden;
    scrollbar-width:thin; scrollbar-color:#1e1e28 transparent;
  }
  @media(max-width:1024px){
    .panel{ bottom:auto; top:4px; max-height:calc(100% - 8px); }
  }
  .panel::-webkit-scrollbar{ width:4px; }
  .panel::-webkit-scrollbar-thumb{ background:#1e1e28; border-radius:2px; }
  .btn-bar{
    pointer-events:auto;
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:4px;
    margin-bottom:6px;
  }
  .btn-bar button{ font-size:10px; padding:5px 4px; }
  @media(min-width:500px){
    .btn-bar{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn-bar button{ font-size:inherit; padding:revert; }
  }
  .credit{
    position:absolute; bottom:4px; right:14px;
    font-size:8px; color:#2a2a36; pointer-events:none; letter-spacing:1px;
  }
  .row{
    pointer-events:auto; display:flex; gap:10px; align-items:center;
    padding:6px 10px; border:1px solid #1e1e28;
    background:rgba(6,6,10,0.78); border-radius:6px;
  }
  .row.disabled{ opacity:0.35; }
  label{ width:130px; font-size:10px; color:#666; }
  label small{ color:#555; font-size:9px; }
  button small{ color:#777; font-size:9px; }
  .tog small{ color:#666; }
  input[type=range]{ width:210px; }
  .tog{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    font-size:11px; color:#8a8a8a;
  }
  .tog label{
    width:auto; color:#8a8a8a; font-size:11px;
    display:flex; align-items:center; gap:6px;
    cursor:pointer; user-select:none;
  }
  .tog input{ cursor:pointer; }
  button{
    pointer-events:auto; background:#0b0b12; color:#9a9a9a;
    border:1px solid #1e1e28; padding:6px 10px; border-radius:6px;
    cursor:pointer; font-size:11px;
  }
  button:hover{ border-color:#2a2a36; color:#cfcfcf; }
  input:disabled{ cursor:not-allowed; }
  .help-overlay{
    display:none; position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:rgba(6,6,10,0.94); border:1px solid #1e1e28;
    border-radius:8px; padding:18px 24px;
    font-size:11px; color:#8a8a8a; pointer-events:auto;
    max-height:80vh; overflow-y:auto; z-index:10;
    min-width:320px;
  }
  .help-overlay.show{ display:block; }
  .help-overlay h3{ color:#00d2ff; font-size:12px; margin:10px 0 6px; letter-spacing:2px; }
  .help-overlay h3:first-child{ margin-top:0; }
  .help-overlay .krow{ display:flex; justify-content:space-between; padding:2px 0; }
  .help-overlay .kk{ color:#00d2ff; min-width:90px; }
  .help-hint{
    position:absolute; bottom:14px; right:14px;
    font-size:10px; color:#444; pointer-events:none;
  }
  .ui-hidden .top,
  .ui-hidden .hud,
  .ui-hidden .panel,
  .ui-hidden .help-hint,
  .ui-hidden .help-overlay,
  .ui-hidden .credit,
  .ui-hidden .wrap{ height:100vh; }
</style>
</head>
<body>
  <div class="top">
    <div class="t">TWIST // KERNEL + POLE + NÁBOJ + TLAK + ČAS</div>
    <div class="a">
      JÁDRO: z=Tr(x), t=TM(n), i=(z+2t) mod 5, x←gᵢ(x).
      POLE: gyron → hmota(R), d/e → náboj(G/B). ∇ρL = gravitace, -∇ρS = tlak, sign(ρQ)·∇ρQ = plazma. ρ ∈ [0,1].
      ČAS: dτ/dn = 1/(1+K·ρ). POHON: gyron kopanec. PŘESNÝ: pos=K(pos). MYŠ: odpuz / tahni.
      KOLEČKO: zoom. SHIFT+KOLEČKO: rotace. DOTYK: 1prst=myš, 2prsty=zoom+rotace.
    </div>
  </div>

  <div class="wrap">
    <canvas id="c"></canvas>

    <div class="hud">
      <div>ČÁSTICE <span class="v" id="pc">0</span></div>
      <div>FPS <span class="v" id="fps">0</span></div>
      <div>TM <span class="v" id="tm">0</span></div>
      <div>ROT <span class="v" id="rotv">0</span>°</div>
      <div id="histDiv" style="display:none">z <span class="v" id="histZ">-</span> i <span class="v" id="histI">-</span></div>
    </div>

    <div class="panel">
      <div class="row" id="rowModules">
        <label>MODULY</label>
        <div class="tog">
          <label><input type="checkbox" id="tglKernel" checked>JÁDRO <small>(1)</small></label>
          <label><input type="checkbox" id="tglField"  checked>POLE <small>(2)</small></label>
          <label><input type="checkbox" id="tglMouse"  checked>MYŠ <small>(3)</small></label>
          <label><input type="checkbox" id="tglChaos"  checked>CHAOS <small>(4)</small></label>
          <label><input type="checkbox" id="tglPump" checked>POHON <small>(5)</small></label>
          <label><input type="checkbox" id="tglExact">PŘESNÝ <small>(6)</small></label>
        </div>
      </div>

      <div class="row" id="rowMouseMode">
        <label>MYŠ REŽIM <small>(M)</small></label>
        <div class="tog">
          <label><input type="radio" name="mouseMode" id="mouseRepel">ODPUZ</label>
          <label><input type="radio" name="mouseMode" id="mouseAttract" checked>TAHNI</label>
        </div>
      </div>

      <div class="btn-bar">
        <button id="panelHide">SKRÝT <small>(TAB)</small></button>
        <button id="reset">RESET <small>(R)</small></button>
        <button id="defaults">VÝCHOZÍ <small>(B)</small></button>
        <button id="pause">PAUZA <small>(SPC)</small></button>
        <button id="share">SDÍLET <small>(C)</small></button>
      </div>

      <div id="slidersWrap">
      <div class="row" id="rowParticles">
        <label>ČÁSTICE <small>(P/N)</small></label>
        <input id="particles" type="range" min="12" max="24" step="1" value="19" />
      </div>

      <div class="row" id="rowTempo">
        <label>TEMPO <small>(J Y)</small></label>
        <input id="tempo" type="range" min="0.05" max="3.00" step="0.01" value="1.00" />
      </div>

      <div class="row" id="rowDamping">
        <label>TLUMENÍ <small>([ ])</small></label>
        <input id="damping" type="range" min="0.50" max="1.000" step="0.001" value="0.677" />
      </div>

      <div class="row" id="rowForce">
        <label>SÍLA IFS <small>(; ')</small></label>
        <input id="force" type="range" min="0.000" max="1.000" step="0.001" value="0.3" />
      </div>

      <div class="row" id="rowChaos">
        <label>CHAOS <small>(Z X)</small></label>
        <input id="chaos" type="range" min="0.0" max="5.0" step="0.01" value="1.86" />
      </div>

      <div class="row" id="rowFade">
        <label>STOPA <small>(I K)</small></label>
        <input id="fade" type="range" min="0.50" max="1.000" step="0.001" value="0.69" />
      </div>

      <div class="row" id="rowScale">
        <label>MĚŘÍTKO <small>(+ −)</small></label>
        <input id="scale" type="range" min="0.05" max="5.00" step="0.01" value="0.65" />
      </div>

      <div class="row" id="rowSpin">
        <label>ROTACE <small>(← →)</small></label>
        <input id="spin" type="range" min="-0.050" max="0.050" step="0.001" value="0.000" />
      </div>

      <div class="row" id="rowPalette">
        <label>BARVY <small>(7 8)</small></label>
        <input id="palette" type="range" min="0" max="10" step="1" value="1" />
      </div>

      <div class="row" id="rowFieldFade">
        <label>POLE FADE <small>(O L)</small></label>
        <input id="ffield" type="range" min="0.50" max="1.000" step="0.001" value="0.929" />
      </div>

      <div class="row" id="rowDeposit">
        <label>HUSTOTA <small>(F V)</small></label>
        <input id="deposit" type="range" min="1" max="50" step="1" value="3" />
      </div>

      <div class="row" id="rowGrav">
        <label>GRAVITACE <small>(↑ ↓)</small></label>
        <input id="grav" type="range" min="0.000" max="2.000" step="0.001" value="1" />
      </div>

      <div class="row" id="rowPressure">
        <label>TLAK <small>(, .)</small></label>
        <input id="pressure" type="range" min="0.000" max="2.000" step="0.001" value="1.93" />
      </div>

      <div class="row" id="rowTimeK">
        <label>ČAS K <small>(W S)</small></label>
        <input id="timeK" type="range" min="0" max="100" step="1" value="38" />
      </div>

      <div class="row" id="rowTimeMin">
        <label>ČAS MIN <small>(E D)</small></label>
        <input id="timeMin" type="range" min="0.05" max="1.00" step="0.01" value="0.07" />
      </div>

      <div class="row" id="rowCharge">
        <label>NÁBOJ <small>(Q A)</small></label>
        <input id="charge" type="range" min="0.000" max="10.00" step="0.01" value="5" />
      </div>

      <div class="row" id="rowVortex">
        <label>VÍR <small>(&lt; &gt;)</small></label>
        <input id="vortex" type="range" min="0.00" max="1.00" step="0.01" value="0.00" />
      </div>

      <div class="row" id="rowPump">
        <label>POHON <small>(T G)</small></label>
        <input id="pump" type="range" min="0.000" max="0.200" step="0.001" value="0.099" />
      </div>
      </div>
    </div>

    <div class="help-overlay" id="helpOverlay">
      <h3>PŘEPÍNAČE</h3>
      <div class="krow"><span class="kk">SPACE</span><span>pauza / pokračovat</span></div>
      <div class="krow"><span class="kk">R</span><span>reset (nové částice, zachová nastavení)</span></div>
      <div class="krow"><span class="kk">B</span><span>výchozí (reset + všechny slidery na default)</span></div>
      <div class="krow"><span class="kk">1</span><span>JÁDRO on/off</span></div>
      <div class="krow"><span class="kk">2</span><span>POLE on/off</span></div>
      <div class="krow"><span class="kk">3</span><span>MYŠ on/off</span></div>
      <div class="krow"><span class="kk">4</span><span>CHAOS on/off</span></div>
      <div class="krow"><span class="kk">5</span><span>POHON on/off</span></div>
      <div class="krow"><span class="kk">6</span><span>PŘESNÝ IFS on/off (kanonický krok)</span></div>
      <div class="krow"><span class="kk">M</span><span>myš: odpuz / tahni</span></div>
      <div class="krow"><span class="kk">P / N</span><span>více / méně částic</span></div>
      <div class="krow"><span class="kk">7 / 8</span><span>barvy (paleta)</span></div>
      <h3>KAMERA</h3>
      <div class="krow"><span class="kk">+ / -</span><span>zoom</span></div>
      <div class="krow"><span class="kk">← / →</span><span>rotace (auto-spin)</span></div>
      <div class="krow"><span class="kk">0</span><span>reset rotace + posun + spin</span></div>
      <div class="krow"><span class="kk">Shift+tažení</span><span>posun kamery (pan)</span></div>
      <h3>FYZIKA</h3>
      <div class="krow"><span class="kk">↑ / ↓</span><span>gravitace</span></div>
      <div class="krow"><span class="kk">[ / ]</span><span>tlumení</span></div>
      <div class="krow"><span class="kk">; / '</span><span>síla IFS</span></div>
      <div class="krow"><span class="kk">, / .</span><span>tlak</span></div>
      <div class="krow"><span class="kk">Q / A</span><span>náboj</span></div>
      <div class="krow"><span class="kk">&lt; / &gt;</span><span>vír (orbit vs pád)</span></div>
      <div class="krow"><span class="kk">W / S</span><span>čas K</span></div>
      <div class="krow"><span class="kk">E / D</span><span>čas min</span></div>
      <div class="krow"><span class="kk">T / G</span><span>pohon (pump)</span></div>
      <div class="krow"><span class="kk">F / V</span><span>hustota (deposit multiplier)</span></div>
      <div class="krow"><span class="kk">Z / X</span><span>chaos</span></div>
      <div class="krow"><span class="kk">I / K</span><span>stopa (fade)</span></div>
      <div class="krow"><span class="kk">O / L</span><span>pole fade</span></div>
      <div class="krow"><span class="kk">J / Y</span><span>tempo (zpomalit / zrychlit)</span></div>
      <h3>NÁPOVĚDA</h3>
      <div class="krow"><span class="kk">H</span><span>zobrazit / skrýt</span></div>
      <div class="krow"><span class="kk">U</span><span>skrýt / ukázat vše (čisté plátno)</span></div>
      <div class="krow"><span class="kk">TAB</span><span>skrýt / ukázat menu</span></div>
      <div class="krow"><span class="kk">C</span><span>sdílet (kopírovat odkaz s nastavením)</span></div>
      <div class="krow"><span class="kk">ESC</span><span>zavřít nápovědu</span></div>
    </div>

    <div class="help-hint">[H] klávesy  [U] skrýt vše  [TAB] menu</div>
    <div class="credit">&copy; A. M. Thorn, 2026 AD</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias:false, alpha:false });
  if(!gl){ alert("WebGL2 je nutný."); return; }

  const ext = gl.getExtension('EXT_color_buffer_float');
  if(!ext){ alert("Chybí EXT_color_buffer_float (float render target)."); return; }
  gl.getExtension('EXT_float_blend');

  // =========================
  // UI
  // =========================
  const ui = {
    tglKernel:  document.getElementById('tglKernel'),
    tglField:   document.getElementById('tglField'),
    tglMouse:   document.getElementById('tglMouse'),
    tglChaos:   document.getElementById('tglChaos'),
    tglPump:    document.getElementById('tglPump'),
    tglExact:   document.getElementById('tglExact'),
    mouseRepel: document.getElementById('mouseRepel'),
    mouseAttract: document.getElementById('mouseAttract'),

    damping: document.getElementById('damping'),
    force:   document.getElementById('force'),
    chaos:   document.getElementById('chaos'),
    fade:    document.getElementById('fade'),
    scale:   document.getElementById('scale'),

    ffield:  document.getElementById('ffield'),
    deposit: document.getElementById('deposit'),
    grav:    document.getElementById('grav'),
    pressure: document.getElementById('pressure'),
    pump:    document.getElementById('pump'),
    spin:    document.getElementById('spin'),
    timeK:   document.getElementById('timeK'),
    timeMin: document.getElementById('timeMin'),
    charge:  document.getElementById('charge'),
    particles: document.getElementById('particles'),
    palette: document.getElementById('palette'),
    vortex: document.getElementById('vortex'),
    tempo: document.getElementById('tempo'),

    rowMouseMode: document.getElementById('rowMouseMode'),
    rowChaos: document.getElementById('rowChaos'),
    rowFieldFade: document.getElementById('rowFieldFade'),
    rowDeposit: document.getElementById('rowDeposit'),
    rowGrav: document.getElementById('rowGrav'),
    rowPressure: document.getElementById('rowPressure'),
    rowTimeK: document.getElementById('rowTimeK'),
    rowTimeMin: document.getElementById('rowTimeMin'),
    rowCharge: document.getElementById('rowCharge'),
    rowPump: document.getElementById('rowPump'),
  };

  function setRowEnabled(rowEl, enabled){
    rowEl.classList.toggle('disabled', !enabled);
    rowEl.querySelectorAll('input,select,button').forEach(el => {
      el.disabled = !enabled;
    });
  }

  function syncUI(){
    const kernelOn = ui.tglKernel.checked;
    const fieldOn  = ui.tglField.checked;
    const mouseOn  = ui.tglMouse.checked;
    const chaosOn  = ui.tglChaos.checked;

    if(!kernelOn){
      ui.tglPump.checked = false;
      ui.tglPump.disabled = true;
    } else {
      ui.tglPump.disabled = false;
    }
    const pumpOn = ui.tglPump.checked && kernelOn;

    setRowEnabled(ui.rowMouseMode, mouseOn);
    setRowEnabled(ui.rowChaos, chaosOn);
    setRowEnabled(ui.rowFieldFade, fieldOn);
    setRowEnabled(ui.rowDeposit, fieldOn);
    setRowEnabled(ui.rowGrav, fieldOn);
    setRowEnabled(ui.rowPressure, fieldOn);
    setRowEnabled(ui.rowTimeK, fieldOn);
    setRowEnabled(ui.rowTimeMin, fieldOn);
    setRowEnabled(ui.rowCharge, fieldOn);
    setRowEnabled(ui.rowPump, pumpOn);
  }

  [ui.tglKernel, ui.tglField, ui.tglMouse, ui.tglChaos, ui.tglPump, ui.tglExact,
   ui.mouseRepel, ui.mouseAttract].forEach(el => {
    el.addEventListener('change', syncUI);
  });
  syncUI();

  // =========================
  // Panel toggle (TAB)
  // =========================
  const slidersWrap = document.getElementById('slidersWrap');
  const panelHideBtn = document.getElementById('panelHide');

  let slidersVisible = window.innerWidth >= 500;
  function togglePanel(){
    slidersVisible = !slidersVisible;
    slidersWrap.style.display = slidersVisible ? '' : 'none';
    panelHideBtn.innerHTML = slidersVisible
      ? 'SKRÝT <small>(TAB)</small>'
      : 'UKÁZAT <small>(TAB)</small>';
  }
  panelHideBtn.addEventListener('click', togglePanel);
  if(!slidersVisible) slidersWrap.style.display = 'none';
  if(!slidersVisible) panelHideBtn.innerHTML = 'UKÁZAT <small>(TAB)</small>';

  // =========================
  // URL hash: encode/decode
  // =========================
  const BASE_URL = 'https://mathorn1973.github.io/twist/';

  const SLIDER_MAP = [
    ['dm', 'damping'],   ['fo', 'force'],    ['ch', 'chaos'],
    ['fa', 'fade'],      ['sc', 'scale'],    ['sp', 'spin'],
    ['ff', 'ffield'],    ['de', 'deposit'],  ['gr', 'grav'],
    ['pr', 'pressure'],  ['tk', 'timeK'],    ['tm', 'timeMin'],
    ['qa', 'charge'],    ['pu', 'pump'],     ['pa', 'particles'],
    ['te', 'tempo'],    ['pl', 'palette'],  ['vx', 'vortex'],
  ];

  const TOGGLE_MAP = [
    ['K', 'tglKernel'], ['F', 'tglField'], ['X', 'tglMouse'],
    ['C', 'tglChaos'],  ['P', 'tglPump'],  ['E', 'tglExact'],
  ];

  function encodeSettings(){
    let parts = [];
    let tg = '';
    for(const [k, id] of TOGGLE_MAP){
      tg += k + (ui[id].checked ? '1' : '0');
    }
    parts.push(tg);
    parts.push('M' + (ui.mouseAttract.checked ? 'a' : 'r'));
    for(const [k, id] of SLIDER_MAP){
      parts.push(k + ui[id].value);
    }
    return parts.join('~');
  }

  function decodeSettings(hash){
    if(!hash) return;
    let parts;
    if(hash.includes('~')){
      parts = hash.split('~');
    } else {
      const raw = hash.split('.');
      parts = [];
      for(let i = 0; i < raw.length; i++){
        if(i > 0 && /^\d+$/.test(raw[i]) && parts.length > 0 && /\d$/.test(parts[parts.length-1])){
          parts[parts.length-1] += '.' + raw[i];
        } else {
          parts.push(raw[i]);
        }
      }
    }
    for(const p of parts){
      if(p.length > 4 && /^[KFXCPE][01]/.test(p)){
        for(let i = 0; i < p.length - 1; i += 2){
          const key = p[i];
          const val = p[i+1] === '1';
          for(const [k, id] of TOGGLE_MAP){
            if(k === key) ui[id].checked = val;
          }
        }
        continue;
      }
      if(p[0] === 'M' && p.length === 2){
        if(p[1] === 'a') ui.mouseAttract.checked = true;
        else ui.mouseRepel.checked = true;
        continue;
      }
      const sk = p.substring(0, 2);
      const sv = p.substring(2);
      for(const [k, id] of SLIDER_MAP){
        if(k === sk && ui[id]){
          const v = parseFloat(sv);
          if(!isNaN(v)){
            const min = parseFloat(ui[id].min);
            const max = parseFloat(ui[id].max);
            ui[id].value = Math.min(max, Math.max(min, v));
          }
        }
      }
    }
    syncUI();
  }

  function shareURL(){
    const hash = encodeSettings();
    const url = BASE_URL + '#' + hash;
    try { history.replaceState(null, '', '#' + hash); } catch(e){}

    function showOK(){
      const btn = document.getElementById('share');
      const orig = btn.innerHTML;
      btn.innerHTML = 'ZKOPÍROVÁNO ✓';
      setTimeout(() => { btn.innerHTML = orig; }, 1500);
    }

    function showURL(){
      const btn = document.getElementById('share');
      const orig = btn.innerHTML;
      btn.innerHTML = '<span style="font-size:8px;word-break:break-all;max-width:200px;display:inline-block">' + url + '</span>';
      setTimeout(() => { btn.innerHTML = orig; }, 5000);
    }

    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(url).then(showOK).catch(() => { fallback(); });
    } else {
      fallback();
    }

    function fallback(){
      const ta = document.createElement('textarea');
      ta.value = url;
      ta.style.cssText = 'position:fixed;top:-9999px;left:-9999px;';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try { ok = document.execCommand('copy'); } catch(e){}
      document.body.removeChild(ta);
      if(ok) showOK();
      else showURL();
    }
  }

  document.getElementById('share').addEventListener('click', shareURL);

  if(location.hash.length > 1){
    decodeSettings(location.hash.substring(1));
  }

  // =========================
  // HUD
  // =========================
  const fpsEl = document.getElementById('fps');
  const tmEl  = document.getElementById('tm');
  const pcEl  = document.getElementById('pc');

  // =========================
  // GPU params
  // =========================
  const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxPixels = Math.min(400 * 1024 * 1024 / 48, maxTexSize * maxTexSize);
  const TEX_SIZE = Math.min(3200, Math.floor(Math.sqrt(maxPixels)));
  const N        = TEX_SIZE * TEX_SIZE;
  const FIELD_SIZE = 256;

  console.log('TEX_SIZE:', TEX_SIZE, ' N:', N.toLocaleString(), ' MAX_TEXTURE_SIZE:', maxTexSize);
  pcEl.textContent = N.toLocaleString();
  let activeN = N;

  // =========================
  // WebGL helpers
  // =========================
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s) + "\n\n" + src);
    }
    return s;
  }
  function program(vsSrc, fsSrc){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
  }
  function tex2D(w,h, internalFormat, format, type, filter){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
    return t;
  }
  function fboMRT(textures){
    const f = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    const bufs = [];
    for(let i=0;i<textures.length;i++){
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, textures[i], 0);
      bufs.push(gl.COLOR_ATTACHMENT0+i);
    }
    gl.drawBuffers(bufs);
    const st = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if(st !== gl.FRAMEBUFFER_COMPLETE){
      throw new Error("FBO incomplete: " + st.toString(16));
    }
    return f;
  }
  function U(p, name){ return gl.getUniformLocation(p, name); }

  // =========================
  // SHADERS
  // =========================
  const VS_QUAD = `#version 300 es
  layout(location=0) in vec2 a_pos;
  out vec2 v_uv;
  void main(){
    v_uv = a_pos*0.5 + 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  const FS_INIT = `#version 300 es
  precision highp float;
  precision highp int;
  layout(location=0) out vec4 o_state;
  layout(location=1) out vec4 o_k0;
  layout(location=2) out vec4 o_k1;
  uniform uint u_seed;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  void main(){
    uvec2 fc = uvec2(uint(gl_FragCoord.x), uint(gl_FragCoord.y));
    uint id = fc.y * uint(${TEX_SIZE}) + fc.x;
    uint h = hash(id ^ (u_seed*747796405u + 2891336453u));

    uint h2 = hash(h);
    float r  = float(h & 0xFFFFu) / 65535.0;
    float a  = float(h2 & 0xFFFFu) / 65535.0 * 6.2831853;
    float rad = sqrt(r) * 1.4;
    vec2 pos = vec2(cos(a), sin(a)) * rad;

    uint h3 = hash(h2 + 1u);
    float va = a + 1.5708;
    float vmag = 0.005 + float(h3 & 0xFFFFu) / 65535.0 * 0.01;
    vec2 vel = vec2(cos(va), sin(va)) * vmag;

    uint k0 = hash(h2);
    uint k1 = hash(k0);
    int p1  = int(k0 % 5u);
    int p4  = int((k0/5u) % 5u);
    int p1p = int((k0/25u) % 5u);
    int p4p = int((k0/125u) % 5u);
    int q   = int(k1 % 5u);
    int ts  = int((k1/5u) % 5u);

    o_state = vec4(pos, vel);
    o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
    o_k1 = vec4(float(q), float(ts), 0.0, 0.0);
  }`;

  const FS_FADE = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_prev;
  uniform float u_fade;
  out vec4 o_col;
  void main(){ o_col = min(texture(u_prev, v_uv) * u_fade, 8.0); }`;

  const FS_FIELD_FADE = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_prev;
  uniform float u_fade;
  out vec4 o_col;
  void main(){ o_col = min(texture(u_prev, v_uv) * u_fade, 1.0); }`;

  const FS_BLIT = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_tex;
  uniform int u_palette;
  out vec4 o_col;
  void main(){
    vec3 c = texture(u_tex, v_uv).rgb;
    c = c / (1.0 + c);

    if(u_palette >= 6){
      float lum = dot(c, vec3(0.299, 0.587, 0.114));
      float sat = (u_palette >= 9) ? 1.8 : (u_palette >= 8) ? 4.0 : (u_palette >= 7) ? 3.0 : 2.2;
      c = max(vec3(0.0), lum + (c - lum) * sat);
      float gam = (u_palette >= 9) ? 0.85 : 0.75;
      c = pow(c, vec3(gam));
    }

    o_col = vec4(c, 1.0);
  }`;

  const FS_BLUR = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_tex;
  uniform vec2 u_dir;
  out vec4 o_col;
  void main(){
    vec4 c = texture(u_tex, v_uv) * 0.382925;
    c += texture(u_tex, v_uv + u_dir * 1.384615) * 0.241732;
    c += texture(u_tex, v_uv - u_dir * 1.384615) * 0.241732;
    c += texture(u_tex, v_uv + u_dir * 3.230769) * 0.06136;
    c += texture(u_tex, v_uv - u_dir * 3.230769) * 0.06136;
    o_col = c;
  }`;

  const VS_POINTS_FIELD = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform float u_bounds;
  uniform int   u_tm;
  uniform uint  u_frame;
  uniform float u_deposit;
  uniform int   u_kernelOn;

  out float v_mass;
  out float v_qp;
  out float v_qm;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  int idx_map(int z, int tm){
    int i = (tm==0) ? z : (z+2);
    return (i>=5) ? (i-5) : i;
  }

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};

    vec4 st = texelFetch(u_state, ivec2(xx,yy), 0);
    vec2 pos = st.xy;

    float mass = 0.0;
    float qp = 0.0;
    float qm = 0.0;

    if(u_kernelOn == 1){
      vec4 k0 = texelFetch(u_k0, ivec2(xx,yy), 0);
      vec4 k1 = texelFetch(u_k1, ivec2(xx,yy), 0);
      int p1  = int(k0.x + 0.5);
      int p4  = int(k0.y + 0.5);
      int p1p = int(k0.z + 0.5);
      int p4p = int(k0.w + 0.5);
      int q   = int(k1.x + 0.5);
      int ts  = int(k1.y + 0.5);
      int z = z_trace6(p1,p4,p1p,p4p,q,ts);
      int idx = idx_map(z, u_tm);

      if(u_tm == 0 && z == 4) mass = u_deposit;
      if(idx == 3) qp = u_deposit;
      if(idx == 4) qm = u_deposit;
    } else {
      uint uid = uint(yy) * uint(${TEX_SIZE}) + uint(xx);
      uint h = hash(uid + u_frame * 1923u);
      uint k = h % 5u;
      if(u_tm == 0 && k == 4u) mass = u_deposit;
      if(k == 3u) qp = u_deposit;
      if(k == 4u) qm = u_deposit;
    }

    v_mass = mass;
    v_qp = qp;
    v_qm = qm;
    vec2 p = pos / u_bounds;
    gl_Position = vec4(p, 0.0, 1.0);
    gl_PointSize = 1.0;
  }`;

  const FS_FIELD_DEPOSIT = `#version 300 es
  precision highp float;
  in float v_mass;
  in float v_qp;
  in float v_qm;
  out vec4 o_col;
  void main(){ o_col = vec4(v_mass, v_qp, v_qm, 1.0); }`;

  const FS_PHYS = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform sampler2D u_field;
  uniform sampler2D u_fieldRaw;
  uniform vec2  u_fieldTexel;

  uniform int   u_tm;
  uniform uint  u_frame;

  uniform int   u_kernelOn;
  uniform int   u_fieldOn;
  uniform int   u_mouseOn;
  uniform int   u_chaosOn;
  uniform int   u_pumpOn;
  uniform int   u_exactIFS;

  uniform float u_grav;
  uniform float u_pump;
  uniform float u_charge;
  uniform float u_pressure;

  uniform vec2  u_mouse;
  uniform float u_mouseDown;
  uniform float u_mouseSign;

  uniform float u_damping;
  uniform float u_force;
  uniform float u_chaos;
  uniform float u_bounds;
  uniform float u_kick;

  uniform vec2  u_J;
  uniform vec2  u_ck[5];

  uniform float u_timeK;
  uniform float u_timeMin;
  uniform float u_tempo;
  uniform float u_vortex;

  layout(location=0) out vec4 o_state;
  layout(location=1) out vec4 o_k0;
  layout(location=2) out vec4 o_k1;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int add5i(int a,int b){ int s=a+b; return (s>=5)? s-5 : s; }
  int sub5i(int a,int b){ int s=a-b; return (s<0)? s+5 : s; }
  int neg5i(int x){ return (x==0)? 0 : 5-x; }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  int idx_map(int z, int tm){
    int i = (tm==0) ? z : (z+2);
    return (i>=5) ? (i-5) : i;
  }

  vec2 cmul(vec2 a, vec2 b){
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
  }

  float hashf(ivec2 c, int tm){
    int n = (c.x*73856093) ^ (c.y*19349663) ^ (tm*83492791);
    n = (n<<13) ^ n;
    int nn = (n*(n*n*15731 + 789221) + 1376312589);
    return fract(float(nn) * 0.00000000023283064);
  }

  void main(){
    ivec2 coord = ivec2(gl_FragCoord.xy);

    vec4 st = texelFetch(u_state, coord, 0);
    vec4 k0 = texelFetch(u_k0, coord, 0);
    vec4 k1 = texelFetch(u_k1, coord, 0);

    vec2 pos = st.xy;
    vec2 vel = st.zw;

    vec4 ok0 = k0;
    vec4 ok1 = k1;

    int idx = 0;
    int p1=0,p4=0,p1p=0,p4p=0,q=0,ts=0;
    int z0=0, q0=0;

    if(u_kernelOn == 1){
      p1  = int(k0.x + 0.5);
      p4  = int(k0.y + 0.5);
      p1p = int(k0.z + 0.5);
      p4p = int(k0.w + 0.5);
      q   = int(k1.x + 0.5);
      ts  = int(k1.y + 0.5);

      z0 = z_trace6(p1,p4,p1p,p4p,q,ts);
      q0 = q;
      idx = idx_map(z0, u_tm);

      if(idx==0){
        int tp=p1; p1=p4; p4=tp;
        tp=p1p; p1p=p4p; p4p=tp;
      } else if(idx==1){
        int tp=p1;  p1=neg5i(p1p); p1p=neg5i(tp);
        tp=p4;      p4=neg5i(p4p); p4p=neg5i(tp);
        q  = neg5i(q);
        ts = neg5i(ts);
      } else if(idx==2){
        int op1=p1, op4=p4, op1p=p1p, op4p=p4p, ots=ts;
        p1  = add5i(neg5i(op1p), 2);
        p4  = add5i(add5i(neg5i(op4p), 1), ots);
        p1p = add5i(neg5i(op1),  2);
        p4p = add5i(add5i(neg5i(op4),  1), neg5i(ots));
        q   = sub5i(1, q);
        ts  = neg5i(ots);
      } else if(idx==3){
        p1  = sub5i(2,p1);  p4  = sub5i(1,p4);
        p1p = sub5i(3,p1p); p4p = sub5i(4,p4p);
        q   = sub5i(1,q);   ts  = sub5i(1,ts);
      } else {
        p1  = sub5i(2,p1);  p4  = sub5i(1,p4);
        p1p = sub5i(3,p1p); p4p = sub5i(4,p4p);
        q   = sub5i(2,q);   ts  = sub5i(1,ts);
      }
    } else {
      uint uid = uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x);
      uint h = hash(uid + u_frame * 1923u);
      idx = int(h % 5u);
    }

    vec2 target = u_ck[idx] + cmul(u_J, pos);

    if(u_exactIFS == 1){
      pos = target;
      vel = vec2(0.0);
      if(abs(pos.x) > u_bounds){ pos.x = sign(pos.x) * u_bounds; }
      if(abs(pos.y) > u_bounds){ pos.y = sign(pos.y) * u_bounds; }
      o_state = vec4(pos, vel);
      if(u_kernelOn == 1){
        o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
        o_k1 = vec4(float(q), float(ts), 0.0, 0.0);
      } else {
        o_k0 = ok0;
        o_k1 = ok1;
      }
      return;
    }

    vec2 acc = (target - pos) * u_force;

    float N = 1.0;

    if(u_fieldOn == 1){
      vec2 uv = pos / u_bounds * 0.5 + 0.5;
      uv = clamp(uv, vec2(0.001), vec2(0.999));

      float rho = texture(u_field, uv).r;

      N = 1.0 / (1.0 + u_timeK * rho);
      N = clamp(N, u_timeMin, 1.0);

      if(u_grav > 0.0){
        float fx1 = texture(u_field, uv + vec2(u_fieldTexel.x, 0.0)).r;
        float fx0 = texture(u_field, uv - vec2(u_fieldTexel.x, 0.0)).r;
        float fy1 = texture(u_field, uv + vec2(0.0, u_fieldTexel.y)).r;
        float fy0 = texture(u_field, uv - vec2(0.0, u_fieldTexel.y)).r;
        vec2 gradL = vec2(fx1 - fx0, fy1 - fy0);
        // vir: rotuj gradient (0 = radial pad, 1 = cisty orbit)
        vec2 curl = vec2(-gradL.y, gradL.x);
        vec2 gForce = mix(gradL, curl, u_vortex);
        acc += gForce * u_grav;
      }

      vec4 raw_xp = texture(u_fieldRaw, uv + vec2(u_fieldTexel.x, 0.0));
      vec4 raw_xm = texture(u_fieldRaw, uv - vec2(u_fieldTexel.x, 0.0));
      vec4 raw_yp = texture(u_fieldRaw, uv + vec2(0.0, u_fieldTexel.y));
      vec4 raw_ym = texture(u_fieldRaw, uv - vec2(0.0, u_fieldTexel.y));

      if(u_pressure > 0.0){
        vec2 gradS = vec2(raw_xp.r - raw_xm.r, raw_yp.r - raw_ym.r);
        acc -= gradS * u_pressure;
      }

      if(u_charge > 0.0){
        vec4 raw_here = texture(u_fieldRaw, uv);
        float rhoQ = raw_here.g - raw_here.b;
        float Q = sign(rhoQ);
        float qxp = raw_xp.g - raw_xp.b;
        float qxm = raw_xm.g - raw_xm.b;
        float qyp = raw_yp.g - raw_yp.b;
        float qym = raw_ym.g - raw_ym.b;
        vec2 gradQ = vec2(qxp - qxm, qyp - qym);
        acc += Q * gradQ * u_charge;
      }
    }

    if(u_mouseOn == 1 && u_mouseDown > 0.5){
      vec2 md = pos - u_mouse;
      float d2 = dot(md, md) + 0.002;
      if(d2 < 0.6){
        acc += normalize(md) * (0.06 / d2) * u_mouseSign;
      }
    }

    if(u_chaosOn == 1 && u_chaos > 0.0){
      float h = hashf(coord, u_tm);
      float ang = h * 6.2831853;
      acc += vec2(cos(ang), sin(ang)) * (u_chaos * 0.006);
    }

    float dt = N * u_tempo;

    float accLen = length(acc);
    if(accLen > 0.5) acc *= 0.5 / accLen;

    vel += acc * dt;
    vel *= mix(1.0, u_damping, dt);

    if(u_kernelOn==1 && u_pumpOn==1 && u_tm==0 && z0==4 && u_pump > 0.0){
      float ang = 6.2831853 * float(q0) / 5.0;
      vel += vec2(cos(ang), sin(ang)) * u_pump;
    }

    {
      uint tid = hash(uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x) + u_frame * 3571u);
      float ta = float(tid & 0xFFFFu) / 65535.0 * 6.2831853;
      float thermal = (u_fieldOn == 0) ? 0.003 : 0.0005;
      vel += vec2(cos(ta), sin(ta)) * (thermal + u_kick);
    }

    float vLen = length(vel);
    if(vLen > 1.0) vel *= 1.0 / vLen;

    pos += vel * dt;

    if(any(isnan(pos)) || any(isinf(pos)) || any(isnan(vel)) || any(isinf(vel))){
      uint rid = hash(uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x) + u_frame * 7919u);
      uint rid2 = hash(rid);
      float rx = float(rid  & 0xFFFFu) / 32767.5 - 1.0;
      float ry = float(rid2 & 0xFFFFu) / 32767.5 - 1.0;
      pos = vec2(rx, ry) * u_bounds * 0.8;
      vel = vec2(0.0);
    }

    if(abs(pos.x) > u_bounds){ pos.x = sign(pos.x) * u_bounds; vel.x *= -0.45; }
    if(abs(pos.y) > u_bounds){ pos.y = sign(pos.y) * u_bounds; vel.y *= -0.45; }

    o_state = vec4(pos, vel);

    if(u_kernelOn == 1){
      o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
      o_k1 = vec4(float(q), float(ts), 0.0, 0.0);
    } else {
      o_k0 = ok0;
      o_k1 = ok1;
    }
  }`;

  const VS_POINTS = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform float u_aspect;
  uniform float u_scale;
  uniform float u_rot;
  uniform vec2  u_pan;

  uniform int  u_tm;
  uniform uint u_frame;
  uniform int  u_kernelOn;
  uniform int  u_exactIFS;
  uniform sampler2D u_fieldBlur;
  uniform float u_bounds;

  out float v_speed;
  flat out float v_z;
  flat out float v_gyron;
  out float v_charge;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};

    vec4 st = texelFetch(u_state, ivec2(xx,yy), 0);
    vec2 pos = st.xy;
    vec2 vel = st.zw;
    v_speed = length(vel);

    // nabojovy pomer z rozmazaneho pole (casove vyhlazeny, stabilni)
    vec2 fuv = pos / u_bounds * 0.5 + 0.5;
    fuv = clamp(fuv, vec2(0.001), vec2(0.999));
    vec4 f = texture(u_fieldBlur, fuv);
    float qp = f.g;
    float qm = f.b;
    v_charge = (qp - qm) / (qp + qm + 0.001);

    int z = 1;
    int idx = 0;

    if(u_kernelOn == 1){
      vec4 k0 = texelFetch(u_k0, ivec2(xx,yy), 0);
      vec4 k1 = texelFetch(u_k1, ivec2(xx,yy), 0);
      int p1  = int(k0.x + 0.5);
      int p4  = int(k0.y + 0.5);
      int p1p = int(k0.z + 0.5);
      int p4p = int(k0.w + 0.5);
      int q   = int(k1.x + 0.5);
      int ts  = int(k1.y + 0.5);
      z = z_trace6(p1,p4,p1p,p4p,q,ts);
      v_gyron = (u_tm==0 && z==4) ? 1.0 : 0.0;
    } else {
      uint uid = uint(yy) * uint(${TEX_SIZE}) + uint(xx);
      uint h = hash(uid + u_frame * 1923u);
      idx = int(h % 5u);
      z = idx;
      v_gyron = (u_tm==0 && idx==4) ? 1.0 : 0.0;
    }

    v_z = float(z);

    float c = cos(u_rot);
    float s = sin(u_rot);
    vec2 rp = vec2(c*pos.x - s*pos.y, s*pos.x + c*pos.y);

    gl_Position = vec4((rp.x / u_aspect) * u_scale + u_pan.x, rp.y * u_scale + u_pan.y, 0.0, 1.0);
    gl_PointSize = (u_exactIFS == 1) ? 2.0 : 1.0;
  }`;

  const FS_POINTS = `#version 300 es
  precision highp float;
  precision highp int;
  in float v_speed;
  flat in float v_z;
  flat in float v_gyron;
  in float v_charge;
  uniform float u_scale;
  uniform float u_alphaMul;
  uniform int u_exactIFS;
  uniform int u_palette;
  out vec4 o_col;

  vec3 pal(int z, int p){
    if(p==0){
      if(z==0) return vec3(0.65, 0.55, 0.50);
      if(z==1) return vec3(0.60, 0.58, 0.48);
      if(z==2) return vec3(0.48, 0.62, 0.52);
      if(z==3) return vec3(0.48, 0.52, 0.65);
      return        vec3(0.55, 0.62, 0.65);
    }
    if(p==1){
      if(z==0) return vec3(0.95, 0.30, 0.12);
      if(z==1) return vec3(0.95, 0.72, 0.12);
      if(z==2) return vec3(0.15, 0.90, 0.40);
      if(z==3) return vec3(0.30, 0.50, 1.00);
      return        vec3(0.10, 0.85, 1.00);
    }
    if(p==2){
      if(z==0) return vec3(0.10, 0.18, 0.55);
      if(z==1) return vec3(0.05, 0.45, 0.70);
      if(z==2) return vec3(0.10, 0.72, 0.65);
      if(z==3) return vec3(0.30, 0.85, 0.85);
      return        vec3(0.60, 0.95, 1.00);
    }
    if(p==3){
      if(z==0) return vec3(0.75, 0.30, 0.10);
      if(z==1) return vec3(0.85, 0.60, 0.15);
      if(z==2) return vec3(0.30, 0.60, 0.12);
      if(z==3) return vec3(0.18, 0.45, 0.22);
      return        vec3(0.75, 0.50, 0.25);
    }
    if(p==4){
      if(z==0) return vec3(0.20, 0.0, 0.40);
      if(z==1) return vec3(0.65, 0.0, 0.45);
      if(z==2) return vec3(1.00, 0.25, 0.05);
      if(z==3) return vec3(1.00, 0.72, 0.10);
      return        vec3(1.00, 1.00, 0.70);
    }
    if(p==5){
      if(z==0) return vec3(1.00, 0.55, 0.60);
      if(z==1) return vec3(1.00, 0.80, 0.50);
      if(z==2) return vec3(0.55, 1.00, 0.65);
      if(z==3) return vec3(0.50, 0.65, 1.00);
      return        vec3(0.80, 0.55, 1.00);
    }
    // palety 6-8: ignoruji z, barveni z pole
    return vec3(1.0);
  }

  void main(){
    float e = clamp(v_speed * 28.0, 0.0, 1.0);
    bool vivid = (u_palette >= 6);

    if(!vivid){
      // palety 0-5: beze zmeny
      int z = int(v_z + 0.5);
      vec3 c = pal(z, u_palette);
      c = mix(c*0.55, c, e);
      if(v_gyron > 0.5) c = mix(c, vec3(1.0, 0.75, 0.95), 0.45);
      float alpha = 0.14 * u_scale * u_scale * u_alphaMul;
      if(u_exactIFS == 1){
        if(v_gyron > 0.5) c = pal(int(v_z + 0.5), u_palette);
        alpha = 0.008 * u_alphaMul;
        if(v_gyron > 0.5) c = mix(c, vec3(1.0, 0.75, 0.95), 0.45);
        o_col = vec4(c, clamp(alpha, 0.001, 0.1));
      } else {
        o_col = vec4(c, clamp(alpha, 0.001, 0.20));
      }
      return;
    }

    // palety 6-8: barva z nabojoveho pole
    // v_charge: -1 (zaporny) .. 0 (neutralni) .. +1 (kladny)
    float q = clamp(v_charge, -1.0, 1.0);

    vec3 warm, cool, neutral;
    if(u_palette == 6){
      warm    = vec3(1.00, 0.08, 0.30);
      cool    = vec3(0.10, 0.40, 1.00);
      neutral = vec3(0.0, 1.00, 0.35);
    } else if(u_palette == 7){
      warm    = vec3(1.00, 0.0, 0.75);
      cool    = vec3(0.0, 0.85, 1.00);
      neutral = vec3(0.85, 1.00, 0.0);
    } else if(u_palette == 8){
      warm    = vec3(1.00, 0.0, 0.0);
      cool    = vec3(0.0, 0.0, 1.00);
      neutral = vec3(0.0, 1.00, 0.0);
    } else if(u_palette == 9){
      // ohen: zluta (kladny) -> oranzova (neutral) -> tmava cervena/dym (zaporny)
      warm    = vec3(1.00, 0.95, 0.20);
      cool    = vec3(0.18, 0.06, 0.03);
      neutral = vec3(0.95, 0.35, 0.05);
    } else {
      // ocean: bila pena (kladny) -> tyrkys (neutral) -> hluboka tma (zaporny)
      warm    = vec3(0.85, 0.95, 1.00);
      cool    = vec3(0.01, 0.03, 0.12);
      neutral = vec3(0.05, 0.35, 0.55);
    }

    vec3 c = (q > 0.0) ? mix(neutral, warm, q) : mix(neutral, cool, -q);

    float alpha = 0.35 * u_scale * u_scale * u_alphaMul;
    if(u_exactIFS == 1) alpha = 0.02 * u_alphaMul;
    o_col = vec4(c, clamp(alpha, 0.001, 0.50));
  }`;

  // =========================
  // Programs
  // =========================
  const progInit      = program(VS_QUAD, FS_INIT);
  const progPhys      = program(VS_QUAD, FS_PHYS);
  const progPts       = program(VS_POINTS, FS_POINTS);
  const progFade      = program(VS_QUAD, FS_FADE);
  const progBlit      = program(VS_QUAD, FS_BLIT);
  const progFieldFade = program(VS_QUAD, FS_FIELD_FADE);
  const progFieldDep  = program(VS_POINTS_FIELD, FS_FIELD_DEPOSIT);
  const progBlur      = program(VS_QUAD, FS_BLUR);

  // =========================
  // VAO
  // =========================
  const vaoQuad = gl.createVertexArray();
  gl.bindVertexArray(vaoQuad);
  const quadBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  const vaoEmpty = gl.createVertexArray();

  // =========================
  // Particle textures (ping-pong)
  // =========================
  const IFMT = gl.RGBA16F;
  const FMT  = gl.RGBA;
  const TYPE = gl.HALF_FLOAT;

  const stateTex = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];
  const k0Tex    = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];
  const k1Tex    = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];

  const fboPart = [
    fboMRT([stateTex[0], k0Tex[0], k1Tex[0]]),
    fboMRT([stateTex[1], k0Tex[1], k1Tex[1]])
  ];

  // =========================
  // Field (RGBA16F) + blur
  // =========================
  const fieldTex  = [tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR),
                     tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR)];
  const fieldBlur = [tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR),
                     tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR)];
  const fieldTemp = tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);

  const fboField = [fboMRT([fieldTex[0]]), fboMRT([fieldTex[1]])];
  const fboBlur  = [fboMRT([fieldBlur[0]]), fboMRT([fieldBlur[1]])];
  const fboTemp  = fboMRT([fieldTemp]);

  function clearFBO(f, w, h){
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    gl.viewport(0,0,w,h);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  function clearField(){
    clearFBO(fboField[0], FIELD_SIZE, FIELD_SIZE);
    clearFBO(fboField[1], FIELD_SIZE, FIELD_SIZE);
    clearFBO(fboBlur[0],  FIELD_SIZE, FIELD_SIZE);
    clearFBO(fboBlur[1],  FIELD_SIZE, FIELD_SIZE);
    clearFBO(fboTemp,     FIELD_SIZE, FIELD_SIZE);
  }
  function clearTrail(){
    if(trailFbo[0]) clearFBO(trailFbo[0], viewW, viewH);
    if(trailFbo[1]) clearFBO(trailFbo[1], viewW, viewH);
  }

  // =========================
  // Trail (ping-pong)
  // =========================
  let trailTex = [null, null];
  let trailFbo = [null, null];
  let trailFlip = 0;

  function makeTrailTargets(w,h){
    if(trailTex[0]){ gl.deleteTexture(trailTex[0]); gl.deleteTexture(trailTex[1]); }
    if(trailFbo[0]){ gl.deleteFramebuffer(trailFbo[0]); gl.deleteFramebuffer(trailFbo[1]); }

    trailTex[0] = tex2D(w, h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);
    trailTex[1] = tex2D(w, h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);
    trailFbo[0] = fboMRT([trailTex[0]]);
    trailFbo[1] = fboMRT([trailTex[1]]);

    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[0]);
    gl.viewport(0,0,w,h);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[1]);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  // =========================
  // Uniforms (cache)
  // =========================
  const uInit = { seed: U(progInit, 'u_seed') };

  const uPhys = {
    state: U(progPhys,'u_state'), k0: U(progPhys,'u_k0'), k1: U(progPhys,'u_k1'),
    field: U(progPhys,'u_field'), fieldRaw: U(progPhys,'u_fieldRaw'),
    fieldTexel: U(progPhys,'u_fieldTexel'),
    tm: U(progPhys,'u_tm'), frame: U(progPhys,'u_frame'),
    kernelOn: U(progPhys,'u_kernelOn'), fieldOn: U(progPhys,'u_fieldOn'),
    mouseOn: U(progPhys,'u_mouseOn'), chaosOn: U(progPhys,'u_chaosOn'),
    pumpOn: U(progPhys,'u_pumpOn'), exactIFS: U(progPhys,'u_exactIFS'),
    grav: U(progPhys,'u_grav'), pump: U(progPhys,'u_pump'),
    charge: U(progPhys,'u_charge'), pressure: U(progPhys,'u_pressure'),
    mouse: U(progPhys,'u_mouse'), mouseDown: U(progPhys,'u_mouseDown'),
    mouseSign: U(progPhys,'u_mouseSign'),
    damping: U(progPhys,'u_damping'), force: U(progPhys,'u_force'),
    chaos: U(progPhys,'u_chaos'), bounds: U(progPhys,'u_bounds'),
    J: U(progPhys,'u_J'), ck0: U(progPhys,'u_ck[0]'),
    timeK: U(progPhys,'u_timeK'), timeMin: U(progPhys,'u_timeMin'),
    tempo: U(progPhys,'u_tempo'),
    vortex: U(progPhys,'u_vortex'),
    kick: U(progPhys,'u_kick'),
  };

  const uPts = {
    state: U(progPts,'u_state'), k0: U(progPts,'u_k0'), k1: U(progPts,'u_k1'),
    aspect: U(progPts,'u_aspect'), scale: U(progPts,'u_scale'),
    rot: U(progPts,'u_rot'), pan: U(progPts,'u_pan'),
    tm: U(progPts,'u_tm'), frame: U(progPts,'u_frame'),
    kernelOn: U(progPts,'u_kernelOn'), alphaMul: U(progPts,'u_alphaMul'),
    exactIFS: U(progPts,'u_exactIFS'),
    palette: U(progPts,'u_palette'),
    fieldBlur: U(progPts,'u_fieldBlur'),
    bounds: U(progPts,'u_bounds'),
  };

  const uFade = { prev: U(progFade,'u_prev'), fade: U(progFade,'u_fade') };
  const uBlit = { tex: U(progBlit,'u_tex'), palette: U(progBlit,'u_palette') };
  const uFieldFade = { prev: U(progFieldFade,'u_prev'), fade: U(progFieldFade,'u_fade') };

  const uFieldDep = {
    state: U(progFieldDep,'u_state'), k0: U(progFieldDep,'u_k0'), k1: U(progFieldDep,'u_k1'),
    bounds: U(progFieldDep,'u_bounds'), tm: U(progFieldDep,'u_tm'),
    frame: U(progFieldDep,'u_frame'), kernelOn: U(progFieldDep,'u_kernelOn'),
    deposit: U(progFieldDep,'u_deposit'),
  };

  const uBlur = { tex: U(progBlur,'u_tex'), dir: U(progBlur,'u_dir') };

  // =========================
  // TWIST constants (IFS)
  // =========================
  const angJ = 4*Math.PI/5;
  const Jre = 1 + Math.cos(angJ);
  const Jim = Math.sin(angJ);

  const oneMinusJ = { re: (1 - Jre), im: (0 - Jim) };
  const CK = new Float32Array(10);
  for(let k=0;k<5;k++){
    const a = 2*Math.PI*k/5;
    const wre = Math.cos(a), wim = Math.sin(a);
    const cre = oneMinusJ.re*wre - oneMinusJ.im*wim;
    const cim = oneMinusJ.re*wim + oneMinusJ.im*wre;
    CK[2*k+0] = cre;
    CK[2*k+1] = cim;
  }

  // =========================
  // Resize
  // =========================
  let viewW=0, viewH=0, dpr=1;
  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width  * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(w===viewW && h===viewH) return;
    viewW=w; viewH=h;
    canvas.width = w;
    canvas.height = h;
    makeTrailTargets(w,h);
  }
  window.addEventListener('resize', resize);

  let needLayout = true;
  function layout(){
    const topH = document.body.classList.contains('ui-hidden') ? 0 : 44;
    canvas.style.height = (window.innerHeight - topH) + "px";
    canvas.style.width = "100%";
    resize();
    needLayout = false;
  }
  window.addEventListener('resize', () => { needLayout = true; });
  layout();

  // =========================
  // Mouse
  // =========================
  let mouseNX = 0, mouseNY = 0;
  let mx=0, my=0, mDown=0;
  let viewRot = 0.0;
  let panX = 0, panY = 0;
  let prevScale = parseFloat(ui.scale.value);
  let isPanning = false;
  let panStartNX = 0, panStartNY = 0;
  let panStartX = 0, panStartY = 0;
  let usingTouch = false;  // blokuj mys behem dotyku

  function updateMouse(e){
    if(usingTouch) return;
    const rect = canvas.getBoundingClientRect();
    const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const ny = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    if(isPanning){
      panX = panStartX + (nx - panStartNX);
      panY = panStartY + (ny - panStartNY);
      return;
    }
    mouseNX = nx;
    mouseNY = ny;
  }
  window.addEventListener('mousemove', updateMouse);

  window.addEventListener('mousedown', (e) => {
    if(usingTouch) return;
    if(e.target !== canvas) return;
    if(e.shiftKey){
      isPanning = true;
      const rect = canvas.getBoundingClientRect();
      panStartNX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      panStartNY = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      panStartX = panX;
      panStartY = panY;
    } else {
      mDown = 1;
    }
  });
  window.addEventListener('mouseup', ()=>{ if(!usingTouch){ mDown=0; isPanning=false; } });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dy = e.deltaY;

    if (e.shiftKey) {
      viewRot += dy * 0.0025;
      if (viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if (viewRot < -Math.PI) viewRot += 2 * Math.PI;
      return;
    }

    const min = parseFloat(ui.scale.min);
    const max = parseFloat(ui.scale.max);
    const s   = parseFloat(ui.scale.value);
    const factor = Math.exp(-dy * 0.001);
    let ns = Math.min(max, Math.max(min, s * factor));

    // zoom smerem ke kurzoru: bod pod kurzorem zustane na miste
    const rect = canvas.getBoundingClientRect();
    const cx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const cy = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    const r = ns / s;
    panX = cx * (1 - r) + panX * r;
    panY = cy * (1 - r) + panY * r;
    prevScale = ns;

    ui.scale.value = ns.toFixed(2);
  }, { passive: false });

  // =========================
  // Touch
  // =========================
  let touchCount = 0;
  let prevPinchDist = 0;
  let prevPinchAngle = 0;
  let prevTouchCX = 0, prevTouchCY = 0;

  function touchCenter(t0, t1){
    return { x: (t0.clientX + t1.clientX) / 2, y: (t0.clientY + t1.clientY) / 2 };
  }
  function touchDist(t0, t1){
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }
  function touchAngle(t0, t1){
    return Math.atan2(t1.clientY - t0.clientY, t1.clientX - t0.clientX);
  }
  function touchToNorm(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    mouseNX = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouseNY = -(((clientY - rect.top) / rect.height) * 2 - 1);
  }

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    usingTouch = true;
    touchCount = e.touches.length;
    if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
    } else if(touchCount >= 2){
      mDown = 0;
      prevPinchDist = touchDist(e.touches[0], e.touches[1]);
      prevPinchAngle = touchAngle(e.touches[0], e.touches[1]);
      const c = touchCenter(e.touches[0], e.touches[1]);
      prevTouchCX = c.x;
      prevTouchCY = c.y;
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    touchCount = e.touches.length;
    if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
    } else if(touchCount >= 2){
      mDown = 0;
      const dist = touchDist(e.touches[0], e.touches[1]);
      const angle = touchAngle(e.touches[0], e.touches[1]);
      const center = touchCenter(e.touches[0], e.touches[1]);

      if(prevPinchDist > 0){
        const oldS = parseFloat(ui.scale.value);
        const ratio = dist / prevPinchDist;
        const min = parseFloat(ui.scale.min);
        const max = parseFloat(ui.scale.max);
        let ns = Math.min(max, Math.max(min, oldS * ratio));
        ui.scale.value = ns.toFixed(2);

        // zoom smerem ke stredu pinche
        const rect = canvas.getBoundingClientRect();
        const cx = ((center.x - rect.left) / rect.width) * 2 - 1;
        const cy = -(((center.y - rect.top) / rect.height) * 2 - 1);
        const r = ns / oldS;
        panX = cx * (1 - r) + panX * r;
        panY = cy * (1 - r) + panY * r;
        prevScale = ns;
      }

      let da = angle - prevPinchAngle;
      if(da > Math.PI) da -= 2 * Math.PI;
      if(da < -Math.PI) da += 2 * Math.PI;
      viewRot -= da;
      if(viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if(viewRot < -Math.PI) viewRot += 2 * Math.PI;

      const rect = canvas.getBoundingClientRect();
      const dx = (center.x - prevTouchCX) / rect.width * 2;
      const dy = -(center.y - prevTouchCY) / rect.height * 2;
      panX += dx;
      panY += dy;

      prevPinchDist = dist;
      prevPinchAngle = angle;
      prevTouchCX = center.x;
      prevTouchCY = center.y;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchCount = e.touches.length;
    if(touchCount === 0){
      mDown = 0;
    } else if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
      prevPinchDist = 0;
    }
  }, { passive: false });

  canvas.addEventListener('touchcancel', () => {
    mDown = 0;
    touchCount = 0;
    prevPinchDist = 0;
  });

  // =========================
  // TM bit
  // =========================
  function popcount32(v){
    v = v - ((v >>> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
    return (((v + (v >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
  }
  function thueMorse32(v){ return popcount32(v>>>0) & 1; }

  // =========================
  // Reset / pause
  // =========================
  let seed = (Math.random()*1e9)>>>0;
  let frame = 0;
  let partFlip = 0;
  let fieldFlip = 0;
  let paused = false;
  let prevFieldOn = true;
  let kickFrames = 0;

  let prevExact = false;
  let savedScale = null;

  function reset(){
    seed = (Math.random()*1e9)>>>0;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[0]);
    gl.viewport(0,0,TEX_SIZE,TEX_SIZE);
    gl.useProgram(progInit);
    gl.uniform1ui(uInit.seed, seed);
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // pole zachovat: nove castice se okamzite chyti existujicich gradientu
    makeTrailTargets(viewW, viewH);

    partFlip = 0;
    // fieldFlip zachovan: pole bezi dal
    trailFlip = 0;
    frame = 0;
    viewRot = 0.0;
    panX = 0; panY = 0;
    prevScale = parseFloat(ui.scale.value);
    ui.spin.value = '0.000';
  }

  // VÝCHOZÍ: reset sliders to defaults + reset simulation
  const DEFAULTS = {
    tglKernel: true, tglField: true, tglMouse: true, tglChaos: true, tglPump: true, tglExact: false,
    mouseRepel: false,
    particles: '19', damping: '0.677', force: '0.3', chaos: '1.86',
    fade: '0.69', scale: '0.65', spin: '0.000', tempo: '1.00', palette: '1',
    ffield: '0.929', deposit: '3', grav: '1', pressure: '1.93',
    timeK: '38', timeMin: '0.07', charge: '5', vortex: '0.00', pump: '0.099',
    tempo: '1.00',
  };

  function restoreDefaults(){
    ui.tglKernel.checked = DEFAULTS.tglKernel;
    ui.tglField.checked  = DEFAULTS.tglField;
    ui.tglMouse.checked  = DEFAULTS.tglMouse;
    ui.tglChaos.checked  = DEFAULTS.tglChaos;
    ui.tglPump.checked   = DEFAULTS.tglPump;
    ui.tglExact.checked  = DEFAULTS.tglExact;
    if(DEFAULTS.mouseRepel) ui.mouseRepel.checked = true;
    else ui.mouseAttract.checked = true;

    for(const [k, v] of Object.entries(DEFAULTS)){
      if(ui[k] && ui[k].type === 'range') ui[k].value = v;
    }
    syncUI();
    clearField();
    fieldFlip = 0;
    reset();
  }

  document.getElementById('reset').addEventListener('click', reset);
  document.getElementById('defaults').addEventListener('click', restoreDefaults);
  document.getElementById('pause').addEventListener('click', ()=>{
    paused = !paused;
    document.getElementById('pause').innerHTML = paused ? "POKRAČOVAT <small>(SPC)</small>" : "PAUZA <small>(SPC)</small>";
  });

  ui.spin.addEventListener('dblclick', () => { ui.spin.value = '0.000'; });
  ui.tempo.addEventListener('dblclick', () => { ui.tempo.value = '1.00'; });
  ui.vortex.addEventListener('dblclick', () => { ui.vortex.value = '0.00'; });

  // =========================
  // Keyboard
  // =========================
  const helpEl = document.getElementById('helpOverlay');

  helpEl.addEventListener('click', (e) => {
    if(e.target === helpEl) helpEl.classList.remove('show');
  });

  function nudge(slider, delta){
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const step = parseFloat(slider.step) || 0.001;
    let v = parseFloat(slider.value) + delta * step;
    v = Math.min(max, Math.max(min, v));
    const dec = (slider.step.split('.')[1] || '').length;
    slider.value = v.toFixed(dec);
  }

  window.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    const k = e.key;
    const S = 5;

    switch(k){
      case 'h': case 'H':
        helpEl.classList.toggle('show');
        break;
      case 'Escape':
        helpEl.classList.remove('show');
        break;
      case 'u': case 'U':
        document.body.classList.toggle('ui-hidden');
        needLayout = true;
        break;
      case 'Tab':
        e.preventDefault();
        togglePanel();
        break;
      case 'c': case 'C':
        shareURL();
        break;
      case ' ':
        e.preventDefault();
        paused = !paused;
        document.getElementById('pause').innerHTML = paused ? 'POKRAČOVAT <small>(SPC)</small>' : 'PAUZA <small>(SPC)</small>';
        break;
      case 'r': case 'R':
        reset();
        break;
      case 'b': case 'B':
        restoreDefaults();
        break;
      case '1':
        ui.tglKernel.checked = !ui.tglKernel.checked;
        syncUI();
        break;
      case '2':
        ui.tglField.checked = !ui.tglField.checked;
        syncUI();
        break;
      case '3':
        ui.tglMouse.checked = !ui.tglMouse.checked;
        syncUI();
        break;
      case '4':
        ui.tglChaos.checked = !ui.tglChaos.checked;
        syncUI();
        break;
      case '5':
        ui.tglPump.checked = !ui.tglPump.checked;
        syncUI();
        break;
      case '6':
        ui.tglExact.checked = !ui.tglExact.checked;
        syncUI();
        break;
      case '7':
        nudge(ui.palette, -1);
        break;
      case '8':
        nudge(ui.palette, 1);
        break;
      case 'm': case 'M':
        if(ui.mouseRepel.checked) ui.mouseAttract.checked = true;
        else ui.mouseRepel.checked = true;
        syncUI();
        break;
      case 'p':
        nudge(ui.particles, S);
        break;
      case 'n':
        nudge(ui.particles, -S);
        break;
      case '+': case '=':
        nudge(ui.scale, S * 5);
        break;
      case '-': case '_':
        nudge(ui.scale, -S * 5);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        nudge(ui.spin, -S);
        break;
      case 'ArrowRight':
        e.preventDefault();
        nudge(ui.spin, S);
        break;
      case '0':
        viewRot = 0.0;
        panX = 0; panY = 0;
        ui.spin.value = '0.000';
        break;
      case 'ArrowUp':
        e.preventDefault();
        nudge(ui.grav, S);
        break;
      case 'ArrowDown':
        e.preventDefault();
        nudge(ui.grav, -S);
        break;
      case '[':
        nudge(ui.damping, -S);
        break;
      case ']':
        nudge(ui.damping, S);
        break;
      case ';':
        nudge(ui.force, -S);
        break;
      case "'":
        nudge(ui.force, S);
        break;
      case ',':
        nudge(ui.pressure, -S);
        break;
      case '.':
        nudge(ui.pressure, S);
        break;
      case 'q':
        nudge(ui.charge, -S);
        break;
      case 'a':
        nudge(ui.charge, S);
        break;
      case '<':
        nudge(ui.vortex, -S);
        break;
      case '>':
        nudge(ui.vortex, S);
        break;
      case 'w':
        nudge(ui.timeK, -S);
        break;
      case 's':
        nudge(ui.timeK, S);
        break;
      case 'e':
        nudge(ui.timeMin, -S);
        break;
      case 'd':
        nudge(ui.timeMin, S);
        break;
      case 't':
        nudge(ui.pump, -S);
        break;
      case 'g':
        nudge(ui.pump, S);
        break;
      case 'f':
        nudge(ui.deposit, -S);
        break;
      case 'v':
        nudge(ui.deposit, S);
        break;
      case 'z':
        nudge(ui.chaos, -S);
        break;
      case 'x':
        nudge(ui.chaos, S);
        break;
      case 'i':
        nudge(ui.fade, -S);
        break;
      case 'k':
        nudge(ui.fade, S);
        break;
      case 'o':
        nudge(ui.ffield, -S);
        break;
      case 'l':
        nudge(ui.ffield, S);
        break;
      case 'j':
        nudge(ui.tempo, -S);
        break;
      case 'y':
        nudge(ui.tempo, S);
        break;
    }
  });

  // =========================
  // FPS
  // =========================
  let lastT = performance.now(), acc=0, frames=0;

  // start
  reset();

  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.CULL_FACE);

  // =========================
  // Main loop
  // =========================
  function loop(){
    if(needLayout) layout();

    const now = performance.now();
    const dt = now - lastT; lastT = now;
    acc += dt; frames++;
    if(acc > 500){
      fpsEl.textContent = String(Math.round((frames*1000)/acc));
      frames=0; acc=0;
    }

    if(paused){
      requestAnimationFrame(loop);
      return;
    }

    const tm = thueMorse32(frame);
    tmEl.textContent = String(tm);
    document.getElementById('rotv').textContent = String(Math.round(viewRot * 180 / Math.PI));

    const spinSpeed = parseFloat(ui.spin.value);
    if (Math.abs(spinSpeed) > 0.0001) {
      viewRot += spinSpeed;
      if (viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if (viewRot < -Math.PI) viewRot += 2 * Math.PI;
    }

    const kernelOn = ui.tglKernel.checked ? 1 : 0;
    const fieldOn  = ui.tglField.checked  ? 1 : 0;
    const mouseOn  = ui.tglMouse.checked  ? 1 : 0;
    const chaosOn  = ui.tglChaos.checked  ? 1 : 0;
    const pumpOn   = (ui.tglPump.checked && kernelOn) ? 1 : 0;

    const mouseSign = ui.mouseAttract.checked ? -1.0 : 1.0;

    const damping = parseFloat(ui.damping.value);
    const force   = parseFloat(ui.force.value);
    const chaos   = parseFloat(ui.chaos.value);
    const fade    = parseFloat(ui.fade.value);
    const scale   = parseFloat(ui.scale.value);

    // kompenzace posunu pri zmene meritka: zachovat stred pohledu
    if(prevScale > 0.001 && Math.abs(scale - prevScale) > 0.0001){
      const ratio = scale / prevScale;
      panX *= ratio;
      panY *= ratio;
    }
    prevScale = scale;

    const ffield  = parseFloat(ui.ffield.value);
    const deposit = parseFloat(ui.deposit.value);
    const grav    = parseFloat(ui.grav.value);
    const pressure = parseFloat(ui.pressure.value);
    const pump    = parseFloat(ui.pump.value);
    const timeK   = parseFloat(ui.timeK.value);
    const timeMin = parseFloat(ui.timeMin.value);
    const charge  = parseFloat(ui.charge.value);
    const vortex  = parseFloat(ui.vortex.value);
    const tempo   = parseFloat(ui.tempo.value);

    activeN = Math.min(N, 1 << parseInt(ui.particles.value));
    pcEl.textContent = activeN.toLocaleString();

    const bounds = 2.2;

    // mouse -> world coords
    {
      const aspect = viewW / viewH;
      mx = ((mouseNX - panX) * aspect) / Math.max(0.001, scale);
      my = ((mouseNY - panY)) / Math.max(0.001, scale);
      const c = Math.cos(-viewRot);
      const s = Math.sin(-viewRot);
      const wx = c * mx - s * my;
      const wy = s * mx + c * my;
      mx = wx;
      my = wy;
    }

    // pole off->on transition
    if(fieldOn === 1 && !prevFieldOn){
      clearField();
      kickFrames = 180;
    }
    prevFieldOn = (fieldOn === 1);
    if(kickFrames > 0) kickFrames--;

    // exact IFS auto-zoom
    const exactOn = ui.tglExact.checked;
    if(exactOn && !prevExact){
      savedScale = parseFloat(ui.scale.value);
      const absJ = Math.sqrt(Jre*Jre + Jim*Jim);
      const absOneMinusJ = Math.sqrt(oneMinusJ.re*oneMinusJ.re + oneMinusJ.im*oneMinusJ.im);
      const attractorR = absOneMinusJ / (1.0 - absJ);
      const autoScale = Math.min(0.7 / attractorR, 5.0);
      ui.scale.value = autoScale.toFixed(2);
      clearTrail();
    }
    if(!exactOn && prevExact && savedScale !== null){
      ui.scale.value = savedScale.toFixed(2);
      savedScale = null;
      clearTrail();
    }
    prevExact = exactOn;

    // =========================
    // 0) Field: fade + deposit + blur
    // =========================
    {
      const fieldWrite = 1 - fieldFlip;

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboField[fieldWrite]);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progFieldFade);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldFlip]);
      gl.uniform1i(uFieldFade.prev, 0);
      gl.uniform1f(uFieldFade.fade, ffield);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);

      gl.useProgram(progFieldDep);
      gl.uniform1f(uFieldDep.bounds, bounds);
      gl.uniform1i(uFieldDep.tm, tm);
      gl.uniform1ui(uFieldDep.frame, frame>>>0);
      gl.uniform1i(uFieldDep.kernelOn, kernelOn);
      gl.uniform1f(uFieldDep.deposit, deposit * Math.max(1.0 - ffield, 0.005) * (FIELD_SIZE * FIELD_SIZE) / activeN);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
      gl.uniform1i(uFieldDep.state, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
      gl.uniform1i(uFieldDep.k0, 1);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
      gl.uniform1i(uFieldDep.k1, 2);

      gl.bindVertexArray(vaoEmpty);
      gl.drawArrays(gl.POINTS, 0, activeN);
      gl.disable(gl.BLEND);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboTemp);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progBlur);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldWrite]);
      gl.uniform1i(uBlur.tex, 0);
      gl.uniform2f(uBlur.dir, 1.0/FIELD_SIZE, 0.0);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur[fieldWrite]);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progBlur);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTemp);
      gl.uniform1i(uBlur.tex, 0);
      gl.uniform2f(uBlur.dir, 0.0, 1.0/FIELD_SIZE);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      fieldFlip = fieldWrite;
    }

    // =========================
    // 1) Physics step
    // =========================
    const activeRows = Math.min(TEX_SIZE, Math.ceil(activeN / TEX_SIZE));
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[1-partFlip]);
    gl.viewport(0,0,TEX_SIZE,activeRows);
    gl.useProgram(progPhys);

    gl.uniform1i(uPhys.tm, tm);
    gl.uniform1ui(uPhys.frame, frame>>>0);
    gl.uniform1i(uPhys.kernelOn, kernelOn);
    gl.uniform1i(uPhys.fieldOn,  fieldOn);
    gl.uniform1i(uPhys.mouseOn,  mouseOn);
    gl.uniform1i(uPhys.chaosOn,  chaosOn);
    gl.uniform1i(uPhys.pumpOn,   pumpOn);
    gl.uniform1i(uPhys.exactIFS, ui.tglExact.checked ? 1 : 0);

    gl.uniform1f(uPhys.grav, (fieldOn ? grav : 0.0));
    gl.uniform1f(uPhys.pump, (pumpOn ? pump : 0.0));
    gl.uniform1f(uPhys.charge, (fieldOn ? charge : 0.0));
    gl.uniform1f(uPhys.pressure, (fieldOn ? pressure : 0.0));

    gl.uniform2f(uPhys.mouse, mx, my);
    gl.uniform1f(uPhys.mouseDown, (mouseOn ? mDown : 0.0));
    gl.uniform1f(uPhys.mouseSign, mouseSign);

    gl.uniform1f(uPhys.chaos, (chaosOn ? chaos : 0.0));
    gl.uniform1f(uPhys.bounds, bounds);

    gl.uniform2f(uPhys.J, Jre, Jim);
    gl.uniform2fv(uPhys.ck0, CK);
    gl.uniform2f(uPhys.fieldTexel, 1.0/FIELD_SIZE, 1.0/FIELD_SIZE);
    gl.uniform1f(uPhys.timeK, fieldOn ? timeK : 0.0);
    gl.uniform1f(uPhys.timeMin, timeMin);
    gl.uniform1f(uPhys.tempo, tempo);
    gl.uniform1f(uPhys.vortex, vortex);

    const kickRatio = kickFrames > 0 ? kickFrames / 180.0 : 0.0;
    const kickStr = kickRatio * 0.05;
    gl.uniform1f(uPhys.kick, kickStr);

    const forceEff = kickFrames > 0 ? force * (1.0 - 0.9 * kickRatio) : force;
    const dampEff  = kickFrames > 0 ? Math.min(damping, 0.5 + 0.5 * (1.0 - kickRatio)) : damping;
    gl.uniform1f(uPhys.damping, dampEff);
    gl.uniform1f(uPhys.force, forceEff);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
    gl.uniform1i(uPhys.state, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
    gl.uniform1i(uPhys.k0, 1);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
    gl.uniform1i(uPhys.k1, 2);
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, fieldBlur[fieldFlip]);
    gl.uniform1i(uPhys.field, 3);
    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldFlip]);
    gl.uniform1i(uPhys.fieldRaw, 4);

    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    partFlip = 1 - partFlip;

    // =========================
    // 2) Trail: fade
    // =========================
    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[1-trailFlip]);
    gl.viewport(0,0,viewW,viewH);
    gl.useProgram(progFade);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, trailTex[trailFlip]);
    gl.uniform1i(uFade.prev, 0);
    gl.uniform1f(uFade.fade, exactOn ? 1.0 : fade);
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // =========================
    // 3) Points into trail (additive)
    // =========================
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

    gl.useProgram(progPts);
    gl.uniform1f(uPts.aspect, viewW / viewH);
    gl.uniform1f(uPts.scale, scale);
    gl.uniform1f(uPts.rot, viewRot);
    gl.uniform2f(uPts.pan, panX, panY);
    gl.uniform1i(uPts.tm, tm);
    gl.uniform1ui(uPts.frame, frame>>>0);
    gl.uniform1i(uPts.kernelOn, kernelOn);
    gl.uniform1f(uPts.alphaMul, Math.sqrt(1048576.0 / activeN));
    gl.uniform1i(uPts.exactIFS, ui.tglExact.checked ? 1 : 0);
    gl.uniform1i(uPts.palette, parseInt(ui.palette.value));
    gl.uniform1f(uPts.bounds, bounds);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
    gl.uniform1i(uPts.state, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
    gl.uniform1i(uPts.k0, 1);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
    gl.uniform1i(uPts.k1, 2);
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, fieldBlur[fieldFlip]);
    gl.uniform1i(uPts.fieldBlur, 3);

    gl.bindVertexArray(vaoEmpty);
    gl.drawArrays(gl.POINTS, 0, activeN);
    gl.disable(gl.BLEND);

    // =========================
    // 4) Blit to screen
    // =========================
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,viewW,viewH);
    gl.useProgram(progBlit);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, trailTex[1-trailFlip]);
    gl.uniform1i(uBlit.tex, 0);
    gl.uniform1i(uBlit.palette, parseInt(ui.palette.value));
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    trailFlip = 1 - trailFlip;

    // =========================
    // Histogram
    // =========================
    if(kernelOn && frame > 0 && (frame & 63) === 0){
      const SAMPLE = 256;
      const k0buf = new Float32Array(SAMPLE * 4);
      const k1buf = new Float32Array(SAMPLE * 4);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[partFlip]);
      gl.readBuffer(gl.COLOR_ATTACHMENT1);
      gl.readPixels(0, 0, SAMPLE, 1, gl.RGBA, gl.FLOAT, k0buf);
      gl.readBuffer(gl.COLOR_ATTACHMENT2);
      gl.readPixels(0, 0, SAMPLE, 1, gl.RGBA, gl.FLOAT, k1buf);
      gl.readBuffer(gl.COLOR_ATTACHMENT0);

      const zH = [0,0,0,0,0];
      const iH = [0,0,0,0,0];
      for(let j = 0; j < SAMPLE; j++){
        const p1  = Math.round(k0buf[j*4+0]);
        const p4  = Math.round(k0buf[j*4+1]);
        const p1p = Math.round(k0buf[j*4+2]);
        const p4p = Math.round(k0buf[j*4+3]);
        const q   = Math.round(k1buf[j*4+0]);
        const ts  = Math.round(k1buf[j*4+1]);
        let z = (p1+p4+p1p+p4p+q+ts) % 5;
        if(z < 0) z += 5;
        zH[z]++;
        let idx = (tm === 0) ? z : (z + 2) % 5;
        iH[idx]++;
      }

      const histZEl = document.getElementById('histZ');
      const histIEl = document.getElementById('histI');
      const histDiv = document.getElementById('histDiv');
      histDiv.style.display = '';
      histZEl.textContent = zH.map((v,k) => k+':'+v).join(' ');
      histIEl.textContent = iH.map((v,k) => 'abcde'[k]+':'+v).join(' ');
    }

    frame = (frame + 1) >>> 0;
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
