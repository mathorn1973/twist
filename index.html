<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>TWIST-J | A Finite Rule with Unbounded Evolution</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body{
    background:#06060a; color:#8a8a8a;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    height:100vh; overflow:hidden;
    overscroll-behavior:none; touch-action:none;
  }
  .top{
    height:44px; display:flex; align-items:baseline; gap:18px;
    padding:10px 16px; border-bottom:1px solid #141418; background:#06060a;
  }
  .top .t{ color:#00d2ff; letter-spacing:3px; font-size:12px; }
  .wrap{ position:relative; width:100%; height:calc(100vh - 44px); }
  canvas{ width:100%; height:100%; display:block; cursor:crosshair; touch-action:none; }
  .hud{
    position:absolute; top:14px; right:14px;
    font-size:11px; text-align:right; color:#4a4a4a; pointer-events:none;
  }
  .hud .v{ color:#00d2ff; }
  .panel{
    position:absolute; left:14px; bottom:14px;
    display:flex; flex-direction:column; gap:10px; pointer-events:auto;
    max-height:calc(100% - 28px); overflow-y:auto; overflow-x:hidden;
    scrollbar-width:thin; scrollbar-color:#1e1e28 transparent;
  }
  @media(max-width:1024px){
    .panel{ bottom:auto; top:4px; max-height:calc(100% - 8px); }
  }
  .panel::-webkit-scrollbar{ width:4px; }
  .panel::-webkit-scrollbar-thumb{ background:#1e1e28; border-radius:2px; }
  .btn-bar{
    pointer-events:auto;
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:4px;
    margin-bottom:6px;
  }
  .btn-bar button{ font-size:10px; padding:5px 4px; }
  @media(min-width:500px){
    .btn-bar{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn-bar button{ font-size:inherit; padding:revert; }
  }
  .credit{
    position:absolute; bottom:8px; right:14px;
    font-size:9px; color:#4a4a56; pointer-events:auto;
    letter-spacing:1px; text-decoration:none;
    padding:4px 8px; border:1px solid #1a1a24;
    border-radius:4px; background:rgba(6,6,10,0.7);
  }
  .credit:hover{ color:#00d2ff; border-color:#2a2a36; }
  .row{
    pointer-events:auto; display:flex; gap:10px; align-items:center;
    padding:6px 10px; border:1px solid #1e1e28;
    background:rgba(6,6,10,0.78); border-radius:6px;
  }
  .row.disabled{ opacity:0.35; }
  label{ width:130px; font-size:10px; color:#666; }
  label small{ color:#555; font-size:9px; }
  button small{ color:#777; font-size:9px; }
  .tog small{ color:#666; }
  input[type=range]{ width:210px; }
  .tog{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    font-size:11px; color:#8a8a8a;
  }
  .tog label{
    width:auto; color:#8a8a8a; font-size:11px;
    display:flex; align-items:center; gap:6px;
    cursor:pointer; user-select:none;
  }
  .tog input{ cursor:pointer; }
  button{
    pointer-events:auto; background:#0b0b12; color:#9a9a9a;
    border:1px solid #1e1e28; padding:6px 10px; border-radius:6px;
    cursor:pointer; font-size:11px;
  }
  button:hover{ border-color:#2a2a36; color:#cfcfcf; }
  input:disabled{ cursor:not-allowed; }
  .help-overlay{
    display:none; position:absolute; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:rgba(6,6,10,0.94); border:1px solid #1e1e28;
    border-radius:8px; padding:18px 24px;
    font-size:11px; color:#8a8a8a; pointer-events:auto;
    max-height:80vh; overflow-y:auto; z-index:10;
    min-width:320px;
  }
  .help-overlay.show{ display:block; }
  .help-overlay h3{ color:#00d2ff; font-size:12px; margin:10px 0 6px; letter-spacing:2px; }
  .help-overlay h3:first-child{ margin-top:0; }
  .help-overlay .krow{ display:flex; justify-content:space-between; padding:2px 0; }
  .help-overlay .kk{ color:#00d2ff; min-width:90px; }
  .invert-btn{
    display:none;
    position:absolute; bottom:52px; right:14px;
    padding:10px 16px; border-radius:8px;
    background:rgba(6,6,10,0.8); border:1px solid #1e1e28;
    color:#666; font-size:11px; letter-spacing:2px;
    pointer-events:auto; cursor:pointer;
    touch-action:none; user-select:none;
    -webkit-tap-highlight-color:transparent;
    z-index:4;
  }
  .invert-btn.active{
    background:rgba(0,210,255,0.15); border-color:#00d2ff;
    color:#00d2ff;
  }
  .invert-hud{
    display:none;
    position:absolute; top:14px; left:50%;
    transform:translateX(-50%);
    color:#00d2ff; font-size:11px; letter-spacing:3px;
    pointer-events:none; z-index:4;
  }
  .invert-hud.show{ display:block; }
  @media(pointer:coarse){
    .invert-btn{ display:block; }
  }
  .ui-hidden .top{ display:none; }
  .ui-hidden .hud{ display:none; }
  .ui-hidden .panel{ display:none; }
  .ui-hidden .help-overlay{ display:none; }
  .ui-hidden .credit{ display:none; }
  .ui-hidden .twistj-link{ display:none; }
  .ui-hidden #gameOverlay{ display:none !important; }
  .ui-hidden #gameOverlay.game-ended{ display:flex !important; }
  .ui-hidden.game-locked #gameOverlay.game-ended{ display:flex !important; }
  .ui-hidden .invert-btn{ display:none !important; }
  .ui-hidden .invert-hud{ display:none !important; }
  .ui-hidden .audio-btn{ display:none !important; }
  .audio-btn{
    position:absolute; bottom:8px; left:14px;
    width:32px; height:32px; border-radius:6px;
    background:rgba(6,6,10,0.8); border:1px solid #1e1e28;
    color:#555; font-size:16px; line-height:32px; text-align:center;
    pointer-events:auto; cursor:pointer; z-index:5;
    user-select:none; transition: color 0.2s, border-color 0.2s;
  }
  .audio-btn:hover{ color:#00d2ff; border-color:#2a2a36; }
  .audio-btn.playing{ color:#00d2ff; border-color:#00d2ff; }

  /* Game locked mode: fullscreen, no controls */
  .game-locked .hud{ display:none !important; }
  .game-locked .panel{ display:none !important; }
  .game-locked .help-overlay{ display:none !important; }
  .game-locked .invert-hud{ display:none !important; }
  .game-locked .audio-btn{
    display:block !important;
    position:fixed; bottom:12px; z-index:200;
  }
  .game-locked #audioBtn{ right:12px; left:auto; }
  .game-locked #fullscreenBtn{ right:52px; left:auto; }
  .game-locked .audio-btn.audio-hidden{ display:none !important; }
  .game-locked .top .t{ font-size:11px; }

  /* Demo mode: only floating buttons visible */
  .demo-mode .hud{ display:none !important; }
  .demo-mode .panel{ display:none !important; }
  .demo-mode .help-overlay{ display:none !important; }
  .demo-mode .invert-hud{ display:none !important; }
  .demo-mode .invert-btn{ display:none !important; }
  .demo-mode .top{ display:none !important; }
  .demo-mode .credit{ display:none !important; }
  .demo-mode .twistj-link{ display:none !important; }
  .demo-mode #gameLockedHud{ display:none !important; }
  .demo-mode #gameOverlay{ display:none !important; }
  .demo-mode .wrap{ height:100vh; }
  .demo-mode .audio-btn{
    display:block !important;
    position:fixed; bottom:12px; z-index:200;
    opacity:0.5; transition: opacity 0.3s;
  }
  .demo-mode .audio-btn:hover{ opacity:1; }
  .demo-mode #audioBtn{ left:12px; right:auto; }
  .demo-mode #fullscreenBtn{ left:52px; right:auto; }
  .demo-mode.ui-hidden .audio-btn{ display:block !important; }
  .game-locked #gameLockedHud{
    display:flex !important;
    position:absolute; top:36px; left:50%;
    transform:translateX(-50%);
    gap:16px; color:#555; font-size:11px; letter-spacing:2px;
    pointer-events:none; z-index:4;
  }
  .game-locked #gameLockedHud .gl-time{ color:#00d2ff; }
  .game-locked #gameLockedHud .gl-fill{ color:#555; }
  .game-locked #gameLockedHud .gl-status{ color:#0a0; }
  .ui-hidden .wrap{ height:100vh; }

  /* UI hidden overrides game-locked mode */
  .ui-hidden.game-locked .top{ display:none !important; }
  .ui-hidden.game-locked #gameLockedHud{ display:none !important; }
  .ui-hidden.game-locked .invert-btn{ display:none !important; }
  .ui-hidden.game-locked .credit{ display:none !important; }
  .ui-hidden.game-locked .twistj-link{ display:none !important; }
  .ui-hidden.game-locked .wrap{ height:100vh; }

  .row.stack{ flex-direction:column; align-items:stretch; }
  .row.stack label{ width:auto; }
  .row.stack input[type=range]{ width:100%; }

</style>
</head>
<body>
  <div class="top">
    <div class="t">TWIST-J: A FINITE RULE WITH UNBOUNDED EVOLUTION</div>
  </div>

  <div class="wrap">
    <canvas id="c"></canvas>

    <div class="hud">
      <div>PARTICLES <span class="v" id="pc">0</span></div>
      <div>FPS <span class="v" id="fps">0</span></div>
      <div>TM <span class="v" id="tm">0</span></div>
      <div>ROT <span class="v" id="rotv">0</span>&deg;</div>
      <div id="histDiv" style="display:none">z <span class="v" id="histZ">-</span> i <span class="v" id="histI">-</span></div>
    </div>

    <div class="panel">
      <div class="row" id="rowModules">
        <label>MODULES</label>
        <div class="tog">
          <label><input type="checkbox" id="tglKernel" checked>KERNEL <small>(1)</small></label>
          <label><input type="checkbox" id="tglField"  checked>FIELD <small>(2)</small></label>
          <label><input type="checkbox" id="tglMouse"  checked>MOUSE <small>(3)</small></label>
          <label><input type="checkbox" id="tglChaos"  checked>CHAOS <small>(4)</small></label>
        </div>
      </div>
      <div class="row" id="rowModules2">
        <label>EXTRAS</label>
        <div class="tog">
          <label><input type="checkbox" id="tglPump" checked>PUMP <small>(5)</small></label>
          <label><input type="checkbox" id="tglReact">REACT <small>(opt)</small></label>
          <label><input type="checkbox" id="tglExact">EXACT <small>(6)</small></label>
        </div>
      </div>

      <div class="row" id="rowMouseMode">
        <label>MOUSE MODE <small>(M)</small></label>
        <div class="tog">
          <label><input type="radio" name="mouseMode" id="mouseRepel">REPEL</label>
          <label><input type="radio" name="mouseMode" id="mouseAttract" checked>ATTRACT</label>
          <label style="margin-left:6px;color:#555;font-size:10px;cursor:pointer" onclick="document.getElementById('helpOverlay').classList.toggle('show')">H HELP</label>
        </div>
      </div>

      <div class="btn-bar">
        <button id="panelHide">HIDE <small>(TAB)</small></button>
        <button id="reset">RESET <small>(R)</small></button>
        <button id="defaults">DEFAULTS <small>(B)</small></button>
        <button id="pause">PAUSE <small>(ESC)</small></button>
        <button id="share">SHARE <small>(C)</small></button>
        <button id="gameBtn">GAME</button>
        <button id="demoBtn" style="color:#ff0;border-color:#553">DEMO</button>
      </div>

      <div id="slidersWrap">
      <div class="row" id="rowParticles">
        <label>PARTICLES <small>(P/N)</small></label>
        <input id="particles" type="range" min="12" max="23" step="1" value="19" />
      </div>

      <div class="row" id="rowTempo">
        <label>TEMPO <small>(J Y)</small></label>
        <input id="tempo" type="range" min="0.05" max="3.00" step="0.01" value="1.00" />
      </div>

      <div class="row" id="rowDamping">
        <label>DAMPING <small>([ ])</small></label>
        <input id="damping" type="range" min="0.50" max="1.000" step="0.001" value="0.677" />
      </div>

      <div class="row" id="rowForce">
        <label>IFS FORCE <small>(; ')</small></label>
        <input id="force" type="range" min="0.0000" max="2.000" step="0.0001" value="0.3" />
      </div>

      <div class="row" id="rowChaos">
        <label>CHAOS <small>(Z X)</small></label>
        <input id="chaos" type="range" min="0.0" max="5.0" step="0.01" value="1.86" />
      </div>

      <div class="row" id="rowFade">
        <label>TRAIL <small>(I K)</small></label>
        <input id="fade" type="range" min="0.50" max="1.000" step="0.001" value="0.69" />
      </div>

      <div class="row" id="rowScale">
        <label>SCALE <small>(+ &minus;)</small></label>
        <input id="scale" type="range" min="0.05" max="5.00" step="0.01" value="0.65" />
      </div>

      <div class="row" id="rowSpin">
        <label>SPIN <small>(&larr; &rarr;)</small></label>
        <input id="spin" type="range" min="-0.050" max="0.050" step="0.001" value="0.000" />
      </div>

      <div class="row" id="rowPalette">
        <label>PALETTE <small>(7 8)</small></label>
        <input id="palette" type="range" min="0" max="10" step="1" value="1" />
      </div>

      <div class="row" id="rowFieldFade">
        <label>FIELD FADE <small>(O L)</small></label>
        <input id="ffield" type="range" min="0.00" max="1.005" step="0.0001" value="0.929" />
      </div>

      <div class="row" id="rowDeposit">
        <label>DENSITY <small>(F V)</small></label>
        <input id="deposit" type="range" min="1" max="50" step="1" value="3" />
      </div>

      <div class="row" id="rowGrav">
        <label>GRAVITY <small>(&uarr; &darr;)</small></label>
        <input id="grav" type="range" min="0.000" max="2.000" step="0.001" value="1" />
      </div>

      <div class="row" id="rowPressure">
        <label>PRESSURE <small>(, .)</small></label>
        <input id="pressure" type="range" min="0.000" max="2.000" step="0.001" value="1.93" />
      </div>

      <div class="row" id="rowTimeK">
        <label>TIME K <small>(W S)</small></label>
        <input id="timeK" type="range" min="0" max="200" step="0.1" value="38" />
      </div>

      <div class="row" id="rowTimeMin">
        <label>TIME MIN <small>(E D)</small></label>
        <input id="timeMin" type="range" min="0.0001" max="1.00" step="0.0001" value="0.07" />
      </div>

      <div class="row" id="rowCharge">
        <label>CHARGE <small>(Q A)</small></label>
        <input id="charge" type="range" min="0.000" max="10.00" step="0.01" value="5" />
      </div>

      <div class="row" id="rowVortex">
        <label>VORTEX <small>(&lt; &gt;)</small></label>
        <input id="vortex" type="range" min="0.00" max="1.00" step="0.01" value="0.00" />
      </div>

      <div class="row" id="rowPump">
        <label>PUMP <small>(T G)</small></label>
        <input id="pump" type="range" min="0.000" max="0.200" step="0.001" value="0.099" />
      </div>

      <div class="row" id="rowReact">
        <label>REACT <small>(9 0)</small></label>
        <input id="react" type="range" min="0.00" max="3.00" step="0.01" value="1.00" />
      </div>
      </div>

      <div id="gameWrap" style="display:none">
      <div class="row">
        <label>GAME</label>
        <div class="tog">
          <label><input type="checkbox" id="gameEnabled">ENABLE</label>
          <label><input type="checkbox" id="gameShowZone" checked>SHOW ZONE</label>
        </div>
      </div>
      <div class="row">
        <label>MODE</label>
        <div class="tog">
          <label><input type="radio" name="gameMode" id="gameModeEmpty" checked>EMPTY</label>
          <label><input type="radio" name="gameMode" id="gameModeNotEmpty">FULL</label>
        </div>
      </div>
      <div class="row" id="rowGameX">
        <label>ZONE X</label>
        <input id="gameX" type="range" min="-0.90" max="0.90" step="0.01" value="0.00" />
      </div>
      <div class="row" id="rowGameY">
        <label>ZONE Y</label>
        <input id="gameY" type="range" min="-0.90" max="0.90" step="0.01" value="0.00" />
      </div>
      <div class="row" id="rowGameSize">
        <label>ZONE SIZE</label>
        <input id="gameSize" type="range" min="0.05" max="0.60" step="0.01" value="0.18" />
      </div>
      <div class="row" id="rowGameThresh">
        <label>THRESHOLD</label>
        <input id="gameThresh" type="range" min="0.001" max="0.200" step="0.001" value="0.030" />
      </div>
      <div class="row" id="rowGameCoverage">
        <label>COVERAGE</label>
        <input id="gameCoverage" type="range" min="0.001" max="0.800" step="0.005" value="0.100" />
      </div>
      <div class="row" id="rowGameGrace">
        <label>GRACE <small>(s)</small></label>
        <input id="gameGrace" type="range" min="0.1" max="5.0" step="0.1" value="0.7" />
      </div>
      
      
      
      <div class="row" id="rowGameWinArea">
        <label>WIN: AREA</label>
        <div class="tog">
          <label><input type="checkbox" id="gameWinArea" checked>ON</label>
          <span style="color:#555;font-size:10px">EMPTY: keep enemy area &lt; COVERAGE Â· FULL: keep friendly area &gt; COVERAGE</span>
        </div>
      </div>
      <div class="row" id="rowGameWinPresence">
        <label>WIN: PRESENCE</label>
        <div class="tog">
          <label><input type="checkbox" id="gameWinPresence">ON</label>
          <span style="color:#555;font-size:10px">EMPTY: no enemy pixels Â· FULL: at least one friendly pixel</span>
        </div>
      </div>
      <div class="row" id="rowGameDuality">
        <label>DUALITY <small>(opt)</small></label>
        <div class="tog">
          <label><input type="checkbox" id="gameDualOn">FRIENDLY / ENEMY <small>(MOUSE=FRIENDLY)</small></label>
        </div>
      </div>
      <div class="row stack" id="rowGameColors">
        <label>COLORS <small id="colorLabel">BLUE / PINK</small></label>
        <input id="gameColors" type="range" min="0" max="4" step="1" value="0" />
      </div>
      <div class="row stack" id="rowGameInitBalance">
        <label>INIT BALANCE <small>friendly:enemy</small></label>
        <input id="gameInitBalance" type="range" min="0.10" max="0.90" step="0.01" value="0.50" />
      </div>
      <div class="row stack" id="rowGameDualRate">
        <label>EAT RATE</label>
        <input id="gameDualRate" type="range" min="0.00" max="10.00" step="0.1" value="2.00" />
      </div>
      <div class="row" id="rowGamePowerEats">
        <label><input id="gamePowerEats" type="checkbox" /> POWER EATS</label>
        <span style="color:#555;font-size:10px">REINF multipliers also boost eating strength per side</span>
      </div>
      <div class="row" id="rowGameEnergyTransfer">
        <label><input id="gameEnergyTransfer" type="checkbox" checked /> ENERGY TRANSFER</label>
        <span style="color:#555;font-size:10px">Eating converts enemy into your own (snowball)</span>
      </div>
      <div class="row" id="rowGameDualEq">
        <label>BALANCE <small>(reinforcements)</small></label>
        <input id="gameDualEq" type="range" min="0.00" max="1.00" step="0.01" value="0.00" />
      </div>

      <div class="row stack" id="rowGameReinfFlow">
        <label>REINF FLOW</label>
        <input id="gameReinfFlow" type="range" min="0.00" max="5.00" step="0.01" value="0.00" />
      </div>
      <div class="row" id="rowGameReinfWaves">
        <label><input id="gameReinfWaves" type="checkbox" /> WAVES <small>(ENEMY only)</small></label>
      </div>

      <div class="row stack" id="rowGameReinfBlue">
        <label>REINF FRIENDLY</label>
        <input id="gameReinfBlue" type="range" min="0.00" max="3.00" step="0.01" value="1.00" />
      </div>
      <div class="row stack" id="rowGameReinfPink">
        <label>REINF ENEMY</label>
        <input id="gameReinfPink" type="range" min="0.00" max="3.00" step="0.01" value="1.00" />
      </div>
      <div class="row stack" id="rowGameDualCoh">
        <label>CLUSTER</label>
        <input id="gameDualCoh" type="range" min="0.00" max="200.00" step="0.05" value="1.20" />
      </div>
      <div class="btn-bar">
        <button id="gameStart">NEW RUN</button>
        <button id="gameStop" disabled>STOP</button>
        <button id="gameBack">&larr; BACK</button>
        <button id="gameLock">LOCK &amp; SHARE</button>
      </div>
      <div id="gameHud" style="text-align:center;padding:6px;font-size:11px;color:#666">
        <div>
          <span id="gameStatus">SETUP</span> &nbsp;
          <span style="color:#00d2ff" id="gameTimer">0.0s</span> &nbsp;
          <span id="gameFill" style="color:#666">0%</span>
        </div>
        <div style="margin-top:4px;color:#555;font-size:10px;letter-spacing:1px">
          <span id="gameAreaStat">AREA: -</span> &nbsp; | &nbsp;
          <span id="gamePresenceStat">PRES: -</span>
        </div>
        <div style="margin-top:4px;color:#555;font-size:10px;letter-spacing:1px">
          <span id="gameReinfStat">REINF: off</span>
        </div>
      </div>
      </div>
      </div>
    </div>

    <div class="help-overlay" id="helpOverlay">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h3 style="margin:0">TWIST-J</h3>
        <button onclick="document.getElementById('helpOverlay').classList.remove('show')" style="background:none;border:1px solid #2a2a36;color:#666;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:11px">&times; CLOSE</button>
      </div>
      <div style="color:#777;margin-bottom:8px;line-height:1.5">
        J-Operator: <span style="color:#00d2ff">J = 1 + &#950;&#8325;&sup2;</span> &mdash; a single algebraic axiom.<br>
        Thue-Morse sequence serves as time driver in TWIST-J.<br>
        Kernel: z=Tr(x), t=TM(n), i=(z+2t) mod 5, x&#8592;g&#7522;(x).<br>
        Field: gyron &#8594; mass(R), d/e &#8594; charge(G/B).<br>
        &#8711;&#961;L = gravity, -&#8711;&#961;S = pressure, sign(&#961;Q)&middot;&#8711;&#961;Q = plasma. &#961; &#8712; [0,1].<br>
        Time: d&#964;/dn = 1/(1+K&middot;&#961;).
      </div>
      <h3>TOGGLES</h3>
      <div class="krow"><span class="kk">ESC</span><span>pause / resume</span></div>
      <div class="krow"><span class="kk">SPACE (hold)</span><span>invert mouse attract/repel</span></div>
      <div class="krow"><span class="kk">R</span><span>reset (new particles, keep settings)</span></div>
      <div class="krow"><span class="kk">B</span><span>defaults (reset + all sliders to default)</span></div>
      <div class="krow"><span class="kk">1</span><span>KERNEL on/off</span></div>
      <div class="krow"><span class="kk">2</span><span>FIELD on/off</span></div>
      <div class="krow"><span class="kk">3</span><span>MOUSE on/off</span></div>
      <div class="krow"><span class="kk">4</span><span>CHAOS on/off</span></div>
      <div class="krow"><span class="kk">5</span><span>PUMP on/off</span></div>
      <div class="krow"><span class="kk">6</span><span>EXACT IFS on/off (canonical step)</span></div>
      <div class="krow"><span class="kk">M</span><span>mouse: repel / attract</span></div>
      <div class="krow"><span class="kk">P / N</span><span>more / fewer particles</span></div>
      <div class="krow"><span class="kk">Shift+P/N</span><span>beyond slider (vm2000=22M, vm8000=87M, vm16000=175M)</span></div>
      <div class="krow"><span class="kk">7 / 8</span><span>palette</span></div>
      <h3>CAMERA</h3>
      <div class="krow"><span class="kk">+ / -</span><span>zoom</span></div>
      <div class="krow"><span class="kk">&#8592; / &#8594;</span><span>spin (auto-rotate)</span></div>
      <div class="krow"><span class="kk">0</span><span>reset rotation + pan + spin</span></div>
      <div class="krow"><span class="kk">Shift+drag</span><span>pan camera</span></div>
      <div class="krow"><span class="kk">Wheel</span><span>zoom toward cursor</span></div>
      <div class="krow"><span class="kk">Shift+Wheel</span><span>rotate</span></div>
      <div class="krow"><span class="kk">Touch</span><span>1 finger = mouse, 2 fingers = zoom + rotate</span></div>
      <h3>PHYSICS</h3>
      <div class="krow"><span class="kk">&#8593; / &#8595;</span><span>gravity</span></div>
      <div class="krow"><span class="kk">[ / ]</span><span>damping</span></div>
      <div class="krow"><span class="kk">; / '</span><span>IFS force</span></div>
      <div class="krow"><span class="kk">, / .</span><span>pressure</span></div>
      <div class="krow"><span class="kk">Q / A</span><span>charge</span></div>
      <div class="krow"><span class="kk">&lt; / &gt;</span><span>vortex (orbit vs fall)</span></div>
      <div class="krow"><span class="kk">W / S</span><span>time K</span></div>
      <div class="krow"><span class="kk">E / D</span><span>time min</span></div>
      <div class="krow"><span class="kk">T / G</span><span>pump strength</span></div>
      <div class="krow"><span class="kk">9 / 0</span><span>react intensity (0 = camera reset when REACT off)</span></div>
      <div class="krow"><span class="kk">F / V</span><span>density (deposit multiplier)</span></div>
      <div class="krow"><span class="kk">Z / X</span><span>chaos</span></div>
      <div class="krow"><span class="kk">I / K</span><span>trail (fade)</span></div>
      <div class="krow"><span class="kk">O / L</span><span>field fade</span></div>
      <div class="krow"><span class="kk">J / Y</span><span>tempo (slow / fast)</span></div>
      <div class="krow"><span class="kk">9 / 0</span><span>react intensity (when REACTIONS on)</span></div>
      <h3>DISPLAY</h3>
      <div class="krow"><span class="kk">H</span><span>show / hide this help</span></div>
      <div class="krow"><span class="kk">U</span><span>hide all UI (clean canvas for screenshots)</span></div>
      <div class="krow"><span class="kk">M</span><span>toggle audio (Schumann riff engine)</span></div>
      <div class="krow"><span class="kk">TAB</span><span>hide / show controls</span></div>
      <h3>SHARE</h3>
      <div style="color:#777;margin-bottom:8px;line-height:1.5">
        Press <span style="color:#00d2ff">C</span> or the SHARE button to copy a URL encoding all current settings. Anyone opening the link starts with the same configuration. Explore, then share what you find.
      </div>
      <h3>LINKS</h3>
      <div style="margin:4px 0"><a href="https://twistj.com" target="_blank" style="color:#00d2ff;text-decoration:none">twistj.com</a></div>
      <div style="margin-top:16px;text-align:center;color:#555;font-size:10px;letter-spacing:2px;line-height:1.8">
        ALWAYS THE SAME. FOREVER NEW.<br>
        <span style="color:#00d2ff;letter-spacing:3px">SIMPLIZIS.</span>
      </div>
    </div>

    <div id="gameOverlay" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;text-align:center;pointer-events:auto;z-index:50;background:rgba(0,0,0,0.55)">
      <div style="background:rgba(6,6,10,0.92);border:1px solid #1e1e28;border-radius:8px;padding:28px 40px;min-width:220px">
        <!-- Start screen -->
        <div id="gameStartScreen" style="display:none">
          <div style="color:#555;font-size:10px;letter-spacing:3px;margin-bottom:12px">LET US TWIST AGAIN</div>
          <button id="gamePlayBtn" style="font-size:13px;padding:10px 24px;letter-spacing:2px;color:#00d2ff;border-color:#00d2ff">DEFEND THE ZONE</button>
        </div>
        <!-- Game over screen -->
        <div id="gameEndScreen" style="display:none">
          <div style="color:#f44;font-size:14px;letter-spacing:3px;margin-bottom:8px" id="gameOverTitle">GAME OVER</div>
          <div style="color:#8a8a8a;font-size:22px;letter-spacing:2px;margin-bottom:16px" id="gameOverTime">12.3s</div>
          <div id="gameOverStats" style="color:#666;font-size:10px;line-height:1.6;letter-spacing:1px;margin:-6px 0 16px 0;white-space:pre-line"></div>
          <button id="gameRetry" style="font-size:13px;padding:10px 24px;letter-spacing:2px;margin-bottom:14px">TRY AGAIN</button>
          <div style="display:flex;gap:12px;justify-content:center">
            <a href="https://twistj.com" target="_blank" style="color:#444;font-size:9px;letter-spacing:2px;text-decoration:none;padding:4px 10px;border:1px solid #1e1e28;border-radius:4px">TWIST-J</a>
            <a href="https://orcid.org/0009-0008-5463-278X" target="_blank" style="color:#444;font-size:9px;letter-spacing:2px;text-decoration:none;padding:4px 10px;border:1px solid #1e1e28;border-radius:4px">A. M. Thorn</a>
          </div>
        </div>
      </div>
    </div>

    <div id="invertBtn" class="invert-btn">INVERT</div>
    <div id="invertHud" class="invert-hud"></div>
    <div id="gameLockedHud" style="display:none">
      <span class="gl-status" id="glStatus">READY</span>
      <span class="gl-time" id="glTime">0.0s</span>
      <span class="gl-fill" id="glFill">0%</span>
    </div>

    <a class="credit twistj-link" href="https://twistj.com" target="_blank" style="right:120px">twistj.com</a>
    <a class="credit" href="https://orcid.org/0009-0008-5463-278X" target="_blank">A. M. Thorn</a>
    <div class="audio-btn" id="audioBtn" title="Toggle audio">ðŸ”‡</div>
    <div class="audio-btn" id="fullscreenBtn" title="Fullscreen" style="left:52px">â›¶</div>
  </div>

<script>
// ============================================================
//  TWIST-J Schumann Riff Engine (embedded)
// ============================================================
const TwistJ = (() => {
const PHI   = (1 + Math.sqrt(5)) / 2;
const PHI_I = 1 / PHI;
const PHI_2 = PHI * PHI;
const PHI_I2 = 1 / PHI_2;
const F_SCH = 7.83;
const FIBS  = [3, 5, 8, 13, 21];
const TEMPO_MULS   = [PHI_I2, PHI_I, 1, PHI, PHI_2];
const TEMPO_NAMES  = ['largo', 'adagio', 'andante', 'allegro', 'presto'];
const TEMPO_LABELS = ['Ï†â»Â²', 'Ï†â»Â¹', '1', 'Ï†', 'Ï†Â²'];
const ROOT_HARMONICS = [24, 27, 30, 36, 40];
const ROOT_NAMES     = ['I', 'II', 'III', 'V', 'VI'];
const SCALE_RATIOS = [[1,1],[9,8],[5,4],[4,3],[3,2],[5,3],[15,8],[2,1]];
const RIFF_NAMES = [
  'jab','snap','kick','stab','pop','hit','crack','dart',
  'whip','burst','slam','rush','punch','spike','bang','zip',
  'flick','hook','rip','tap','dive','sting','chop','zap',
  'thump','click','buzz','ping','slash','drop','clip','bolt',
  'grind','lash','poke','blitz','smash','jolt','strike','cut'
];
// Each riff = array of [degree, durationMul] pairs
// degree: 0-7 scale (-1=rest), dur: fraction of beat (0.125=32nd, 0.25=16th, 0.5=8th, 1=quarter)
// Riffs are SHORT (2-6 notes), fast, punchy, rhythmically varied
const RIFFS = [
  [[0,.25],[4,.25]],                                    // jab: 16th-16th stab
  [[-1,.125],[0,.25],[7,.125]],                         // snap: ghost-hit-flick
  [[0,.5],[4,.25],[7,.25]],                             // kick: strong root, quick climb
  [[7,.125],[4,.125],[0,.25]],                          // stab: rapid 32nd descend
  [[-1,.25],[0,.125],[0,.125]],                         // pop: synco double tap
  [[0,.125],[4,.125],[7,.125],[4,.125]],                // hit: 32nd machine gun
  [[7,.25],[-1,.125],[0,.125]],                         // crack: smash-gap-land
  [[0,.125],[2,.125],[4,.125],[7,.125]],                // dart: 32nd chromatic run
  [[4,.25],[-1,.125],[0,.125]],                         // whip: hit-flick-hit
  [[0,.125],[7,.125],[-1,.125],[4,.125]],               // burst: leap-rest-drop
  [[0,.5],[7,.125],[0,.125]],                           // slam: hold-smash-back
  [[2,.125],[4,.125],[7,.125]],                         // rush: triple 32nd run up
  [[0,.25],[0,.125],[4,.125]],                          // punch: root-double-rise
  [[-1,.125],[7,.25],[4,.125]],                         // spike: ghost-high-drop
  [[4,.125],[4,.125],[7,.25]],                          // bang: stutter + leap
  [[7,.125],[4,.125]],                                  // zip: fast pair
  [[0,.125],[-1,.125],[7,.25]],                         // flick: tap-ghost-octave
  [[4,.125],[0,.125],[7,.25]],                          // hook: circle + hold
  [[7,.25],[4,.125],[0,.125]],                          // rip: high-tumble
  [[0,.5],[-1,.125],[0,.125]],                          // tap: hold + pickup
  [[7,.125],[5,.125],[4,.125]],                         // dive: chromatic 32nd triple
  [[0,.25],[-1,.125],[4,.125]],                         // sting: root-gap-fifth
  [[4,.125],[7,.125],[4,.125],[0,.125]],                // chop: bouncing 32nds
  [[-1,.125],[0,.125],[4,.25]],                         // zap: ghost-pickup-land
  [[0,.125],[0,.125],[0,.125],[-1,.125]],               // thump: triple pulse + gap
  [[4,.125],[-1,.125],[0,.125]],                        // click: staccato triplet
  [[0,.125],[4,.125],[0,.125]],                         // buzz: oscillating 32nds
  [[7,.25],[5,.25]],                                    // ping: quick high pair
  [[0,.125],[7,.375]],                                  // slash: flick-sustain (swing)
  [[7,.375],[0,.125]],                                  // drop: sustain-flick (reverse)
  [[-1,.125],[4,.125],[7,.125],[4,.125]],               // clip: ghost + bouncing
  [[0,.125],[4,.25],[7,.125]],                          // bolt: tap-hold-tap
  [[0,.25],[2,.125],[4,.125]],                          // grind: root + quick step
  [[7,.125],[0,.25],[4,.125]],                          // lash: oct-root-fifth
  [[-1,.125],[0,.375]],                                 // poke: pickup into hold
  [[4,.125],[7,.125],[0,.125],[4,.125]],                // blitz: fast 4-note cycle
  [[0,.375],[7,.125]],                                  // smash: held root + stab
  [[4,.25],[0,.25]],                                    // jolt: even exchange
  [[0,.125],[4,.125],[7,.125],[0,.125],[4,.125]],       // strike: 5-note 32nd run
  [[7,.125],[4,.125],[2,.125],[0,.125],[7,.125],[0,.125]], // cut: 6-note cascading fall
];
const BASS_RIFFS = [
  [[0,.25],[-1,.25]],                    // pump: hit-rest
  [[0,.25],[0,.125],[4,.125]],           // push: root-stutter-fifth
  [[0,.375],[4,.125]],                   // swing: dotted root
  [[-1,.125],[0,.25],[-1,.125]],         // off: syncopated single
  [[4,.125],[0,.375]],                   // drop: fifth â†’ root
  [[0,.125],[0,.125],[-1,.25]],          // stutter: double tap + gap
  [[0,.25],[4,.25]],                     // walk: root-fifth even
  [[0,.125],[-1,.125],[4,.25]],          // skip: root-ghost-fifth
  [[0,.5]],                              // drone: single root
  [[-1,.125],[0,.125],[0,.25]],          // pickup: ghost-hit-hold
  [[4,.25],[0,.125],[4,.125]],           // bounce: fifth-root-fifth
  [[0,.125],[4,.125],[0,.125],[-1,.125]],// circle: fast rotation
  [[0,.125],[0,.125],[4,.125],[0,.125]], // pulse: driving 32nds
  [[-1,.125],[0,.125],[-1,.125],[4,.125]], // ghost: syncopated gaps
  [[0,.25],[0,.125],[-1,.125]],          // knock: hit-tap-rest
  [[4,.125],[0,.125],[4,.125],[0,.125]], // motor: alternating 32nds
];
function riffNoteDeg(riff,pos){return riff[pos][0];}
function riffNoteDur(riff,pos){return riff[pos][1];}
function riffEndDeg(riff){for(let i=riff.length-1;i>=0;i--)if(riff[i][0]>=0)return riff[i][0];return 0;}
function riffStartDeg(riff){for(let i=0;i<riff.length;i++)if(riff[i][0]>=0)return riff[i][0];return 0;}
function selectRiff(n,prevEnd){const base=gPhase(n,RIFFS.length);const gap=Math.abs(riffStartDeg(RIFFS[base])-prevEnd);if(gap<=3)return base;const off=tm(n*3+1)===1?7:13;const alt=(base+off)%RIFFS.length;return Math.abs(riffStartDeg(RIFFS[alt])-prevEnd)<gap?alt:base;}
function selectBassRiff(n){return gPhase(n*7,BASS_RIFFS.length);}
const VOICE_DEFS = [{name:'lead',wave:'triangle',vol:0.50,regOff:0},{name:'counter',wave:'sine',vol:0.30,regOff:0},{name:'bass',wave:'triangle',vol:0.45,regOff:-1},{name:'pad',wave:'sine',vol:0.18,regOff:0},{name:'pulse',wave:'square',vol:0.12,regOff:1}];

function tm(n){n=n>>>0;n^=n>>16;n^=n>>8;n^=n>>4;n^=n>>2;n^=n>>1;return n&1;}
function gPhase(n,mod){mod=mod||5;return Math.floor((((n*PHI)%1+1)%1)*mod);}
function fibAt(n){let a=0,b=1;for(let i=0;i<((n%24)+24)%24;i++){const t=a+b;a=b;b=t;}return a;}
function scaleHarmonic(rootH,deg,octShift){const d=((deg%8)+8)%8;const oct=Math.floor(deg/8)+(octShift||0);const[num,den]=SCALE_RATIOS[d];return Math.round(rootH*num/den*Math.pow(2,oct));}
function rootHarmonicsAtReg(reg){const mul=Math.pow(2,reg);return ROOT_HARMONICS.map(h=>Math.round(h*mul));}
function sectionTempoIdx(s){const b=gPhase(s*3+7,5);const j=tm(s*5+1)===1?2:0;return(b+j)%5;}
function computeSection(secNum){const t1=tm(secNum),t2=tm(secNum*3+1),t3=tm(secNum*7+2);const count=[1,2,3,5][t1+t2+t3];const start=gPhase(secNum*11+3,5);const step=tm(secNum*5)===0?1:2;const set=[];let idx=start;for(let i=0;i<count;i++){set.push(idx%5);idx+=step;}return{count:[...new Set(set)].length,activeSet:[...new Set(set)],sectionLen:FIBS[gPhase(secNum*13,4)]};}
function articulate(step,noteIdx){const t1=tm(step+noteIdx*3);const t2=tm(step*5+noteIdx*7);if(t1===1&&t2===1)return'accent';if(noteIdx===0)return'accent';return'normal';}
function shouldSilence(themeNum,silWeight){if(silWeight<=0)return false;return(tm(themeNum*3+7)+tm(themeNum*11+2))/2>=(1-silWeight);}
function query(n){n=Math.max(0,Math.floor(n));const secNum=Math.floor(n/200);const themeNum=Math.floor(n/40);const phraseNum=Math.floor(n/3);const notePos=n%3;const sec=computeSection(secNum);const tIdx=sectionTempoIdx(secNum);const rootIdx=gPhase(themeNum,5);const rootReg=Math.max(0,Math.min(3,1+fibAt(themeNum)%2));const roots=rootHarmonicsAtReg(rootReg);const rootH=roots[rootIdx];const lri=selectRiff(phraseNum,0);const leadRiff=RIFFS[lri];const bri=selectBassRiff(phraseNum);const bassRiff=BASS_RIFFS[bri];const lp=notePos%leadRiff.length;const bp=notePos%bassRiff.length;const leadDeg=leadRiff[lp][0];const leadDur=leadRiff[lp][1];const bassDeg=bassRiff[bp][0];const art=articulate(n,lp);return{n,section:secNum,theme:themeNum,phrase:phraseNum,noteInRiff:lp,tempoMul:TEMPO_MULS[tIdx],tempoName:TEMPO_NAMES[tIdx],rootHarmonic:rootH,rootName:ROOT_NAMES[rootIdx],rootReg,lead:{riffIdx:lri,riffName:RIFF_NAMES[lri],degree:leadDeg,harmonic:leadDeg>=0?scaleHarmonic(rootH,leadDeg,0):null,freq:leadDeg>=0?scaleHarmonic(rootH,leadDeg,0)*F_SCH:null,articulation:art,rest:leadDeg<0,durMul:leadDur},bass:{degree:bassDeg,harmonic:bassDeg>=0?scaleHarmonic(rootH,bassDeg,-1):null,freq:bassDeg>=0?scaleHarmonic(rootH,bassDeg,-1)*F_SCH:null,rest:bassDeg<0},tm:tm(n),duration:leadDur,activeVoices:sec.activeSet,voiceCount:sec.count,silence:shouldSilence(themeNum,0.5)};}
function sequence(from,count){const out=[];for(let i=0;i<count;i++)out.push(query(from+i));return out;}

class Engine{
constructor(opts){opts=opts||{};this.baseTempo=opts.tempo||84;this.reverb=opts.reverb!=null?opts.reverb:0.77;this.breath=opts.breath!=null?opts.breath:0.65;this.silW=opts.silence!=null?opts.silence:0.50;this.regW=opts.register||2;this.wander=opts.wander||false;this.playing=false;this.step=0;this._listeners={};this._ax=null;this._master=null;this._dryB=null;this._revS=null;this._revC=null;this._comp=null;this._schedId=null;this._masterNextT=0;this._initState();}
start(n){this._initAudio();this._jumpToN(n||0);this.playing=true;if(this._ax.state==='suspended')this._ax.resume();const now=this._ax.currentTime;this._masterNextT=now;this._voices.forEach(v=>{if(v.nextT<now)v.nextT=now;});this._sched();}
pause(){this.playing=false;if(this._schedId)clearTimeout(this._schedId);}
resume(){if(!this._ax)return this.start(this.step);this.playing=true;if(this._ax.state==='suspended')this._ax.resume();const now=this._ax.currentTime;this._masterNextT=now;this._voices.forEach(v=>{if(v.nextT<now)v.nextT=now;});this._sched();}
stop(){this.playing=false;if(this._schedId)clearTimeout(this._schedId);this.step=0;this._initState();}
setTempo(bpm){this.baseTempo=Math.max(20,Math.min(400,bpm));}
setWander(on){this.wander=!!on;}
setVoiceVol(i,vol){if(this._voices&&this._voices[i])this._voices[i].vol=Math.max(0,Math.min(1,vol));}
muteVoice(i){if(this._voices&&this._voices[i])this._voices[i].muted=true;}
unmuteVoice(i){if(this._voices&&this._voices[i])this._voices[i].muted=false;}
set(opts){if(opts.reverb!=null){this.reverb=opts.reverb;this._updateReverb();}if(opts.breath!=null)this.breath=opts.breath;if(opts.silence!=null)this.silW=opts.silence;if(opts.register!=null)this.regW=opts.register;if(opts.tempo!=null)this.setTempo(opts.tempo);if(opts.wander!=null)this.setWander(opts.wander);}
on(event,fn){if(!this._listeners[event])this._listeners[event]=[];this._listeners[event].push(fn);}
off(event,fn){if(!this._listeners[event])return;this._listeners[event]=this._listeners[event].filter(f=>f!==fn);}
get state(){return{n:this.step,playing:this.playing,section:this._S.sectionNum,theme:this._S.themeNum,tempo:this._effectiveTempo(),tempoName:TEMPO_NAMES[this._S.tempoMulIdx],tempoLabel:TEMPO_LABELS[this._S.tempoMulIdx],tempoMul:this._S.tempoMul,rootIdx:this._S.rootIdx,rootName:ROOT_NAMES[this._S.rootIdx],rootReg:this._S.rootReg,rootHarmonic:rootHarmonicsAtReg(this._S.rootReg)[this._S.rootIdx],leadRiff:RIFF_NAMES[this._S.leadRiffIdx],leadRiffIdx:this._S.leadRiffIdx,voiceCount:this._S.activeCount,activeVoices:this._S.activeSet,silence:this._S.inSilence,wander:this.wander,voices:this._voices.map(v=>({name:v.name,active:v.active,muted:v.muted,harmonic:v.curH,freq:v.curH?v.curH*F_SCH:0}))};}
_emit(event,data){(this._listeners[event]||[]).forEach(fn=>{try{fn(data);}catch(e){}});}
_initState(){this._S={sectionNum:0,sectionLen:5,themesInSection:0,themeNum:0,activeCount:3,activeSet:[0,1,2],inSilence:false,silBeatsLeft:0,silPhraseNum:0,tempoMulIdx:2,tempoMul:1,prevTempoMul:1,tempoTransition:1,tempoTransLen:0,leadRiffIdx:0,leadRiffPos:0,leadEndDeg:0,leadPhraseNum:0,counterRiffIdx:10,counterRiffPos:0,counterEndDeg:4,counterPhraseNum:0,bassRiffIdx:0,bassRiffPos:0,bassPhraseNum:0,rootIdx:0,rootReg:1,breathBeats:0};this._voices=VOICE_DEFS.map((d,i)=>({...d,i,step:0,nextT:0,muted:false,structActive:true,curH:0,active:false}));}
_jumpToN(n){n=Math.max(0,Math.floor(n));this.step=n;const S=this._S;this._voices.forEach((v,i)=>{v.step=n+i*5;});S.sectionNum=Math.floor(n/200);S.themeNum=Math.floor(n/40);S.leadPhraseNum=Math.floor(n/3);S.counterPhraseNum=Math.floor(n/3)+5;S.bassPhraseNum=Math.floor(n/3)+3;S.leadRiffIdx=selectRiff(S.leadPhraseNum,0);S.counterRiffIdx=selectRiff(S.counterPhraseNum*3+11,4);S.bassRiffIdx=selectBassRiff(S.bassPhraseNum);S.leadRiffPos=0;S.counterRiffPos=0;S.bassRiffPos=0;S.rootIdx=gPhase(S.themeNum,5);S.rootReg=Math.max(0,Math.min(3,1+fibAt(S.themeNum)%this.regW-Math.floor(this.regW/2)));const sec=computeSection(S.sectionNum);S.sectionLen=sec.sectionLen;S.activeCount=sec.count;S.activeSet=sec.activeSet;S.themesInSection=S.themeNum%S.sectionLen;const tIdx=sectionTempoIdx(S.sectionNum);S.tempoMulIdx=tIdx;S.tempoMul=TEMPO_MULS[tIdx];S.prevTempoMul=S.tempoMul;S.tempoTransition=1;this._voices.forEach((v,j)=>{v.structActive=sec.activeSet.includes(j);});S.inSilence=false;S.breathBeats=0;}
_effectiveTempo(){const S=this._S;let mul;if(S.tempoTransition>=1)mul=S.tempoMul;else{const t=S.tempoTransition;const e=t*t*(3-2*t);mul=S.prevTempoMul+(S.tempoMul-S.prevTempoMul)*e;}return this.baseTempo*mul;}
_updateReverb(){if(this._dryB)this._dryB.gain.value=1-this.reverb;if(this._revS)this._revS.gain.value=this.reverb;}
_initAudio(){if(this._ax)return;const ax=new(window.AudioContext||window.webkitAudioContext)();this._ax=ax;this._comp=ax.createDynamicsCompressor();this._comp.threshold.value=-10;this._comp.knee.value=12;this._comp.ratio.value=4;this._comp.connect(ax.destination);this._master=ax.createGain();this._master.gain.value=0.70;this._dryB=ax.createGain();this._dryB.gain.value=1-this.reverb;this._dryB.connect(this._comp);this._revS=ax.createGain();this._revS.gain.value=this.reverb;this._revS.connect(this._comp);const sr=ax.sampleRate,len=sr*5;const buf=ax.createBuffer(2,len,sr);for(let c=0;c<2;c++){const d=buf.getChannelData(c);for(let i=0;i<len;i++){const t=i/sr;d[i]=((Math.random()*2-1)*.25+(tm(i>>>4)*2-1)*.008)*Math.exp(-t*PHI*.55)+Math.sin(2*Math.PI*F_SCH*2*t)*Math.exp(-t*5)*.015;}}this._revC=ax.createConvolver();this._revC.buffer=buf;this._master.connect(this._dryB);this._master.connect(this._revC);this._revC.connect(this._revS);}
_synth(freq,dur,vel,when,wave,vi){if(!this._ax||freq<18)return;const ax=this._ax,master=this._master;const S=this._S;const tScale=Math.min(2.5,Math.max(0.25,1/S.tempoMul));const osc=ax.createOscillator();osc.type=wave;osc.frequency.setValueAtTime(freq,when);let atk,sus,rel;switch(vi){case 0:atk=.008*tScale;sus=dur*.35;rel=dur*.25*tScale;break;case 1:atk=.02*tScale;sus=dur*.4;rel=dur*.3*tScale;break;case 2:atk=.005;sus=dur*.5;rel=dur*.25;break;case 3:atk=.08*tScale;sus=dur*.9;rel=dur*.6*tScale;break;case 4:atk=.002;sus=dur*.06;rel=dur*.05;break;}const tot=atk+sus+rel;const env=ax.createGain();env.gain.setValueAtTime(0,when);env.gain.linearRampToValueAtTime(vel*.30,when+atk);if(vi===4){env.gain.exponentialRampToValueAtTime(.001,when+Math.max(tot,.03));}else{env.gain.linearRampToValueAtTime(vel*.18,when+atk+sus);env.gain.exponentialRampToValueAtTime(.0003,when+Math.max(tot,.04));}if(vi<2||vi===3){const vib=ax.createOscillator(),vG=ax.createGain();vib.frequency.value=F_SCH*PHI_I*(1+vi*.3);vG.gain.value=freq*.002*tScale;vib.connect(vG);vG.connect(osc.frequency);vib.start(when);vib.stop(when+tot+.1);}if(vi===2&&freq>60){const sub=ax.createOscillator();sub.type='sine';sub.frequency.setValueAtTime(freq/2,when);const sE=ax.createGain();sE.gain.setValueAtTime(0,when);sE.gain.linearRampToValueAtTime(vel*.10,when+.01);sE.gain.exponentialRampToValueAtTime(.0003,when+tot);sub.connect(sE);sE.connect(master);sub.start(when);sub.stop(when+tot+.1);}osc.connect(env);env.connect(master);osc.start(when);osc.stop(when+tot+.1);}
_advanceVoice(v,when){const S=this._S;const beatDur=60/this._effectiveTempo();if(S.inSilence){v.active=false;v.step++;return beatDur*.5;}if(!v.structActive){v.active=false;v.step++;return beatDur*PHI*.5;}if(S.breathBeats>0&&v.i===0){S.breathBeats--;v.active=false;v.step++;return beatDur*.5;}const roots=rootHarmonicsAtReg(S.rootReg+v.regOff);const rootH=roots[S.rootIdx];let harm=0,isRest=false,dur=beatDur*.5;switch(v.i){case 0:{const riff=RIFFS[S.leadRiffIdx];const note=riff[S.leadRiffPos];const deg=note[0];const durMul=note[1];dur=beatDur*durMul;const art=articulate(v.step,S.leadRiffPos);if(deg<0)isRest=true;else{harm=scaleHarmonic(rootH,deg,0);this._synth(harm*F_SCH,dur,v.vol*(art==='accent'?1:.65),when,v.wave,0);}S.leadRiffPos++;if(S.leadRiffPos>=riff.length){S.leadEndDeg=riffEndDeg(riff);S.leadRiffPos=0;S.leadPhraseNum++;S.leadRiffIdx=selectRiff(S.leadPhraseNum,S.leadEndDeg);this._emit('riff',this.state);}break;}case 1:{const riff=RIFFS[S.counterRiffIdx];const note=riff[S.counterRiffPos];const deg=note[0];const durMul=note[1];dur=beatDur*durMul;const art=articulate(v.step+7,S.counterRiffPos);if(deg<0)isRest=true;else{const inv=tm(S.counterPhraseNum)===1?(7-deg):deg;harm=scaleHarmonic(rootH,inv,tm(S.counterPhraseNum*3)===1?1:0);this._synth(harm*F_SCH,dur,v.vol*(art==='accent'?1:.55),when,v.wave,1);}S.counterRiffPos++;if(S.counterRiffPos>=riff.length){S.counterEndDeg=riffEndDeg(riff);S.counterRiffPos=0;S.counterPhraseNum++;S.counterRiffIdx=selectRiff(S.counterPhraseNum*3+11,S.counterEndDeg);}break;}case 2:{const bRiff=BASS_RIFFS[S.bassRiffIdx%BASS_RIFFS.length];const note=bRiff[S.bassRiffPos];const deg=note[0];const durMul=note[1];dur=beatDur*durMul;if(deg<0)isRest=true;else{harm=scaleHarmonic(rootH,deg,-1);if(harm<12)harm*=2;this._synth(harm*F_SCH,dur*1.1,v.vol*(S.bassRiffPos===0?1:.7),when,v.wave,2);}S.bassRiffPos++;if(S.bassRiffPos>=bRiff.length){S.bassRiffPos=0;S.bassPhraseNum++;S.bassRiffIdx=selectBassRiff(S.bassPhraseNum);}break;}case 3:{const padDeg=[0,2,4,7][v.step%4];dur=beatDur*2;if(tm(v.step*2)!==1&&v.step>0)isRest=true;else{harm=scaleHarmonic(rootH,padDeg,0);this._synth(harm*F_SCH,dur,v.vol*.7,when,v.wave,3);}break;}case 4:{dur=beatDur*0.25;if(!(tm(v.step)===1&&tm(v.step*3+1)===1))isRest=true;else{harm=scaleHarmonic(rootH,tm(v.step*7)===0?0:4,1);this._synth(harm*F_SCH,dur*.6,v.vol*.9,when,'square',4);}break;}}v.curH=harm||0;v.active=!isRest&&!v.muted;v.step++;if(v.i===0&&S.leadPhraseNum>0&&S.leadPhraseNum%FIBS[gPhase(S.sectionNum,4)]===0){this._advanceTheme();}return dur;}
_advanceTheme(){const S=this._S;S.themeNum++;if(shouldSilence(S.themeNum,this.silW)){S.inSilence=true;S.silBeatsLeft=FIBS[gPhase(S.silPhraseNum*7,4)];S.silPhraseNum++;}const restB=Math.round((tm(S.themeNum*5+3)+1)*this.breath*2);if(restB>0)S.breathBeats=restB;S.rootIdx=gPhase(S.themeNum,5);S.rootReg=Math.max(0,Math.min(3,1+fibAt(S.themeNum)%this.regW-Math.floor(this.regW/2)));S.themesInSection++;if(S.themesInSection>=S.sectionLen){S.themesInSection=0;S.sectionNum++;const sec=computeSection(S.sectionNum);S.sectionLen=sec.sectionLen;S.activeCount=sec.count;S.activeSet=sec.activeSet;this._voices.forEach((v,j)=>{v.structActive=sec.activeSet.includes(j);});const newTIdx=sectionTempoIdx(S.sectionNum);S.prevTempoMul=S.tempoMul;S.tempoMulIdx=newTIdx;S.tempoMul=TEMPO_MULS[newTIdx];S.tempoTransition=0;S.tempoTransLen=4;if(this.wander){const jump=104729*gPhase(S.sectionNum*7+3,5)+7919*tm(S.sectionNum*11);const newN=this.step+jump;this._voices.forEach(v=>{v.step=newN+v.i*5;});this.step=newN;S.leadPhraseNum=gPhase(newN,100);S.counterPhraseNum=gPhase(newN+7,100);S.bassPhraseNum=gPhase(newN+13,50);S.leadRiffIdx=selectRiff(S.leadPhraseNum,0);S.counterRiffIdx=selectRiff(S.counterPhraseNum*3+11,4);S.bassRiffIdx=selectBassRiff(S.bassPhraseNum);S.leadRiffPos=0;S.counterRiffPos=0;S.bassRiffPos=0;}this._emit('section',this.state);}if(S.tempoTransition<1&&S.tempoTransLen>0){S.tempoTransition=Math.min(1,S.tempoTransition+1/S.tempoTransLen);}this._emit('beat',this.state);}
_advanceSilence(){const S=this._S;if(!S.inSilence)return;S.silBeatsLeft--;if(S.silBeatsLeft<=0)S.inSilence=false;}
_sched(){if(!this.playing||!this._ax)return;const now=this._ax.currentTime;const S=this._S;const AHEAD=0.22;while(S.inSilence&&this._masterNextT<now+AHEAD){if(this._masterNextT<now)this._masterNextT=now;this._advanceSilence();this._masterNextT+=60/this._effectiveTempo();}for(const v of this._voices){while(v.nextT<now+AHEAD){if(v.nextT<now)v.nextT=now;const d=this._advanceVoice(v,v.nextT);v.nextT+=d;}}let mx=0;for(const v of this._voices)if(v.step>mx)mx=v.step;if(mx!==this.step){this.step=mx;this._emit('beat',this.state);}this._schedId=setTimeout(()=>this._sched(),28);}
}
function TwistJC(opts){return new Engine(opts);}
TwistJC.query=query;TwistJC.sequence=sequence;TwistJC.tm=tm;TwistJC.gPhase=gPhase;
TwistJC.F_SCHUMANN=F_SCH;TwistJC.PHI=PHI;TwistJC.TEMPO_MULS=TEMPO_MULS;
return TwistJC;
})();

(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias:false, alpha:false });
  if(!gl){ alert("WebGL2 required."); return; }

  const ext = gl.getExtension('EXT_color_buffer_float');
  if(!ext){ alert("Missing EXT_color_buffer_float."); return; }
  gl.getExtension('EXT_float_blend');

  // =========================
  // UI
  // =========================
  const ui = {
    tglKernel:  document.getElementById('tglKernel'),
    tglField:   document.getElementById('tglField'),
    tglMouse:   document.getElementById('tglMouse'),
    tglChaos:   document.getElementById('tglChaos'),
    tglPump:    document.getElementById('tglPump'),
    tglReact:   document.getElementById('tglReact'),
    tglExact:   document.getElementById('tglExact'),
    mouseRepel: document.getElementById('mouseRepel'),
    mouseAttract: document.getElementById('mouseAttract'),

    damping: document.getElementById('damping'),
    force:   document.getElementById('force'),
    chaos:   document.getElementById('chaos'),
    fade:    document.getElementById('fade'),
    scale:   document.getElementById('scale'),

    ffield:  document.getElementById('ffield'),
    deposit: document.getElementById('deposit'),
    grav:    document.getElementById('grav'),
    pressure: document.getElementById('pressure'),
    pump:    document.getElementById('pump'),
    react:   document.getElementById('react'),
    spin:    document.getElementById('spin'),
    timeK:   document.getElementById('timeK'),
    timeMin: document.getElementById('timeMin'),
    charge:  document.getElementById('charge'),
    particles: document.getElementById('particles'),
    palette: document.getElementById('palette'),
    vortex: document.getElementById('vortex'),
    tempo: document.getElementById('tempo'),

    rowMouseMode: document.getElementById('rowMouseMode'),
    rowChaos: document.getElementById('rowChaos'),
    rowFieldFade: document.getElementById('rowFieldFade'),
    rowDeposit: document.getElementById('rowDeposit'),
    rowGrav: document.getElementById('rowGrav'),
    rowPressure: document.getElementById('rowPressure'),
    rowTimeK: document.getElementById('rowTimeK'),
    rowTimeMin: document.getElementById('rowTimeMin'),
    rowCharge: document.getElementById('rowCharge'),
    rowPump: document.getElementById('rowPump'),
    rowReact: document.getElementById('rowReact'),
  };

  function setRowEnabled(rowEl, enabled){
    rowEl.classList.toggle('disabled', !enabled);
    rowEl.querySelectorAll('input,select,button').forEach(el => {
      el.disabled = !enabled;
    });
  }

  // Global (safe before GAME wiring): true when duality mode repurposes g/b field channels.
  let dualityOverride = false;

  function syncUI(){
    const kernelOn = ui.tglKernel.checked;
    const fieldOn  = ui.tglField.checked;
    const mouseOn  = ui.tglMouse.checked;
    const chaosOn  = ui.tglChaos.checked;

    if(!kernelOn){
      ui.tglPump.checked = false;
      ui.tglPump.disabled = true;
    } else {
      ui.tglPump.disabled = false;
    }
    const pumpOn = ui.tglPump.checked && kernelOn;

    setRowEnabled(ui.rowMouseMode, mouseOn);
    setRowEnabled(ui.rowChaos, chaosOn);
    setRowEnabled(ui.rowFieldFade, fieldOn);
    setRowEnabled(ui.rowDeposit, fieldOn);
    setRowEnabled(ui.rowGrav, fieldOn);
    setRowEnabled(ui.rowPressure, fieldOn);
    setRowEnabled(ui.rowTimeK, fieldOn);
    setRowEnabled(ui.rowTimeMin, fieldOn);
    setRowEnabled(ui.rowCharge, fieldOn && !dualityOverride);
    setRowEnabled(ui.rowPump, pumpOn);

    // REACTIONS depend on FIELD (and are disabled by DUALITY)
    ui.tglReact.disabled = !fieldOn || dualityOverride;

    const reactOn = ui.tglReact.checked && fieldOn && !dualityOverride;
    setRowEnabled(ui.rowReact, reactOn);
  }

  [ui.tglKernel, ui.tglField, ui.tglMouse, ui.tglChaos, ui.tglPump, ui.tglReact, ui.tglExact,
   ui.mouseRepel, ui.mouseAttract].forEach(el => {
    el.addEventListener('change', syncUI);
  });
  syncUI();

  // =========================
  // Panel toggle (TAB)
  // =========================
  const slidersWrap = document.getElementById('slidersWrap');
  const panelHideBtn = document.getElementById('panelHide');

  let slidersVisible = window.innerWidth >= 500;
  let gameWrapRef = null; // set later after gameWrap is declared
  let gameWasOpen = false;
  function togglePanel(){
    slidersVisible = !slidersVisible;
    if(!slidersVisible){
      // hiding: remember if game panel was open
      gameWasOpen = (gameWrapRef && gameWrapRef.style.display !== 'none');
      slidersWrap.style.display = 'none';
      if(gameWrapRef && gameWasOpen) gameWrapRef.style.display = 'none';
    } else {
      // showing: restore whichever was open
      if(gameWasOpen && gameWrapRef){
        gameWrapRef.style.display = '';
      } else {
        slidersWrap.style.display = '';
      }
    }
    panelHideBtn.innerHTML = slidersVisible
      ? 'HIDE <small>(TAB)</small>'
      : 'SHOW <small>(TAB)</small>';
  }
  panelHideBtn.addEventListener('click', togglePanel);
  if(!slidersVisible) slidersWrap.style.display = 'none';
  if(!slidersVisible) panelHideBtn.innerHTML = 'SHOW <small>(TAB)</small>';

  // =========================
  // URL hash: encode/decode
  // =========================
  const BASE_URL = 'https://evo.twistj.com/';

  // game UI refs needed for URL encode/decode (full wiring later)
  const gameUI = {
    enabled:      document.getElementById('gameEnabled'),
    showZone:     document.getElementById('gameShowZone'),
    modeEmpty:    document.getElementById('gameModeEmpty'),
    modeNotEmpty: document.getElementById('gameModeNotEmpty'),
    x:            document.getElementById('gameX'),
    y:            document.getElementById('gameY'),
    size:         document.getElementById('gameSize'),
    thresh:       document.getElementById('gameThresh'),
    coverage:     document.getElementById('gameCoverage'),
    grace:        document.getElementById('gameGrace'),
    winArea:      document.getElementById('gameWinArea'),
    winPresence:  document.getElementById('gameWinPresence'),
    dualOn:       document.getElementById('gameDualOn'),
    dualRate:     document.getElementById('gameDualRate'),
    dualEq:       document.getElementById('gameDualEq'),
    dualCoh:      document.getElementById('gameDualCoh'),
    initBalance:  document.getElementById('gameInitBalance'),
    powerEats:    document.getElementById('gamePowerEats'),
    energyTransfer: document.getElementById('gameEnergyTransfer'),
    colors:       document.getElementById('gameColors'),
    colorLabel:   document.getElementById('colorLabel'),
    reinfBlue:    document.getElementById('gameReinfBlue'),
    reinfPink:    document.getElementById('gameReinfPink'),
    reinfFlow:    document.getElementById('gameReinfFlow'),
    reinfWaves:   document.getElementById('gameReinfWaves'),
    areaStat:     document.getElementById('gameAreaStat'),
    presenceStat: document.getElementById('gamePresenceStat'),
    reinfStat:    document.getElementById('gameReinfStat'),
    start:        document.getElementById('gameStart'),
    stop:         document.getElementById('gameStop'),
    back:         document.getElementById('gameBack'),
    status:       document.getElementById('gameStatus'),
    timer:        document.getElementById('gameTimer'),
    fill:         document.getElementById('gameFill'),
    overlay:      document.getElementById('gameOverlay'),
    overTime:     document.getElementById('gameOverTime'),
    overTitle:    document.getElementById('gameOverTitle'),
    retry:        document.getElementById('gameRetry'),
    playBtn:      document.getElementById('gamePlayBtn'),
    startScreen:  document.getElementById('gameStartScreen'),
    endScreen:    document.getElementById('gameEndScreen'),
  };

  let gameLockRequested = false;

  const game = {
    enabled: false,
    running: false,
    showZone: true,
    modeEmpty: true,
    cx: 0, cy: 0,
    half: 0.18,
    threshold: 0.030,
    coverageMax: 0.100,
    grace: 0.7,
    winArea: true,
    winPresence: false,
    winHold: 0,
    blueHold: 0,
    tDanger: 0,
    time: 0,
    lastT: 0,
    over: false,
    locked: false,
    // Duality (BLUE/PINK predation)
    dualOn: false,
    dualRate: 2.00,
    dualEq: 0.00,
    dualCoh: 1.20,
    initBalance: 0.50,
    reinfBlue: 1.00,
    reinfPink: 1.00,
    reinfFlow: 0.00,
    reinfWaves: false,
    powerEats: false,
    energyTransfer: true,
    dualColors: 0,
  };

  const DUAL_COLOR_NAMES = [
    'BLUE / PINK',
    'AMBER / GREEN (CRT)',
    'WHITE / DARK BLUE',
    'MIL BLUE / MIL RED',
    'WHITE / DARK GREY',
  ];

  function updateColorLabel(){
    const idx = gameUI.colors ? parseInt(gameUI.colors.value) : 0;
    if(gameUI.colorLabel) gameUI.colorLabel.textContent = DUAL_COLOR_NAMES[idx] || DUAL_COLOR_NAMES[0];
  }
  if(gameUI.colors) gameUI.colors.addEventListener('input', updateColorLabel);

  const gameWrap = document.getElementById('gameWrap');
  gameWrapRef = gameWrap; // enable togglePanel to also hide game panel
  const glStatus = document.getElementById('glStatus');
  const glTime = document.getElementById('glTime');
  const glFill = document.getElementById('glFill');

  function gameReadUI(){
    game.enabled = gameUI.enabled.checked;
    game.showZone = gameUI.showZone.checked;
    game.modeEmpty = gameUI.modeEmpty.checked;
    game.cx = parseFloat(gameUI.x.value);
    game.cy = parseFloat(gameUI.y.value);
    game.half = parseFloat(gameUI.size.value);
    game.threshold = parseFloat(gameUI.thresh.value);
    game.coverageMax = parseFloat(gameUI.coverage.value);
    game.grace = parseFloat(gameUI.grace.value);
    game.winArea = gameUI.winArea ? gameUI.winArea.checked : true;
    game.winPresence = gameUI.winPresence ? gameUI.winPresence.checked : false;
    // ensure at least one condition is active
    if(!game.winArea && !game.winPresence){
      game.winArea = true;
      if(gameUI.winArea) gameUI.winArea.checked = true;
    }
    game.dualOn = !!(gameUI.dualOn && gameUI.dualOn.checked);
    game.dualRate = gameUI.dualRate ? parseFloat(gameUI.dualRate.value) : 1.0;
    game.dualEq = gameUI.dualEq ? parseFloat(gameUI.dualEq.value) : 0.00;
    game.dualCoh = gameUI.dualCoh ? parseFloat(gameUI.dualCoh.value) : 0.0;
    game.initBalance = gameUI.initBalance ? parseFloat(gameUI.initBalance.value) : 0.5;
    game.reinfBlue = gameUI.reinfBlue ? parseFloat(gameUI.reinfBlue.value) : 1.0;
    game.reinfPink = gameUI.reinfPink ? parseFloat(gameUI.reinfPink.value) : 1.0;
    game.reinfFlow = gameUI.reinfFlow ? parseFloat(gameUI.reinfFlow.value) : 0.0;
    game.reinfWaves = !!(gameUI.reinfWaves && gameUI.reinfWaves.checked);
    game.powerEats = !!(gameUI.powerEats && gameUI.powerEats.checked);
    game.energyTransfer = !!(gameUI.energyTransfer && gameUI.energyTransfer.checked);
    game.dualColors = gameUI.colors ? parseInt(gameUI.colors.value) : 0;

    // tell the main UI to disable CHARGE/REACT (they use g/b channels) when duality is active
    dualityOverride = game.dualOn;
  }

  const SLIDER_MAP = [
    ['dm', 'damping'],   ['fo', 'force'],    ['ch', 'chaos'],
    ['fa', 'fade'],      ['sc', 'scale'],    ['sp', 'spin'],
    ['ff', 'ffield'],    ['de', 'deposit'],  ['gr', 'grav'],
    ['pr', 'pressure'],  ['tk', 'timeK'],    ['tm', 'timeMin'],
    ['qa', 'charge'],    ['pu', 'pump'],     ['pa', 'particles'],
    ['te', 'tempo'],    ['pl', 'palette'],  ['vx', 'vortex'],
    ['rx', 'react'],
  ];

  const TOGGLE_MAP = [
    ['K', 'tglKernel'], ['F', 'tglField'], ['X', 'tglMouse'],
    ['C', 'tglChaos'],  ['P', 'tglPump'],  ['E', 'tglExact'], ['R', 'tglReact'],
  ];

  function encodeSettings(){
    let parts = [];
    let tg = '';
    for(const [k, id] of TOGGLE_MAP){
      tg += k + (ui[id].checked ? '1' : '0');
    }
    parts.push(tg);
    parts.push('M' + (ui.mouseAttract.checked ? 'a' : 'r'));
    for(const [k, id] of SLIDER_MAP){
      parts.push(k + ui[id].value);
    }
    // game params (only when enabled)
    if(gameUI.enabled.checked){
      parts.push('g1');
      parts.push('gs' + (gameUI.showZone.checked ? '1' : '0'));
      parts.push('gm' + (gameUI.modeEmpty.checked ? '0' : '1'));
      parts.push('gx' + gameUI.x.value);
      parts.push('gy' + gameUI.y.value);
      parts.push('gh' + gameUI.size.value);
      parts.push('gt' + gameUI.thresh.value);
      parts.push('gC' + gameUI.coverage.value);
      parts.push('gg' + gameUI.grace.value);
      parts.push('gWA' + (gameUI.winArea.checked ? '1':'0'));
      parts.push('gWP' + (gameUI.winPresence.checked ? '1':'0'));
      parts.push('gRb' + gameUI.reinfBlue.value);
      parts.push('gRp' + gameUI.reinfPink.value);
      if(gameUI.reinfFlow && parseFloat(gameUI.reinfFlow.value) > 0) parts.push('gRf' + gameUI.reinfFlow.value);
      if(gameUI.reinfWaves && gameUI.reinfWaves.checked) parts.push('gRw1');
      if(gameUI.powerEats && gameUI.powerEats.checked) parts.push('gPE1');
      if(gameUI.energyTransfer && !gameUI.energyTransfer.checked) parts.push('gET0');
    }
    // duality params (independent of GAME enable)
    if(gameUI.dualOn && gameUI.dualOn.checked){
      parts.push('gd1');
      parts.push('gD' + gameUI.dualRate.value);
      if(gameUI.dualEq) parts.push('gE' + gameUI.dualEq.value);
      if(gameUI.dualCoh) parts.push('gA' + gameUI.dualCoh.value);
      if(gameUI.initBalance && parseFloat(gameUI.initBalance.value) !== 0.5) parts.push('gB' + gameUI.initBalance.value);
      if(gameUI.colors && parseInt(gameUI.colors.value) > 0) parts.push('gCo' + gameUI.colors.value);
    }
    // preserve VRAM budget if non-default
    if(VRAM_BUDGET > (isDesktop ? 800 : 300)){
      parts.push('vm' + VRAM_BUDGET);
    }
    return parts.join('~');
  }

  function decodeSettings(hash){
    if(!hash) return;
    let parts;
    if(hash.includes('~')){
      parts = hash.split('~');
    } else {
      const raw = hash.split('.');
      parts = [];
      for(let i = 0; i < raw.length; i++){
        if(i > 0 && /^\d+$/.test(raw[i]) && parts.length > 0 && /\d$/.test(parts[parts.length-1])){
          parts[parts.length-1] += '.' + raw[i];
        } else {
          parts.push(raw[i]);
        }
      }
    }
    for(const p of parts){
      if(p.length > 4 && /^[KFXCPER][01]/.test(p)){
        for(let i = 0; i < p.length - 1; i += 2){
          const key = p[i];
          const val = p[i+1] === '1';
          for(const [k, id] of TOGGLE_MAP){
            if(k === key) ui[id].checked = val;
          }
        }
        continue;
      }
      if(p[0] === 'M' && p.length === 2){
        if(p[1] === 'a') ui.mouseAttract.checked = true;
        else ui.mouseRepel.checked = true;
        continue;
      }
      const sk = p.substring(0, 2);
      const sv = p.substring(2);
      for(const [k, id] of SLIDER_MAP){
        if(k === sk && ui[id]){
          const v = parseFloat(sv);
          if(!isNaN(v)){
            const min = parseFloat(ui[id].min);
            const max = parseFloat(ui[id].max);
            ui[id].value = Math.min(max, Math.max(min, v));
          }
        }
      }
      // game params
      if(p === 'g1'){ gameUI.enabled.checked = true; continue; }
      if(p === 'gL1'){ gameLockRequested = true; continue; }
      if(p.startsWith('gs')){ gameUI.showZone.checked = p[2] === '1'; continue; }
      if(p.startsWith('gm')){ if(p[2]==='1') gameUI.modeNotEmpty.checked=true; else gameUI.modeEmpty.checked=true; continue; }
      if(p.startsWith('gWA')){ if(gameUI.winArea) gameUI.winArea.checked = (p[3]==='1'); continue; }
      if(p.startsWith('gWP')){ if(gameUI.winPresence) gameUI.winPresence.checked = (p[3]==='1'); continue; }
      if(p.startsWith('gRb')){ if(gameUI.reinfBlue){ const v=parseFloat(p.substring(3)); if(!isNaN(v)) gameUI.reinfBlue.value=v; } continue; }
      if(p.startsWith('gRp')){ if(gameUI.reinfPink){ const v=parseFloat(p.substring(3)); if(!isNaN(v)) gameUI.reinfPink.value=v; } continue; }
      if(p.startsWith('gRf')){ if(gameUI.reinfFlow){ const v=parseFloat(p.substring(3)); if(!isNaN(v)) gameUI.reinfFlow.value=v; } continue; }
      if(p === 'gRw1'){ if(gameUI.reinfWaves) gameUI.reinfWaves.checked = true; continue; }
      if(p.startsWith('gCo')){ if(gameUI.colors){ const v=parseInt(p.substring(3)); if(!isNaN(v)) gameUI.colors.value=v; updateColorLabel(); } continue; }
      if(p === 'gPE1'){ if(gameUI.powerEats) gameUI.powerEats.checked = true; continue; }
      if(p === 'gET0'){ if(gameUI.energyTransfer) gameUI.energyTransfer.checked = false; continue; }

      if(p.startsWith('gW')){ if(gameUI.winArea) gameUI.winArea.checked = p[2] === '1'; if(gameUI.winPresence) gameUI.winPresence.checked = (p.length > 3 ? p[3] === '1' : false); continue; }
      if(p.startsWith('gd')){ if(gameUI.dualOn) gameUI.dualOn.checked = p[2] === '1'; continue; }
      const gMap = {gx:'x', gy:'y', gh:'size', gt:'thresh', gC:'coverage', gg:'grace', gD:'dualRate', gE:'dualEq', gA:'dualCoh', gB:'initBalance'};
      const gk2 = p.substring(0,2);
      if(gMap[gk2] && gameUI[gMap[gk2]]){
        const v = parseFloat(p.substring(2));
        if(!isNaN(v)) gameUI[gMap[gk2]].value = v;
      }
    }
    gameReadUI();
    syncUI();
  }

  function shareURL(){
    const hash = encodeSettings();
    const url = BASE_URL + '#' + hash;
    try { history.replaceState(null, '', '#' + hash); } catch(e){}

    function showOK(){
      const btn = document.getElementById('share');
      const orig = btn.innerHTML;
      btn.innerHTML = 'COPIED &#10003;';
      setTimeout(() => { btn.innerHTML = orig; }, 1500);
    }

    function showURL(){
      const btn = document.getElementById('share');
      const orig = btn.innerHTML;
      btn.innerHTML = '<span style="font-size:8px;word-break:break-all;max-width:200px;display:inline-block">' + url + '</span>';
      setTimeout(() => { btn.innerHTML = orig; }, 5000);
    }

    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(url).then(showOK).catch(() => { fallback(); });
    } else {
      fallback();
    }

    function fallback(){
      const ta = document.createElement('textarea');
      ta.value = url;
      ta.style.cssText = 'position:fixed;top:-9999px;left:-9999px;';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try { ok = document.execCommand('copy'); } catch(e){}
      document.body.removeChild(ta);
      if(ok) showOK();
      else showURL();
    }
  }

  document.getElementById('share').addEventListener('click', shareURL);

  if(location.hash.length > 1){
    decodeSettings(location.hash.substring(1));
  }

  window.addEventListener('hashchange', () => {
    if(location.hash.length > 1){
      gameLockRequested = false;
      decodeSettings(location.hash.substring(1));
      clearField();
      fieldFlip = 0;
      reset();
      if(gameLockRequested){
        gameLockRequested = false;
        enterLockedMode();
        needLayout = true;
      }
    }
  });

  // =========================
  // HUD
  // =========================
  const fpsEl = document.getElementById('fps');
  const tmEl  = document.getElementById('tm');
  const pcEl  = document.getElementById('pc');

  // =========================
  // GPU params
  // =========================
  const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const isDesktop = !window.matchMedia('(pointer:coarse)').matches;

  // VRAM budget: override with ~vm=X in URL hash (MB)
  // Each particle: 6 textures (state/k0/k1 x2 ping-pong) x RGBA32F = 96 bytes
  let VRAM_BUDGET = isDesktop ? 800 : 300;
  {
    const h = location.hash;
    const vm = h.match(/vm(\d+)/);
    if(vm) VRAM_BUDGET = parseInt(vm[1]);
  }
  const BYTES_PER_PARTICLE = 96;
  const maxPixels = Math.min(VRAM_BUDGET * 1024 * 1024 / BYTES_PER_PARTICLE, maxTexSize * maxTexSize);
  const TEX_SIZE = Math.min(maxTexSize, Math.floor(Math.sqrt(maxPixels)));
  const N        = TEX_SIZE * TEX_SIZE;
  const FIELD_SIZE = 256;
  const MAX_POW  = Math.min(30, Math.ceil(Math.log2(N)));

  console.log('TWIST-J | TEX:', TEX_SIZE, ' N:', N.toLocaleString(),
    ' MAX_POW: 2^'+MAX_POW, ' VRAM:', VRAM_BUDGET+'MB',
    isDesktop ? '(desktop)' : '(mobile)',
    ' GPU_MAX_TEX:', maxTexSize);
  pcEl.textContent = N.toLocaleString();
  let activeN = N;

  // =========================
  // WebGL helpers
  // =========================
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s) + "\n\n" + src);
    }
    return s;
  }
  function program(vsSrc, fsSrc){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
  }
  function tex2D(w,h, internalFormat, format, type, filter){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
    return t;
  }
  function fboMRT(textures){
    const f = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    const bufs = [];
    for(let i=0;i<textures.length;i++){
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, textures[i], 0);
      bufs.push(gl.COLOR_ATTACHMENT0+i);
    }
    gl.drawBuffers(bufs);
    const st = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if(st !== gl.FRAMEBUFFER_COMPLETE){
      throw new Error("FBO incomplete: " + st.toString(16));
    }
    return f;
  }
  function U(p, name){ return gl.getUniformLocation(p, name); }

  // =========================
  // SHADERS
  // =========================
  const VS_QUAD = `#version 300 es
  layout(location=0) in vec2 a_pos;
  out vec2 v_uv;
  void main(){
    v_uv = a_pos*0.5 + 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  const FS_INIT = `#version 300 es
  precision highp float;
  precision highp int;
  layout(location=0) out vec4 o_state;
  layout(location=1) out vec4 o_k0;
  layout(location=2) out vec4 o_k1;
  uniform uint u_seed;
  uniform int u_dualOn;
  uniform float u_initBalance; // 0=all PINK, 0.5=equal, 1=all BLUE

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  void main(){
    uvec2 fc = uvec2(uint(gl_FragCoord.x), uint(gl_FragCoord.y));
    uint id = fc.y * uint(${TEX_SIZE}) + fc.x;
    uint h = hash(id ^ (u_seed*747796405u + 2891336453u));

    uint h2 = hash(h);
    float r  = float(h & 0xFFFFu) / 65535.0;
    float a  = float(h2 & 0xFFFFu) / 65535.0 * 6.2831853;
    float rad = sqrt(r) * 1.4;
    vec2 pos = vec2(cos(a), sin(a)) * rad;

    uint h3 = hash(h2 + 1u);
    float va = a + 1.5708;
    float vmag = 0.005 + float(h3 & 0xFFFFu) / 65535.0 * 0.01;
    vec2 vel = vec2(cos(va), sin(va)) * vmag;

    uint k0 = hash(h2);
    uint k1 = hash(k0);
    int p1  = int(k0 % 5u);
    int p4  = int((k0/5u) % 5u);
    int p1p = int((k0/25u) % 5u);
    int p4p = int((k0/125u) % 5u);
    int q   = int(k1 % 5u);
    int ts  = int((k1/5u) % 5u);

    // Duality per-particle state
    float sp;
    if(u_dualOn == 1){
      // Angle-based separation with balance control
      // u_initBalance: 0.5=equal, >0.5=more BLUE, <0.5=more PINK
      // Shift the boundary: balance=0.7 means 70% BLUE â†’ threshold moves down
      float noise = (float(h3 & 0xFFFFu) / 65535.0 - 0.5) * 0.8;
      float thresh = (1.0 - u_initBalance * 2.0); // bal=0.5â†’0, bal=0.1â†’0.8, bal=0.9â†’-0.8
      sp = (sin(a) + noise > thresh) ? 0.0 : 1.0;
    } else {
      sp = float(k1 & 1u);
    }
    uint k2 = hash(k1 + 17u);
    float pw = 0.6 + float(k2 & 0xFFFFu) / 65535.0 * 0.4;

    o_state = vec4(pos, vel);
    o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
    o_k1 = vec4(float(q), float(ts), sp, pw);
  }`;

  const FS_FADE = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_prev;
  uniform float u_fade;
  out vec4 o_col;
  void main(){ o_col = min(texture(u_prev, v_uv) * u_fade, 8.0); }`;

  const FS_FIELD_FADE = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_prev;
  uniform float u_fade;
  out vec4 o_col;
  void main(){ o_col = min(texture(u_prev, v_uv) * u_fade, 1.0); }`;

  const FS_BLIT = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_tex;
  uniform int u_palette;
  uniform int u_zoneShow;
  uniform vec4 u_zone; // cx, cy, half, lineW
  uniform float u_zoneDanger; // 0=safe, 1=critical
  uniform int u_zoneMode; // 0=EMPTY(blue), 1=NOT_EMPTY(green)
  uniform float u_time;
  uniform float u_viewScale;
  uniform float u_cs;
  uniform float u_sn;
  uniform vec2 u_pan;
  uniform float u_aspect;
  out vec4 o_col;
  void main(){
    vec3 c = texture(u_tex, v_uv).rgb;
    c = c / (1.0 + c);

    if(u_palette >= 6){
      float lum = dot(c, vec3(0.299, 0.587, 0.114));
      float sat = (u_palette >= 9) ? 1.8 : (u_palette >= 8) ? 4.0 : (u_palette >= 7) ? 3.0 : 2.2;
      c = max(vec3(0.0), lum + (c - lum) * sat);
      float gam = (u_palette >= 9) ? 0.85 : 0.75;
      c = pow(c, vec3(gam));
    }

    if(u_zoneShow == 1){
      vec2 ndc = v_uv * 2.0 - 1.0;
      ndc.x /= u_aspect;
      ndc /= max(u_viewScale, 0.001);
      vec2 w = mat2(u_cs, u_sn, -u_sn, u_cs) * ndc + u_pan;
      float dx = abs(w.x - u_zone.x) - u_zone.z;
      float dy = abs(w.y - u_zone.y) - u_zone.z;
      float outer = max(dx, dy);
      float lw = u_zone.w;

      // zone color: blue(safe) -> red(danger)
      float d = clamp(u_zoneDanger, 0.0, 1.0);
      vec3 safeCol = (u_zoneMode == 1) ? vec3(0.1, 0.7, 0.3) : vec3(0.1, 0.4, 0.8);
      vec3 dangerCol = vec3(0.9, 0.1, 0.05);
      vec3 zoneCol = mix(safeCol, dangerCol, d);

      // blink: starts at d>0.4, frequency and intensity build with danger
      float blinkPhase = 0.0;
      if(d > 0.4){
        float blinkT = (d - 0.4) / 0.6; // 0..1 over danger range
        float freq = 3.0 + 12.0 * blinkT * blinkT; // 3 Hz -> 15 Hz
        float pulse = sin(u_time * freq * 6.2832) * 0.5 + 0.5;
        blinkPhase = pulse * blinkT * 0.5;
      }

      // fill: barely visible, grows with danger + blink
      if(outer < 0.0){
        float fillAlpha = 0.03 + 0.12 * d + blinkPhase * 0.2;
        c = mix(c, zoneCol, fillAlpha);
      }

      // border: subtle, grows with danger + blink
      bool onBorder = outer > -lw && outer < lw && min(dx,dy) < lw;
      if(onBorder){
        float borderAlpha = 0.15 + 0.55 * d + blinkPhase * 0.3;
        c = mix(c, zoneCol, borderAlpha);
      }
    }

    o_col = vec4(c, 1.0);
  }`;

  const FS_BLUR = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_tex;
  uniform vec2 u_dir;
  out vec4 o_col;
  void main(){
    vec4 c = texture(u_tex, v_uv) * 0.382925;
    c += texture(u_tex, v_uv + u_dir * 1.384615) * 0.241732;
    c += texture(u_tex, v_uv - u_dir * 1.384615) * 0.241732;
    c += texture(u_tex, v_uv + u_dir * 3.230769) * 0.06136;
    c += texture(u_tex, v_uv - u_dir * 3.230769) * 0.06136;
    o_col = c;
  }`;

  const VS_POINTS_FIELD = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform float u_bounds;
  uniform int   u_tm;
  uniform uint  u_frame;
  uniform float u_deposit;
  uniform int   u_kernelOn;
  uniform int   u_dualOn;
  uniform float u_dualEq;

  out float v_mass;
  out float v_qp;
  out float v_qm;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  int idx_map(int z, int tm){
    int i = (tm==0) ? z : (z+2);
    return (i>=5) ? (i-5) : i;
  }

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};

    vec4 st = texelFetch(u_state, ivec2(xx,yy), 0);
    vec2 pos = st.xy;

    float mass = 0.0;
    float qp = 0.0;
    float qm = 0.0;

    // Duality: when enabled, use (g,b) as species density (BLUE/PINK) instead of +/- charge.
    if(u_dualOn == 1){
      vec4 kk1 = texelFetch(u_k1, ivec2(xx,yy), 0);
      float sp = kk1.z;                 // 0=BLUE, 1=PINK
      float pw = clamp(kk1.w, 0.0, 1.0); // strength
      float dep = u_deposit * pw;

      // keep mass deposition (gyron -> mass) for game-zone mechanics
      if(u_kernelOn == 1){
        vec4 k0 = texelFetch(u_k0, ivec2(xx,yy), 0);
        int p1  = int(k0.x + 0.5);
        int p4  = int(k0.y + 0.5);
        int p1p = int(k0.z + 0.5);
        int p4p = int(k0.w + 0.5);
        int q   = int(kk1.x + 0.5);
        int ts  = int(kk1.y + 0.5);
        int z = z_trace6(p1,p4,p1p,p4p,q,ts);
        if(u_tm == 0 && z == 4) mass = u_deposit;
      } else {
        uint uid = uint(yy) * uint(${TEX_SIZE}) + uint(xx);
        uint h = hash(uid + u_frame * 1923u);
        uint k = h % 5u;
        if(u_tm == 0 && k == 4u) mass = u_deposit;
      }

      if(sp < 0.5) qp = dep; else qm = dep;
    } else {
      // Original: charge deposition from kernel/random idx
      if(u_kernelOn == 1){
        vec4 k0 = texelFetch(u_k0, ivec2(xx,yy), 0);
        vec4 kk1 = texelFetch(u_k1, ivec2(xx,yy), 0);
        int p1  = int(k0.x + 0.5);
        int p4  = int(k0.y + 0.5);
        int p1p = int(k0.z + 0.5);
        int p4p = int(k0.w + 0.5);
        int q   = int(kk1.x + 0.5);
        int ts  = int(kk1.y + 0.5);
        int z = z_trace6(p1,p4,p1p,p4p,q,ts);
        int idx = idx_map(z, u_tm);

        if(u_tm == 0 && z == 4) mass = u_deposit;
        if(idx == 3) qp = u_deposit;
        if(idx == 4) qm = u_deposit;
      } else {
        uint uid = uint(yy) * uint(${TEX_SIZE}) + uint(xx);
        uint h = hash(uid + u_frame * 1923u);
        uint k = h % 5u;
        if(u_tm == 0 && k == 4u) mass = u_deposit;
        if(k == 3u) qp = u_deposit;
        if(k == 4u) qm = u_deposit;
      }
    }

    v_mass = mass;
    v_qp = qp;
    v_qm = qm;
    vec2 p = pos / u_bounds;
    gl_Position = vec4(p, 0.0, 1.0);
    gl_PointSize = 1.0;
  }`;

  const FS_FIELD_DEPOSIT = `#version 300 es
  precision highp float;
  in float v_mass;
  in float v_qp;
  in float v_qm;
  out vec4 o_col;
  void main(){ o_col = vec4(v_mass, v_qp, v_qm, 0.0); }`;

  // =========================
  // GAME: 1x1 zone particle counter (robust presence)
  // =========================
  const VS_ZONE_COUNT = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k1;

  uniform float u_cx;
  uniform float u_cy;
  uniform float u_half;

  out float v_species;
  out float v_inZone;

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};

    vec2 pos = texelFetch(u_state, ivec2(xx,yy), 0).xy;
    vec4 k1  = texelFetch(u_k1, ivec2(xx,yy), 0);

    // species encoded in k1.z : BLUE=0, PINK=1
    v_species = k1.z;

    bool inZ = (abs(pos.x - u_cx) <= u_half) && (abs(pos.y - u_cy) <= u_half);
    v_inZone = inZ ? 1.0 : 0.0;

    // Collapse all in-zone particles to the single pixel at center.
    // Off-zone particles are sent outside clip.
    if(inZ){
      gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
      gl_PointSize = 1.0;
    } else {
      gl_Position = vec4(2.0, 2.0, 0.0, 1.0);
      gl_PointSize = 0.0;
    }
  }`;

  const VS_TOTAL_COUNT = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_k1;
  out float v_species;

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};
    vec4 k1  = texelFetch(u_k1, ivec2(xx,yy), 0);
    v_species = k1.z;
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    gl_PointSize = 1.0;
  }`;

  const FS_TOTAL_COUNT = `#version 300 es
  precision highp float;
  in float v_species;
  out vec4 o_col;
  void main(){
    if(v_species < 0.5) o_col = vec4(1.0, 0.0, 0.0, 0.0);
    else                o_col = vec4(0.0, 1.0, 0.0, 0.0);
  }`;

  FS_ZONE_COUNT = `#version 300 es
  precision highp float;
  in float v_species;
  in float v_inZone;
  out vec4 o_col;
  void main(){
    if(v_inZone < 0.5) discard;
    // Additive count: R=BLUE, G=PINK, B=TOTAL (all particles)
    if(v_species < 0.5) o_col = vec4(1.0, 0.0, 1.0, 0.0);
    else                o_col = vec4(0.0, 1.0, 1.0, 0.0);
  }`;

  const FS_FIELD_REACT = `#version 300 es
  precision highp float;
  in vec2 v_uv;
  uniform sampler2D u_prev;
  uniform vec2 u_texel;
  uniform float u_charge;
  uniform float u_pressure;
  uniform float u_react;
  uniform int u_reactOn;

  // Duality: BLUE/PINK predation implemented on species channels (g,b)
  uniform int u_dualOn;
  uniform float u_dualRate;
  uniform float u_dualEq;
  uniform float u_dualCoh;
  uniform float u_eatMulBlue;
  uniform float u_eatMulPink;
  uniform int u_energyTransfer;

  out vec4 o_col;

  float sat(float x){ return clamp(x, 0.0, 1.0); }

  void main(){
    vec4 f = texture(u_prev, v_uv);
    float r = f.r;
    float g = f.g;
    float b = f.b;
    float h = f.a;// (0) duality: stronger eats weaker (transfer on channels g/b)
// NOTE: BALANCE no longer changes core mechanics; it is handled on CPU as reinforcements.
if(u_dualOn == 1 && u_dualRate > 0.0){
  float rate = u_dualRate;
  float aggr = rate * rate * 0.1;

  // Boundary diffusion: species must overlap for eating to happen
  vec4 fL = texture(u_prev, v_uv - vec2(u_texel.x, 0.0));
  vec4 fR = texture(u_prev, v_uv + vec2(u_texel.x, 0.0));
  vec4 fD = texture(u_prev, v_uv - vec2(0.0, u_texel.y));
  vec4 fU = texture(u_prev, v_uv + vec2(0.0, u_texel.y));
  float gN = (g + fL.g + fR.g + fD.g + fU.g) * 0.2;
  float bN = (b + fL.b + fR.b + fD.b + fU.b) * 0.2;

  float cohN = sat(u_dualCoh / 30.0);
  float mixK = 0.06 + 0.18 * cohN + 0.20 * sat(rate / 6.0);
  g = mix(g, gN, mixK);
  b = mix(b, bN, mixK);

  float diff = abs(g - b);
  float sum = g + b + 0.0001;
  float adv = sat(diff / sum);

  // === DIRECT EATING: dominant species consumes minority ===
  // transferRate: fraction of minority consumed per step
  float transferRate = aggr * pow(adv, 0.4) * 0.25;
  transferRate = min(transferRate, 0.95); // cap so we don't overshoot

  // ENERGY TRANSFER multiplier: eater gains more than eaten loses
  float gainMul = (u_energyTransfer == 1) ? 2.0 : 1.0;

  if(g > b && b > 0.0){
    float mul = u_eatMulBlue;
    float eaten = b * transferRate * mul;
    eaten = min(eaten, b); // never eat more than exists
    b -= eaten;
    g += eaten * gainMul;
    g = sat(g);
  } else if(b > g && g > 0.0){
    float mul = u_eatMulPink;
    float eaten = g * transferRate * mul;
    eaten = min(eaten, g);
    g -= eaten;
    b += eaten * gainMul;
    b = sat(b);
  }
}


if(u_reactOn == 1 && u_dualOn == 0){

      // (1) charge annihilation: + and - cancel -> heat (h)
      float ann = min(g, b) * u_react;
      g -= ann;
      b -= ann;

      // cooling even when FIELD FADE = 1
      h *= 0.992;

      // heat from reaction (scales with CHARGE and REACT)
      float heatGain = (0.22 + 0.02 * u_charge) * u_react;
      h = sat(h + ann * heatGain);

      // ash: small fraction of reaction goes to mass
      r = sat(r + ann * 0.08 * u_react);

      // (2) fission: heat + density gradient creates local polarization
      float rL = texture(u_prev, v_uv - vec2(u_texel.x, 0.0)).r;
      float rR = texture(u_prev, v_uv + vec2(u_texel.x, 0.0)).r;
      float rD = texture(u_prev, v_uv - vec2(0.0, u_texel.y)).r;
      float rU = texture(u_prev, v_uv + vec2(0.0, u_texel.y)).r;
      float gx = rR - rL;
      float gy = rU - rD;
      float gmag = abs(gx) + abs(gy);

      float stress = h * gmag;
      float thr = (0.010 + 0.002 * u_pressure) / max(u_react, 0.01);
      float over = max(0.0, stress - thr);

      // sign from main gradient axis (flips on opposite side -> dipole)
      float sgn = (abs(gx) > abs(gy)) ? sign(gx) : sign(gy);

      float makeQ = over * (0.35 + 0.03 * u_charge) * u_react;
      makeQ = min(makeQ, 0.25 * r);

      float rhoQ = makeQ * sgn;
      if(rhoQ > 0.0) g = sat(g + rhoQ);
      else           b = sat(b - rhoQ);

      // consume mass so it is not numerically infinite
      r = sat(r - abs(rhoQ) * 0.45);
    }

    o_col = vec4(r, g, b, h);
  }`;

  const FS_PHYS = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform sampler2D u_field;
  uniform sampler2D u_fieldRaw;
  uniform vec2  u_fieldTexel;

  uniform int   u_tm;
  uniform uint  u_frame;

  uniform int   u_kernelOn;
  uniform int   u_fieldOn;
  uniform int   u_reactOn;
  uniform float u_react;
  uniform int   u_mouseOn;
  uniform int   u_chaosOn;
  uniform int   u_pumpOn;
  uniform int   u_exactIFS;

  // Duality (two particle species: BLUE/PINK)
  uniform int   u_dualOn;
  uniform float u_dualRate;
  uniform float u_dualEq;
  uniform float u_dualCoh;
  uniform float u_eatMulBlue;
  uniform float u_eatMulPink;
  uniform int u_energyTransfer;

  // Reinforcements (driven by BALANCE slider on CPU)
  uniform int   u_reinfOn;
  uniform float u_reinfProb;
  uniform int   u_reinfSide;
  uniform uint  u_reinfSeed;
  uniform vec2  u_reinfDir;
  uniform float u_reinfSpeed;
  uniform float u_reinfSpread;
  uniform float u_reinfMulBlue;
  uniform float u_reinfMulPink;

  uniform float u_grav;
  uniform float u_pump;
  uniform float u_charge;
  uniform float u_pressure;

  uniform vec2  u_mouse;
  uniform float u_mouseDown;
  uniform float u_mouseSign;

  uniform float u_damping;
  uniform float u_force;
  uniform float u_chaos;
  uniform float u_bounds;
  uniform float u_kick;

  uniform vec2  u_J;
  uniform vec2  u_ck[5];

  uniform float u_timeK;
  uniform float u_timeMin;
  uniform float u_tempo;
  uniform float u_vortex;

  layout(location=0) out vec4 o_state;
  layout(location=1) out vec4 o_k0;
  layout(location=2) out vec4 o_k1;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int add5i(int a,int b){ int s=a+b; return (s>=5)? s-5 : s; }
  int sub5i(int a,int b){ int s=a-b; return (s<0)? s+5 : s; }
  int neg5i(int x){ return (x==0)? 0 : 5-x; }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  int idx_map(int z, int tm){
    int i = (tm==0) ? z : (z+2);
    return (i>=5) ? (i-5) : i;
  }

  vec2 cmul(vec2 a, vec2 b){
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
  }

  float hashf(ivec2 c, int tm){
    int n = (c.x*73856093) ^ (c.y*19349663) ^ (tm*83492791);
    n = (n<<13) ^ n;
    int nn = (n*(n*n*15731 + 789221) + 1376312589);
    return fract(float(nn) * 0.00000000023283064);
  }

  void main(){
    ivec2 coord = ivec2(gl_FragCoord.xy);

    vec4 st = texelFetch(u_state, coord, 0);
    vec4 k0 = texelFetch(u_k0, coord, 0);
    vec4 k1 = texelFetch(u_k1, coord, 0);

    vec2 pos = st.xy;
    vec2 vel = st.zw;

    vec4 ok0 = k0;
    vec4 ok1 = k1;

    // Duality per-particle state (stored in k1.zw)
    float sp = k1.z; // 0=BLUE, 1=PINK
    float pw = clamp(k1.w, 0.0, 1.0);

    // Reinforcements: occasionally respawn a small subset of particles of one species
    // from a random boundary direction. Controlled on CPU via BALANCE slider.
    if(u_reinfOn == 1 && u_reinfProb > 0.0){
      uint uid2 = uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x);
      uint hh = hash(uid2 ^ u_reinfSeed);
      float r0 = float(hh & 0xFFFFu) / 65535.0;
      if(r0 < u_reinfProb){
        vec2 dir = normalize(u_reinfDir);
        vec2 perp = vec2(-dir.y, dir.x);

        uint h1 = hash(hh + 1u);
        uint h2 = hash(hh + 2u);
        uint h3 = hash(hh + 3u);
        uint h4 = hash(hh + 4u);

        float off = (float(h1 & 0xFFFFu) / 65535.0) * 2.0 - 1.0;

        // spawn on the boundary opposite to travel direction (entering the domain)
        vec2 p0 = (-dir) * (u_bounds * 0.98) + perp * off * (u_bounds * 0.95);
        p0 = clamp(p0, vec2(-u_bounds*0.98), vec2(u_bounds*0.98));

        float spd = u_reinfSpeed * (0.65 + 0.70 * (float(h3 & 0xFFFFu) / 65535.0));
        float spr = u_reinfSpread * ((float(h4 & 0xFFFFu) / 65535.0) * 2.0 - 1.0);

        pos = p0;
        vel = dir * spd + perp * spr;

        sp = float(u_reinfSide);
        float mul = (u_reinfSide==0) ? u_reinfMulBlue : u_reinfMulPink;
        pw = (0.65 + 0.35 * (float(hash(hh + 7u) & 0xFFFFu) / 65535.0)) * mul;
      }
    }

    int idx = 0;
    int p1=0,p4=0,p1p=0,p4p=0,q=0,ts=0;
    int z0=0, q0=0;

    if(u_kernelOn == 1){
      p1  = int(k0.x + 0.5);
      p4  = int(k0.y + 0.5);
      p1p = int(k0.z + 0.5);
      p4p = int(k0.w + 0.5);
      q   = int(k1.x + 0.5);
      ts  = int(k1.y + 0.5);

      z0 = z_trace6(p1,p4,p1p,p4p,q,ts);
      q0 = q;
      idx = idx_map(z0, u_tm);

      if(idx==0){
        int tp=p1; p1=p4; p4=tp;
        tp=p1p; p1p=p4p; p4p=tp;
      } else if(idx==1){
        int tp=p1;  p1=neg5i(p1p); p1p=neg5i(tp);
        tp=p4;      p4=neg5i(p4p); p4p=neg5i(tp);
        q  = neg5i(q);
        ts = neg5i(ts);
      } else if(idx==2){
        int op1=p1, op4=p4, op1p=p1p, op4p=p4p, ots=ts;
        p1  = add5i(neg5i(op1p), 2);
        p4  = add5i(add5i(neg5i(op4p), 1), ots);
        p1p = add5i(neg5i(op1),  2);
        p4p = add5i(add5i(neg5i(op4),  1), neg5i(ots));
        q   = sub5i(1, q);
        ts  = neg5i(ots);
      } else if(idx==3){
        p1  = sub5i(2,p1);  p4  = sub5i(1,p4);
        p1p = sub5i(3,p1p); p4p = sub5i(4,p4p);
        q   = sub5i(1,q);   ts  = sub5i(1,ts);
      } else {
        p1  = sub5i(2,p1);  p4  = sub5i(1,p4);
        p1p = sub5i(3,p1p); p4p = sub5i(4,p4p);
        q   = sub5i(2,q);   ts  = sub5i(1,ts);
      }
    } else {
      uint uid = uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x);
      uint h = hash(uid + u_frame * 1923u);
      idx = int(h % 5u);
    }

    vec2 target = u_ck[idx] + cmul(u_J, pos);

    if(u_exactIFS == 1){
      pos = target;
      vel = vec2(0.0);
      if(abs(pos.x) > u_bounds){ pos.x = sign(pos.x) * u_bounds; }
      if(abs(pos.y) > u_bounds){ pos.y = sign(pos.y) * u_bounds; }
      o_state = vec4(pos, vel);
      if(u_kernelOn == 1){
        o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
        o_k1 = vec4(float(q), float(ts), sp, pw);
      } else {
        o_k0 = ok0;
        o_k1 = vec4(ok1.x, ok1.y, sp, pw);
      }
      return;
    }

    vec2 acc = (target - pos) * u_force;

    float N = 1.0;

    // Field is sampled either for full FIELD dynamics, or just for duality (species) sensing.
    bool needField = (u_fieldOn == 1) || (u_dualOn == 1);
    vec4 fBlur = vec4(0.0);

    if(needField){
      vec2 uv = pos / u_bounds * 0.5 + 0.5;
      uv = clamp(uv, vec2(0.001), vec2(0.999));
      fBlur = texture(u_field, uv);

      if(u_fieldOn == 1){
        float rho = fBlur.r;

        N = 1.0 / (1.0 + u_timeK * rho);
        N = clamp(N, u_timeMin, 1.0);

        if(u_grav > 0.0){
          float fx1 = texture(u_field, uv + vec2(u_fieldTexel.x, 0.0)).r;
          float fx0 = texture(u_field, uv - vec2(u_fieldTexel.x, 0.0)).r;
          float fy1 = texture(u_field, uv + vec2(0.0, u_fieldTexel.y)).r;
          float fy0 = texture(u_field, uv - vec2(0.0, u_fieldTexel.y)).r;
          vec2 gradL = vec2(fx1 - fx0, fy1 - fy0);
          // vir: rotuj gradient (0 = radial pad, 1 = cisty orbit)
          vec2 curl = vec2(-gradL.y, gradL.x);
          vec2 gForce = mix(gradL, curl, u_vortex);
          acc += gForce * u_grav;
        }

        vec4 raw_xp = texture(u_fieldRaw, uv + vec2(u_fieldTexel.x, 0.0));
        vec4 raw_xm = texture(u_fieldRaw, uv - vec2(u_fieldTexel.x, 0.0));
        vec4 raw_yp = texture(u_fieldRaw, uv + vec2(0.0, u_fieldTexel.y));
        vec4 raw_ym = texture(u_fieldRaw, uv - vec2(0.0, u_fieldTexel.y));

        if(u_pressure > 0.0){
          vec2 gradS = vec2(raw_xp.r - raw_xm.r, raw_yp.r - raw_ym.r);
          acc -= gradS * u_pressure;
        }

        // Charge is disabled during duality (g/b are reserved for species)
        if(u_charge > 0.0 && u_dualOn == 0){
          vec4 raw_here = texture(u_fieldRaw, uv);
          float rhoQ = raw_here.g - raw_here.b;
          float Q = sign(rhoQ);
          float qxp = raw_xp.g - raw_xp.b;
          float qxm = raw_xm.g - raw_xm.b;
          float qyp = raw_yp.g - raw_yp.b;
          float qym = raw_ym.g - raw_ym.b;
          vec2 gradQ = vec2(qxp - qxm, qyp - qym);
          acc += Q * gradQ * u_charge;
        }

        // heat (A channel): blast force from heat gradient
        if(u_reactOn == 1){
          float hxp = raw_xp.a;
          float hxm = raw_xm.a;
          float hyp = raw_yp.a;
          float hym = raw_ym.a;
          vec2 gradH = vec2(hxp - hxm, hyp - hym);
          // push away from hot regions
          float blast = (0.10 + 0.18 * u_pressure + 0.03 * u_charge) * u_react;
          acc -= gradH * blast;
        }
      }

    // Duality: make the two colors actually aggregate into domains.
    // Each particle follows the gradient of its own density (BLUE=g, PINK=b)
    // and avoids the opposite density. A small pressure from total density prevents collapse.
    if(u_dualOn == 1 && u_dualCoh > 0.0){
      vec4 bx1 = texture(u_field, uv + vec2(u_fieldTexel.x, 0.0));
      vec4 bx0 = texture(u_field, uv - vec2(u_fieldTexel.x, 0.0));
      vec4 by1 = texture(u_field, uv + vec2(0.0, u_fieldTexel.y));
      vec4 by0 = texture(u_field, uv - vec2(0.0, u_fieldTexel.y));

      vec2 gradBlue = vec2(bx1.g - bx0.g, by1.g - by0.g);
      vec2 gradPink = vec2(bx1.b - bx0.b, by1.b - by0.b);
      vec2 gradSum  = vec2((bx1.g + bx1.b) - (bx0.g + bx0.b),
                           (by1.g + by1.b) - (by0.g + by0.b));

      float mySign = (sp < 0.5) ? 1.0 : -1.0;
      vec2 gradSep = mySign * (gradBlue - gradPink);

      float coh = u_dualCoh;

      // Suppress cohesion near mouse (let player control particles)
      if(u_mouseOn == 1 && u_mouseDown > 0.5){
        float md2 = dot(pos - u_mouse, pos - u_mouse);
        float mouseR = 0.8; // suppression radius
        if(md2 < mouseR * mouseR){
          float prox = 1.0 - sqrt(md2) / mouseR;
          coh *= (1.0 - prox * 0.92); // up to 92% reduction near cursor
        }
      }

      // stronger particles cohere more; weak ones drift
      float p = 0.25 + 0.75 * pw;
      acc += gradSep * coh * p;

      // pressure from total density to avoid singular collapse
      float press = coh * 0.65;
      acc -= gradSum * press;
    }

    }

    if(u_mouseOn == 1 && u_mouseDown > 0.5 && (u_dualOn == 0 || sp < 0.5)){
      vec2 md = pos - u_mouse;
      float d2 = dot(md, md) + 0.002;
      float mRad = (u_dualOn == 1) ? 1.2 : 0.6; // wider reach in duality
      if(d2 < mRad){
        float mforce = (u_dualOn == 1) ? 0.15 : 0.06; // 2.5Ã— stronger in duality
        acc += normalize(md) * (mforce / d2) * u_mouseSign;
      }
    }

    if(u_chaosOn == 1 && u_chaos > 0.0){
      float h = hashf(coord, u_tm);
      float ang = h * 6.2831853;
      acc += vec2(cos(ang), sin(ang)) * (u_chaos * 0.006);
    }

    float dt = N * u_tempo;

    // Duality update: each particle has species (BLUE=0 / PINK=1) and strength pw in k1.zw.
// Species competes locally using the field channels (g,b). Dominant species "eats" the weaker:
// weak particles lose strength and eventually flip to the dominant species.
// NOTE: BALANCE no longer changes these mechanics; it is handled on CPU via reinforcements.
if(u_dualOn == 1 && u_dualRate > 0.0){
  float blue = fBlur.g;
  float pink = fBlur.b;
  float sum = blue + pink;

  if(sum > 0.000001){
    float d0 = (blue - pink) / (sum + 0.0005);
    float dom0 = abs(d0);  // 0=balanced, 1=total dominance

    float mySign = (sp < 0.5) ? 1.0 : -1.0;
    float align = d0 * mySign; // +1 = deep in home territory, -1 = deep in enemy

    float rate = u_dualRate;
    float k = rate * rate * 0.05 * dt;

    // POWER EATS multipliers
    float myMul = (sp < 0.5) ? u_eatMulBlue : u_eatMulPink;
    float enemyMul = (sp < 0.5) ? u_eatMulPink : u_eatMulBlue;

    // In friendly territory: particle strengthens
    // In enemy territory: particle weakens
    if(align > 0.0){
      float gainRate = (u_energyTransfer == 1) ? 0.50 : 0.15;
      pw += align * k * gainRate * myMul;
    } else {
      float lossRate = (u_energyTransfer == 1) ? 2.50 : 1.20;
      pw += align * k * lossRate * enemyMul; // align is negative so this subtracts
    }
    pw = clamp(pw, 0.0, 1.0);

    // FLIP: weak particle in enemy territory converts to enemy species
    // This IS the eating: enemy loses a particle, dominant species gains one
    float flipPw  = (u_energyTransfer == 1)
      ? 0.25 + 0.25 * clamp(rate / 5.0, 0.0, 1.0)   // 0.25..0.50
      : 0.08 + 0.15 * clamp((rate - 3.0) / 7.0, 0.0, 1.0);
    float flipDom = (u_energyTransfer == 1)
      ? 0.10 - 0.05 * clamp(rate / 5.0, 0.0, 1.0)    // 0.10..0.05
      : 0.28 - 0.15 * clamp((rate - 3.0) / 7.0, 0.0, 1.0);

    if(pw < flipPw && dom0 > flipDom){
      // Convert: this particle switches sides
      sp = (d0 >= 0.0) ? 0.0 : 1.0;
      // The converted particle keeps its remaining pw PLUS gets bonus from energy transfer
      // Without ET: reset to 0.60 (moderate)
      // With ET: 0.90 base + bonus from dominance (the more dominant the eater, the stronger the convert)
      pw = (u_energyTransfer == 1) ? min(1.0, 0.90 + 0.10 * dom0) : 0.60;
    }
  }
}



float accLen = length(acc);
    if(accLen > 0.5) acc *= 0.5 / accLen;

    vel += acc * dt;
    vel *= mix(1.0, u_damping, dt);

    if(u_kernelOn==1 && u_pumpOn==1 && u_tm==0 && z0==4 && u_pump > 0.0){
      float ang = 6.2831853 * float(q0) / 5.0;
      vel += vec2(cos(ang), sin(ang)) * u_pump;
    }

    {
      uint tid = hash(uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x) + u_frame * 3571u);
      float ta = float(tid & 0xFFFFu) / 65535.0 * 6.2831853;
      float thermal = (u_fieldOn == 0) ? 0.003 : 0.0005;
      vel += vec2(cos(ta), sin(ta)) * (thermal + u_kick);
    }

    float vLen = length(vel);
    if(vLen > 1.0) vel *= 1.0 / vLen;

    pos += vel * dt;

    if(any(isnan(pos)) || any(isinf(pos)) || any(isnan(vel)) || any(isinf(vel))){
      uint rid = hash(uint(coord.y) * uint(${TEX_SIZE}) + uint(coord.x) + u_frame * 7919u);
      uint rid2 = hash(rid);
      float rx = float(rid  & 0xFFFFu) / 32767.5 - 1.0;
      float ry = float(rid2 & 0xFFFFu) / 32767.5 - 1.0;
      pos = vec2(rx, ry) * u_bounds * 0.8;
      vel = vec2(0.0);
    }

    if(abs(pos.x) > u_bounds){ pos.x = sign(pos.x) * u_bounds; vel.x *= -0.45; }
    if(abs(pos.y) > u_bounds){ pos.y = sign(pos.y) * u_bounds; vel.y *= -0.45; }

    o_state = vec4(pos, vel);

    if(u_kernelOn == 1){
      o_k0 = vec4(float(p1), float(p4), float(p1p), float(p4p));
      o_k1 = vec4(float(q), float(ts), sp, pw);
    } else {
      o_k0 = ok0;
      o_k1 = vec4(ok1.x, ok1.y, sp, pw);
    }
  }`;

  const VS_POINTS = `#version 300 es
  precision highp float;
  precision highp int;

  uniform sampler2D u_state;
  uniform sampler2D u_k0;
  uniform sampler2D u_k1;

  uniform float u_aspect;
  uniform float u_scale;
  uniform float u_rot;
  uniform vec2  u_pan;

  uniform int  u_tm;
  uniform uint u_frame;
  uniform int  u_kernelOn;
  uniform int  u_exactIFS;
  uniform sampler2D u_fieldBlur;
  uniform float u_bounds;
  uniform int u_dualOn;

  out float v_speed;
  flat out float v_z;
  flat out float v_gyron;
  out float v_charge;
  flat out float v_species;
  out float v_pow;

  uint hash(uint x){
    x ^= x >> 16u;
    x *= 0x7feb352du;
    x ^= x >> 15u;
    x *= 0x846ca68bu;
    x ^= x >> 16u;
    return x;
  }

  int z_trace6(int p1,int p4,int p1p,int p4p,int q,int ts){
    int s = p1+p4+p1p+p4p+q+ts;
    if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5; if(s>=5) s-=5;
    return s;
  }

  void main(){
    int id = gl_VertexID;
    int yy = id / ${TEX_SIZE};
    int xx = id - yy * ${TEX_SIZE};

    vec4 st = texelFetch(u_state, ivec2(xx,yy), 0);
    vec2 pos = st.xy;
    vec2 vel = st.zw;
    v_speed = length(vel);

    vec4 kk1 = texelFetch(u_k1, ivec2(xx,yy), 0);
    v_species = kk1.z;
    v_pow = kk1.w;

    // nabojovy pomer z rozmazaneho pole (casove vyhlazeny, stabilni)
    vec2 fuv = pos / u_bounds * 0.5 + 0.5;
    fuv = clamp(fuv, vec2(0.001), vec2(0.999));
    vec4 f = texture(u_fieldBlur, fuv);
    float qp = f.g;
    float qm = f.b;
    v_charge = (qp - qm) / (qp + qm + 0.08);

    int z = 1;
    int idx = 0;

    if(u_kernelOn == 1){
      vec4 k0 = texelFetch(u_k0, ivec2(xx,yy), 0);
      vec4 k1 = texelFetch(u_k1, ivec2(xx,yy), 0);
      int p1  = int(k0.x + 0.5);
      int p4  = int(k0.y + 0.5);
      int p1p = int(k0.z + 0.5);
      int p4p = int(k0.w + 0.5);
      int q   = int(k1.x + 0.5);
      int ts  = int(k1.y + 0.5);
      z = z_trace6(p1,p4,p1p,p4p,q,ts);
      v_gyron = (u_tm==0 && z==4) ? 1.0 : 0.0;
    } else {
      uint uid = uint(yy) * uint(${TEX_SIZE}) + uint(xx);
      uint h = hash(uid + u_frame * 1923u);
      idx = int(h % 5u);
      z = idx;
      v_gyron = (u_tm==0 && idx==4) ? 1.0 : 0.0;
    }

    v_z = float(z);

    float c = cos(u_rot);
    float s = sin(u_rot);
    vec2 rp = vec2(c*pos.x - s*pos.y, s*pos.x + c*pos.y);

    gl_Position = vec4((rp.x / u_aspect) * u_scale + u_pan.x, rp.y * u_scale + u_pan.y, 0.0, 1.0);
    float ps = (u_exactIFS == 1) ? 2.0 : 1.0;
    if(u_dualOn == 1) ps += clamp(v_pow, 0.0, 1.0) * 0.8;
    gl_PointSize = ps;
  }`;

  const FS_POINTS = `#version 300 es
  precision highp float;
  precision highp int;
  in float v_speed;
  flat in float v_z;
  flat in float v_gyron;
  in float v_charge;
  flat in float v_species;
  in float v_pow;
  uniform float u_scale;
  uniform int u_dualOn;
  uniform int u_dualColors;
  uniform float u_alphaMul;
  uniform int u_exactIFS;
  uniform int u_palette;
  out vec4 o_col;

  vec3 dualFriendly(int scheme){
    if(scheme == 1) return vec3(1.00, 0.65, 0.0);   // CRT AMBER (P3 phosphor)
    if(scheme == 2) return vec3(1.00, 1.00, 1.00);   // WHITE
    if(scheme == 3) return vec3(0.20, 0.55, 0.95);   // MIL BLUE
    if(scheme == 4) return vec3(1.00, 1.00, 1.00);   // WHITE (mono)
    return vec3(0.0, 0.85, 1.00);                     // BLUE
  }
  vec3 dualEnemy(int scheme){
    if(scheme == 1) return vec3(0.0, 1.00, 0.15);    // CRT GREEN (P1 phosphor)
    if(scheme == 2) return vec3(0.15, 0.20, 0.60);   // DARK BLUE
    if(scheme == 3) return vec3(0.90, 0.15, 0.10);   // MIL RED
    if(scheme == 4) return vec3(0.92, 0.82, 1.00);   // VIOLET GREY
    return vec3(1.00, 0.0, 0.75);                     // PINK
  }

  vec3 pal(int z, int p){
    if(p==0){
      if(z==0) return vec3(0.65, 0.55, 0.50);
      if(z==1) return vec3(0.60, 0.58, 0.48);
      if(z==2) return vec3(0.48, 0.62, 0.52);
      if(z==3) return vec3(0.48, 0.52, 0.65);
      return        vec3(0.55, 0.62, 0.65);
    }
    if(p==1){
      if(z==0) return vec3(0.95, 0.30, 0.12);
      if(z==1) return vec3(0.95, 0.72, 0.12);
      if(z==2) return vec3(0.15, 0.90, 0.40);
      if(z==3) return vec3(0.30, 0.50, 1.00);
      return        vec3(0.10, 0.85, 1.00);
    }
    if(p==2){
      if(z==0) return vec3(0.10, 0.18, 0.55);
      if(z==1) return vec3(0.05, 0.45, 0.70);
      if(z==2) return vec3(0.10, 0.72, 0.65);
      if(z==3) return vec3(0.30, 0.85, 0.85);
      return        vec3(0.60, 0.95, 1.00);
    }
    if(p==3){
      if(z==0) return vec3(0.75, 0.30, 0.10);
      if(z==1) return vec3(0.85, 0.60, 0.15);
      if(z==2) return vec3(0.30, 0.60, 0.12);
      if(z==3) return vec3(0.18, 0.45, 0.22);
      return        vec3(0.75, 0.50, 0.25);
    }
    if(p==4){
      if(z==0) return vec3(0.20, 0.0, 0.40);
      if(z==1) return vec3(0.65, 0.0, 0.45);
      if(z==2) return vec3(1.00, 0.25, 0.05);
      if(z==3) return vec3(1.00, 0.72, 0.10);
      return        vec3(1.00, 1.00, 0.70);
    }
    if(p==5){
      if(z==0) return vec3(1.00, 0.55, 0.60);
      if(z==1) return vec3(1.00, 0.80, 0.50);
      if(z==2) return vec3(0.55, 1.00, 0.65);
      if(z==3) return vec3(0.50, 0.65, 1.00);
      return        vec3(0.80, 0.55, 1.00);
    }
    // palety 6-8: ignoruji z, barveni z pole
    return vec3(1.0);
  }

  void main(){
    float e = clamp(v_speed * 28.0, 0.0, 1.0);

    // Duality override: render particles as two explicit species (FRIENDLY/ENEMY).
    if(u_dualOn == 1){
      vec3 friendly = dualFriendly(u_dualColors);
      vec3 enemy = dualEnemy(u_dualColors);
      vec3 c = (v_species < 0.5) ? friendly : enemy;

      float p = clamp(v_pow, 0.0, 1.0);

      // CRT phosphor scheme: much brighter, glowing
      if(u_dualColors == 1){
        c = mix(c*0.80, c*1.50, 0.40 + 0.60*e);
        c *= (0.70 + 0.30*p);
      // Mono scheme: boost enemy grey so it survives dimming pipeline
      } else if(u_dualColors == 4){
        c = mix(c*0.75, c*1.40, 0.40 + 0.60*e);
        c *= (0.65 + 0.35*p);
      } else {
        c = mix(c*0.55, c, 0.35 + 0.65*e);
        c *= (0.55 + 0.45*p);
      }
      if(v_gyron > 0.5) c = mix(c, vec3(1.0), 0.30);

      float alpha = 0.20 * u_scale * u_scale * u_alphaMul;
      if(u_dualColors == 1) alpha *= 1.6; // CRT phosphor glow
      if(u_dualColors == 4) alpha *= 1.8; // mono needs extra visibility
      if(u_exactIFS == 1) alpha = 0.012 * u_alphaMul;
      o_col = vec4(c, clamp(alpha, 0.001, 0.50));
      return;
    }

    bool vivid = (u_palette >= 6);

    if(!vivid){
      // palety 0-5: beze zmeny
      int z = int(v_z + 0.5);
      vec3 c = pal(z, u_palette);
      c = mix(c*0.55, c, e);
      if(v_gyron > 0.5) c = mix(c, vec3(1.0, 0.75, 0.95), 0.45);
      float alpha = 0.14 * u_scale * u_scale * u_alphaMul;
      if(u_exactIFS == 1){
        if(v_gyron > 0.5) c = pal(int(v_z + 0.5), u_palette);
        alpha = 0.008 * u_alphaMul;
        if(v_gyron > 0.5) c = mix(c, vec3(1.0, 0.75, 0.95), 0.45);
        o_col = vec4(c, clamp(alpha, 0.001, 0.1));
      } else {
        o_col = vec4(c, clamp(alpha, 0.001, 0.20));
      }
      return;
    }

    // palety 6-8: barva z nabojoveho pole
    // v_charge: -1 (zaporny) .. 0 (neutralni) .. +1 (kladny)
    float q = clamp(v_charge, -1.0, 1.0);

    vec3 warm, cool, neutral;
    if(u_palette == 6){
      warm    = vec3(1.00, 0.08, 0.30);
      cool    = vec3(0.10, 0.40, 1.00);
      neutral = vec3(0.0, 1.00, 0.35);
    } else if(u_palette == 7){
      warm    = vec3(1.00, 0.0, 0.75);
      cool    = vec3(0.0, 0.85, 1.00);
      neutral = vec3(0.85, 1.00, 0.0);
    } else if(u_palette == 8){
      warm    = vec3(1.00, 0.0, 0.0);
      cool    = vec3(0.0, 0.0, 1.00);
      neutral = vec3(0.0, 1.00, 0.0);
    } else if(u_palette == 9){
      // ohen: zluta (kladny) -> oranzova (neutral) -> tmava cervena/dym (zaporny)
      warm    = vec3(1.00, 0.95, 0.20);
      cool    = vec3(0.18, 0.06, 0.03);
      neutral = vec3(0.95, 0.35, 0.05);
    } else {
      // ocean: bila pena (kladny) -> tyrkys (neutral) -> hluboka tma (zaporny)
      warm    = vec3(0.85, 0.95, 1.00);
      cool    = vec3(0.01, 0.03, 0.12);
      neutral = vec3(0.05, 0.35, 0.55);
    }

    vec3 c = (q > 0.0) ? mix(neutral, warm, q) : mix(neutral, cool, -q);

    float alpha = 0.35 * u_scale * u_scale * u_alphaMul;
    if(u_exactIFS == 1) alpha = 0.02 * u_alphaMul;
    o_col = vec4(c, clamp(alpha, 0.001, 0.50));
  }`;

  // =========================
  // Programs
  // =========================
  const progInit      = program(VS_QUAD, FS_INIT);
  const progPhys      = program(VS_QUAD, FS_PHYS);
  const progPts       = program(VS_POINTS, FS_POINTS);
  const progFade      = program(VS_QUAD, FS_FADE);
  const progBlit      = program(VS_QUAD, FS_BLIT);
  const progFieldFade = program(VS_QUAD, FS_FIELD_FADE);
  const progFieldDep  = program(VS_POINTS_FIELD, FS_FIELD_DEPOSIT);
  const progZoneCount = program(VS_ZONE_COUNT, FS_ZONE_COUNT);
  const progBlur      = program(VS_QUAD, FS_BLUR);
  const progFieldReact= program(VS_QUAD, FS_FIELD_REACT);
  const progTotalCount= program(VS_TOTAL_COUNT, FS_TOTAL_COUNT);

  // =========================
  // VAO
  // =========================
  const vaoQuad = gl.createVertexArray();
  gl.bindVertexArray(vaoQuad);
  const quadBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  const vaoEmpty = gl.createVertexArray();

  // =========================
  // Particle textures (ping-pong)
  // =========================
  const IFMT = gl.RGBA16F;
  const FMT  = gl.RGBA;
  const TYPE = gl.HALF_FLOAT;

  const stateTex = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];
  const k0Tex    = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];
  const k1Tex    = [tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST),
                    tex2D(TEX_SIZE, TEX_SIZE, IFMT, FMT, TYPE, gl.NEAREST)];

  const fboPart = [
    fboMRT([stateTex[0], k0Tex[0], k1Tex[0]]),
    fboMRT([stateTex[1], k0Tex[1], k1Tex[1]])
  ];

  // =========================
  // Field (RGBA16F) + blur
  // =========================
  const fieldTex  = [tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR),
                     tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR)];
  const fieldBlur = [tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR),
                     tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR)];
  const fieldTemp = tex2D(FIELD_SIZE, FIELD_SIZE, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);

  const fboField = [fboMRT([fieldTex[0]]), fboMRT([fieldTex[1]])];

  // 1x1 counter target for robust zone presence (counts BLUE/PINK particles in zone)
  const zoneCountTex = tex2D(1, 1, gl.RGBA32F, gl.RGBA, gl.FLOAT, gl.NEAREST);
  const fboZoneCount = fboMRT([zoneCountTex]);
  const totalCountTex = tex2D(1, 1, gl.RGBA32F, gl.RGBA, gl.FLOAT, gl.NEAREST);
  const fboTotalCount = fboMRT([totalCountTex]);
  const fboBlur  = [fboMRT([fieldBlur[0]]), fboMRT([fieldBlur[1]])];
  const fboTemp  = fboMRT([fieldTemp]);

  function clearFBO(f, w, h, alpha=1){
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    gl.viewport(0,0,w,h);
    gl.clearColor(0,0,0,alpha);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  function clearField(){
    clearFBO(fboField[0], FIELD_SIZE, FIELD_SIZE, 0);
    clearFBO(fboField[1], FIELD_SIZE, FIELD_SIZE, 0);
    clearFBO(fboBlur[0],  FIELD_SIZE, FIELD_SIZE, 0);
    clearFBO(fboBlur[1],  FIELD_SIZE, FIELD_SIZE, 0);
    clearFBO(fboTemp,     FIELD_SIZE, FIELD_SIZE, 0);
  }
  function clearTrail(){
    if(trailFbo[0]) clearFBO(trailFbo[0], viewW, viewH);
    if(trailFbo[1]) clearFBO(trailFbo[1], viewW, viewH);
  }

  // =========================
  // Trail (ping-pong)
  // =========================
  let trailTex = [null, null];
  let trailFbo = [null, null];
  let trailFlip = 0;

  function makeTrailTargets(w,h){
    if(trailTex[0]){ gl.deleteTexture(trailTex[0]); gl.deleteTexture(trailTex[1]); }
    if(trailFbo[0]){ gl.deleteFramebuffer(trailFbo[0]); gl.deleteFramebuffer(trailFbo[1]); }

    trailTex[0] = tex2D(w, h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);
    trailTex[1] = tex2D(w, h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);
    trailFbo[0] = fboMRT([trailTex[0]]);
    trailFbo[1] = fboMRT([trailTex[1]]);

    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[0]);
    gl.viewport(0,0,w,h);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[1]);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  // =========================
  // Uniforms (cache)
  // =========================
  const uInit = { seed: U(progInit, 'u_seed'), dualOn: U(progInit, 'u_dualOn'), initBalance: U(progInit, 'u_initBalance') };

  const uPhys = {
    state: U(progPhys,'u_state'), k0: U(progPhys,'u_k0'), k1: U(progPhys,'u_k1'),
    field: U(progPhys,'u_field'), fieldRaw: U(progPhys,'u_fieldRaw'),
    fieldTexel: U(progPhys,'u_fieldTexel'),
    tm: U(progPhys,'u_tm'), frame: U(progPhys,'u_frame'),
    kernelOn: U(progPhys,'u_kernelOn'), fieldOn: U(progPhys,'u_fieldOn'),
    reactOn: U(progPhys,'u_reactOn'),
    react: U(progPhys,'u_react'),
    mouseOn: U(progPhys,'u_mouseOn'), chaosOn: U(progPhys,'u_chaosOn'),
    pumpOn: U(progPhys,'u_pumpOn'), exactIFS: U(progPhys,'u_exactIFS'),
    dualOn: U(progPhys,'u_dualOn'), dualRate: U(progPhys,'u_dualRate'), dualEq: U(progPhys,'u_dualEq'), dualCoh: U(progPhys,'u_dualCoh'),
    eatMulBlue: U(progPhys,'u_eatMulBlue'), eatMulPink: U(progPhys,'u_eatMulPink'),
    energyTransfer: U(progPhys,'u_energyTransfer'),
    reinfOn: U(progPhys,'u_reinfOn'),
    reinfProb: U(progPhys,'u_reinfProb'),
    reinfSide: U(progPhys,'u_reinfSide'),
    reinfSeed: U(progPhys,'u_reinfSeed'),
    reinfDir: U(progPhys,'u_reinfDir'),
    reinfSpeed: U(progPhys,'u_reinfSpeed'),
    reinfSpread: U(progPhys,'u_reinfSpread'),
    reinfMulBlue: U(progPhys,'u_reinfMulBlue'),
    reinfMulPink: U(progPhys,'u_reinfMulPink'),
    grav: U(progPhys,'u_grav'), pump: U(progPhys,'u_pump'),
    charge: U(progPhys,'u_charge'), pressure: U(progPhys,'u_pressure'),
    mouse: U(progPhys,'u_mouse'), mouseDown: U(progPhys,'u_mouseDown'),
    mouseSign: U(progPhys,'u_mouseSign'),
    damping: U(progPhys,'u_damping'), force: U(progPhys,'u_force'),
    chaos: U(progPhys,'u_chaos'), bounds: U(progPhys,'u_bounds'),
    J: U(progPhys,'u_J'), ck0: U(progPhys,'u_ck[0]'),
    timeK: U(progPhys,'u_timeK'), timeMin: U(progPhys,'u_timeMin'),
    tempo: U(progPhys,'u_tempo'),
    vortex: U(progPhys,'u_vortex'),
    kick: U(progPhys,'u_kick'),
  };

  const uPts = {
    state: U(progPts,'u_state'), k0: U(progPts,'u_k0'), k1: U(progPts,'u_k1'),
    aspect: U(progPts,'u_aspect'), scale: U(progPts,'u_scale'),
    rot: U(progPts,'u_rot'), pan: U(progPts,'u_pan'),
    tm: U(progPts,'u_tm'), frame: U(progPts,'u_frame'),
    kernelOn: U(progPts,'u_kernelOn'), alphaMul: U(progPts,'u_alphaMul'),
    exactIFS: U(progPts,'u_exactIFS'),
    palette: U(progPts,'u_palette'),
    fieldBlur: U(progPts,'u_fieldBlur'),
    bounds: U(progPts,'u_bounds'),
    dualOn: U(progPts,'u_dualOn'),
    dualColors: U(progPts,'u_dualColors'),
  };

  const uFade = { prev: U(progFade,'u_prev'), fade: U(progFade,'u_fade') };
  const uBlit = {
    tex: U(progBlit,'u_tex'), palette: U(progBlit,'u_palette'),
    zoneShow: U(progBlit,'u_zoneShow'), zone: U(progBlit,'u_zone'),
    zoneDanger: U(progBlit,'u_zoneDanger'),
    zoneMode: U(progBlit,'u_zoneMode'),
    time: U(progBlit,'u_time'),
    viewScale: U(progBlit,'u_viewScale'), cs: U(progBlit,'u_cs'), sn: U(progBlit,'u_sn'),
    pan: U(progBlit,'u_pan'), aspect: U(progBlit,'u_aspect'),
  };
  const uFieldFade = { prev: U(progFieldFade,'u_prev'), fade: U(progFieldFade,'u_fade') };

  const uFieldDep = {
    state: U(progFieldDep,'u_state'), k0: U(progFieldDep,'u_k0'), k1: U(progFieldDep,'u_k1'),
    bounds: U(progFieldDep,'u_bounds'), tm: U(progFieldDep,'u_tm'),
    frame: U(progFieldDep,'u_frame'), kernelOn: U(progFieldDep,'u_kernelOn'),
    dualOn: U(progFieldDep,'u_dualOn'),
    dualEq: U(progFieldDep,'u_dualEq'),
    deposit: U(progFieldDep,'u_deposit'),
  };

  const uBlur = { tex: U(progBlur,'u_tex'), dir: U(progBlur,'u_dir') };
  const uFieldReact = {
    prev:     U(progFieldReact,'u_prev'),
    texel:    U(progFieldReact,'u_texel'),
    charge:   U(progFieldReact,'u_charge'),
    pressure: U(progFieldReact,'u_pressure'),
    react:    U(progFieldReact,'u_react'),
    reactOn:  U(progFieldReact,'u_reactOn'),
    dualOn:   U(progFieldReact,'u_dualOn'),
    dualRate: U(progFieldReact,'u_dualRate'),
    dualEq:   U(progFieldReact,'u_dualEq'),
    dualCoh:  U(progFieldReact,'u_dualCoh'),
    eatMulBlue: U(progFieldReact,'u_eatMulBlue'),
    eatMulPink: U(progFieldReact,'u_eatMulPink'),
    energyTransfer: U(progFieldReact,'u_energyTransfer'),
  };

  // =========================
  // TWIST constants (IFS)
  // =========================
  const angJ = 4*Math.PI/5;
  const Jre = 1 + Math.cos(angJ);
  const Jim = Math.sin(angJ);

  const oneMinusJ = { re: (1 - Jre), im: (0 - Jim) };
  const CK = new Float32Array(10);
  for(let k=0;k<5;k++){
    const a = 2*Math.PI*k/5;
    const wre = Math.cos(a), wim = Math.sin(a);
    const cre = oneMinusJ.re*wre - oneMinusJ.im*wim;
    const cim = oneMinusJ.re*wim + oneMinusJ.im*wre;
    CK[2*k+0] = cre;
    CK[2*k+1] = cim;
  }

  // =========================
  // Resize
  // =========================
  let viewW=0, viewH=0, dpr=1;
  function resize(){
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width  * dpr));
    const h = Math.max(2, Math.floor(rect.height * dpr));
    if(w===viewW && h===viewH) return;
    viewW=w; viewH=h;
    canvas.width = w;
    canvas.height = h;
    makeTrailTargets(w,h);
  }
  window.addEventListener('resize', resize);

  let needLayout = true;
  function layout(){
    const topH = document.body.classList.contains('ui-hidden') ? 0 : 44;
    canvas.style.height = (window.innerHeight - topH) + "px";
    canvas.style.width = "100%";
    resize();
    needLayout = false;
  }
  window.addEventListener('resize', () => { needLayout = true; });
  layout();

  // =========================
  // Mouse
  // =========================
  let mouseNX = 0, mouseNY = 0;
  let mx=0, my=0, mDown=0;
  let invertHold = false;
  let viewRot = 0.0;
  let panX = 0, panY = 0;
  let prevScale = parseFloat(ui.scale.value);
  let isPanning = false;
  let panStartNX = 0, panStartNY = 0;
  let panStartX = 0, panStartY = 0;
  let usingTouch = false;  // blokuj mys behem dotyku

  function updateMouse(e){
    if(usingTouch) return;
    const rect = canvas.getBoundingClientRect();
    const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const ny = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    if(isPanning){
      panX = panStartX + (nx - panStartNX);
      panY = panStartY + (ny - panStartNY);
      return;
    }
    mouseNX = nx;
    mouseNY = ny;
  }
  window.addEventListener('mousemove', updateMouse);

  window.addEventListener('mousedown', (e) => {
    if(usingTouch) return;
    if(e.target !== canvas) return;
    if(e.shiftKey){
      isPanning = true;
      const rect = canvas.getBoundingClientRect();
      panStartNX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      panStartNY = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      panStartX = panX;
      panStartY = panY;
    } else {
      mDown = 1;
    }
  });
  window.addEventListener('mouseup', ()=>{ if(!usingTouch){ mDown=0; isPanning=false; } });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dy = e.deltaY;

    if (e.shiftKey) {
      viewRot += dy * 0.0025;
      if (viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if (viewRot < -Math.PI) viewRot += 2 * Math.PI;
      return;
    }

    const min = parseFloat(ui.scale.min);
    const max = parseFloat(ui.scale.max);
    const s   = parseFloat(ui.scale.value);
    const factor = Math.exp(-dy * 0.001);
    let ns = Math.min(max, Math.max(min, s * factor));

    // zoom smerem ke kurzoru: bod pod kurzorem zustane na miste
    const rect = canvas.getBoundingClientRect();
    const cx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const cy = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    const r = ns / s;
    panX = cx * (1 - r) + panX * r;
    panY = cy * (1 - r) + panY * r;
    prevScale = ns;

    ui.scale.value = ns.toFixed(2);
  }, { passive: false });

  // =========================
  // Touch
  // =========================
  let touchCount = 0;
  let prevPinchDist = 0;
  let prevPinchAngle = 0;
  let prevTouchCX = 0, prevTouchCY = 0;

  function touchCenter(t0, t1){
    return { x: (t0.clientX + t1.clientX) / 2, y: (t0.clientY + t1.clientY) / 2 };
  }
  function touchDist(t0, t1){
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }
  function touchAngle(t0, t1){
    return Math.atan2(t1.clientY - t0.clientY, t1.clientX - t0.clientX);
  }
  function touchToNorm(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    mouseNX = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouseNY = -(((clientY - rect.top) / rect.height) * 2 - 1);
  }

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    usingTouch = true;
    touchCount = e.touches.length;
    if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
    } else if(touchCount >= 2){
      mDown = 0;
      prevPinchDist = touchDist(e.touches[0], e.touches[1]);
      prevPinchAngle = touchAngle(e.touches[0], e.touches[1]);
      const c = touchCenter(e.touches[0], e.touches[1]);
      prevTouchCX = c.x;
      prevTouchCY = c.y;
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    touchCount = e.touches.length;
    if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
    } else if(touchCount >= 2){
      mDown = 0;
      const dist = touchDist(e.touches[0], e.touches[1]);
      const angle = touchAngle(e.touches[0], e.touches[1]);
      const center = touchCenter(e.touches[0], e.touches[1]);

      if(prevPinchDist > 0){
        const oldS = parseFloat(ui.scale.value);
        const ratio = dist / prevPinchDist;
        const min = parseFloat(ui.scale.min);
        const max = parseFloat(ui.scale.max);
        let ns = Math.min(max, Math.max(min, oldS * ratio));
        ui.scale.value = ns.toFixed(2);

        // zoom smerem ke stredu pinche
        const rect = canvas.getBoundingClientRect();
        const cx = ((center.x - rect.left) / rect.width) * 2 - 1;
        const cy = -(((center.y - rect.top) / rect.height) * 2 - 1);
        const r = ns / oldS;
        panX = cx * (1 - r) + panX * r;
        panY = cy * (1 - r) + panY * r;
        prevScale = ns;
      }

      let da = angle - prevPinchAngle;
      if(da > Math.PI) da -= 2 * Math.PI;
      if(da < -Math.PI) da += 2 * Math.PI;
      viewRot -= da;
      if(viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if(viewRot < -Math.PI) viewRot += 2 * Math.PI;

      const rect = canvas.getBoundingClientRect();
      const dx = (center.x - prevTouchCX) / rect.width * 2;
      const dy = -(center.y - prevTouchCY) / rect.height * 2;
      panX += dx;
      panY += dy;

      prevPinchDist = dist;
      prevPinchAngle = angle;
      prevTouchCX = center.x;
      prevTouchCY = center.y;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchCount = e.touches.length;
    if(touchCount === 0){
      mDown = 0;
    } else if(touchCount === 1){
      touchToNorm(e.touches[0].clientX, e.touches[0].clientY);
      mDown = 1;
      prevPinchDist = 0;
    }
  }, { passive: false });

  canvas.addEventListener('touchcancel', () => {
    mDown = 0;
    touchCount = 0;
    prevPinchDist = 0;
  });

  // =========================
  // TM bit
  // =========================
  function popcount32(v){
    v = v - ((v >>> 1) & 0x55555555);
    v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
    return (((v + (v >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
  }
  function thueMorse32(v){ return popcount32(v>>>0) & 1; }

  // =========================
  // Reset / pause
  // =========================
  let seed = (Math.random()*1e9)>>>0;
  let frame = 0;
  let partFlip = 0;
  let fieldFlip = 0;
  let paused = false;
  let prevFieldOn = true;
  let kickFrames = 0;

  let prevExact = false;
  let savedScale = null;

  function reset(){
    seed = (Math.random()*1e9)>>>0;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[0]);
    gl.viewport(0,0,TEX_SIZE,TEX_SIZE);
    gl.useProgram(progInit);
    gl.uniform1ui(uInit.seed, seed);
    gl.uniform1i(uInit.dualOn, game.dualOn ? 1 : 0);
    gl.uniform1f(uInit.initBalance, game.initBalance);
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // pole zachovat: nove castice se okamzite chyti existujicich gradientu
    makeTrailTargets(viewW, viewH);

    partFlip = 0;
    // fieldFlip zachovan: pole bezi dal
    trailFlip = 0;
    frame = 0;
    viewRot = 0.0;
    panX = 0; panY = 0;
    prevScale = parseFloat(ui.scale.value);
    ui.spin.value = '0.000';
  }


  // Game-safe reset: re-seed particles ONLY (no trail realloc, no UI side effects).
  function resetParticlesOnly(){
    seed = (Math.random()*1e9)>>>0;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[0]);
    gl.viewport(0,0,TEX_SIZE,TEX_SIZE);
    gl.useProgram(progInit);
    gl.uniform1ui(uInit.seed, seed);
    gl.uniform1i(uInit.dualOn, game.dualOn ? 1 : 0);
    gl.uniform1f(uInit.initBalance, game.initBalance);
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    // Ensure init pass is complete before game logic starts reading counts.
    gl.finish();

    partFlip = 0;
    frame = 0;
    kickFrames = 0;
  }


  // VÃCHOZÃ: reset sliders to defaults + reset simulation
  const DEFAULTS = {
    tglKernel: true, tglField: true, tglMouse: true, tglChaos: true, tglPump: true, tglReact: false, tglExact: false,
    mouseRepel: false,
    particles: '19', damping: '0.677', force: '0.3', chaos: '1.86',
    fade: '0.69', scale: '0.65', spin: '0.000', tempo: '1.00', palette: '1',
    ffield: '0.929', deposit: '3', grav: '1', pressure: '1.93',
    timeK: '38', timeMin: '0.07', charge: '5', vortex: '0.00', pump: '0.099',
    react: '1.00',
  };

  function restoreDefaults(){
    ui.tglKernel.checked = DEFAULTS.tglKernel;
    ui.tglField.checked  = DEFAULTS.tglField;
    ui.tglMouse.checked  = DEFAULTS.tglMouse;
    ui.tglChaos.checked  = DEFAULTS.tglChaos;
    ui.tglPump.checked   = DEFAULTS.tglPump;
    ui.tglReact.checked  = DEFAULTS.tglReact;
    ui.tglExact.checked  = DEFAULTS.tglExact;
    if(DEFAULTS.mouseRepel) ui.mouseRepel.checked = true;
    else ui.mouseAttract.checked = true;

    for(const [k, v] of Object.entries(DEFAULTS)){
      if(ui[k] && ui[k].type === 'range') ui[k].value = v;
    }
    syncUI();
    clearField();
    fieldFlip = 0;
    reset();
  }

  document.getElementById('reset').addEventListener('click', reset);
  document.getElementById('defaults').addEventListener('click', restoreDefaults);
  document.getElementById('pause').addEventListener('click', ()=>{
    paused = !paused;
    document.getElementById('pause').innerHTML = paused ? "RESUME <small>(ESC)</small>" : "PAUSE <small>(ESC)</small>";
    if(paused) setInvert(false);
  });

  ui.spin.addEventListener('dblclick', () => { ui.spin.value = '0.000'; });
  ui.tempo.addEventListener('dblclick', () => { ui.tempo.value = '1.00'; });
  ui.vortex.addEventListener('dblclick', () => { ui.vortex.value = '0.00'; });

  // =========================
  // GAME
  // =========================
  // game functions (game object defined above with gameUI)

  function gameLockUI(locked){
    gameUI.modeEmpty.disabled = locked;
    gameUI.modeNotEmpty.disabled = locked;
    gameUI.x.disabled = locked;
    gameUI.y.disabled = locked;
    gameUI.size.disabled = locked;
    gameUI.thresh.disabled = locked;
    gameUI.coverage.disabled = locked;
    gameUI.grace.disabled = locked;
    if(gameUI.winArea) gameUI.winArea.disabled = locked;
    if(gameUI.winPresence) gameUI.winPresence.disabled = locked;
    if(gameUI.dualOn) gameUI.dualOn.disabled = locked;
    if(gameUI.dualRate) gameUI.dualRate.disabled = locked;
    if(gameUI.dualEq) gameUI.dualEq.disabled = locked;
    if(gameUI.dualCoh) gameUI.dualCoh.disabled = locked;
    if(gameUI.initBalance) gameUI.initBalance.disabled = locked;
    gameUI.start.disabled = locked;
    gameUI.stop.disabled = !locked;
  }

  function gameResetRun(){
    // NEW RUN / TRY AGAIN: start from scratch, robustly.
    // Avoid reallocating big GPU targets here (can stall/crash on some drivers).
    // 1) ensure canvas & trail targets are valid
    layout();
    // 2) reset particles only (new seed)
    resetParticlesOnly();
    // 3) wipe field & trail
    clearField(); fieldFlip = 0;
    clearTrail(); trailFlip = 0;
    // 4) ensure trail targets exist at current size (without leaking)
    // 4) do NOT recreate large trail targets here (can stall on some drivers)
    // If targets are missing (first run), create once.
    if(!trailTex || !trailTex[0]){
      makeTrailTargets(viewW, viewH);
    }
  }

  function gameStart(){
    gameReadUI();
    if(!game.enabled) return;
    gameResetRun();
    paused = false;
    game.running = true;
    game.over = false;
    game.time = 0;
    game.tDanger = 0;
    game.winHold = 0;
    game.blueHold = 0;
    game.lastT = performance.now();
    lastCheckT = 0;
    gameLockUI(true);
    gameUI.status.textContent = 'RUNNING';
    gameUI.status.style.color = '#0f0';
    gameUI.overlay.style.display = 'none';
    gameUI.overlay.classList.remove('game-ended');
    gameUI.startScreen.style.display = 'none';
    gameUI.endScreen.style.display = 'none';
    if(game.locked){
      glStatus.textContent = 'RUNNING';
      glStatus.style.color = '#0a0';
      glTime.textContent = '0.0s';
      glFill.textContent = '0%';
    }
  }

  function gameStop(){
    game.running = false;
    paused = false;
    gameLockUI(false);
    gameUI.status.textContent = game.over ? 'GAME OVER' : 'STOPPED';
    gameUI.status.style.color = game.over ? '#f44' : '#666';
    if(game.locked){
      glStatus.textContent = game.over ? 'GAME OVER' : 'STOPPED';
      glStatus.style.color = game.over ? '#f44' : '#666';
    }
  }

  
  function setGameOverStats(kind){
    const el = document.getElementById('gameOverStats');
    if(!el) return;
    const S = game.lastStats;
    if(!S){ el.textContent = ''; return; }
    if(S.mode === 'DUAL'){
      const lines = [];
      lines.push(`RESULT: ${kind}`);
      lines.push(`ENEMY PRES: ${S.pinkPresent ? 'YES' : 'NO'}   zone_gpu=${(S.pinkZoneCount||0).toFixed(0)} total_gpu=${(S.pinkTotalCount||0).toFixed(0)} field_px=${S.pinkPresCount||0}`);
      lines.push(`FRIENDLY TOTAL: ${(S.blueTotalCount||0).toFixed(0)}`);
      lines.push(`FRIENDLY: ${(S.blueTotalCount||0).toFixed(0)} total   ${(S.blueZoneCount||0).toFixed(0)} in zone`);
      if(S.winArea) lines.push(`ENEMY AREA: ${S.pinkPct}%   limit ${(S.covMax*100).toFixed(1)}%`);
      const conds = [];
      if(S.winArea) conds.push('AREA');
      if(S.winPresence) conds.push('PRESENCE');
      lines.push(`WIN CONDITIONS: ${conds.length ? conds.join(' + ') : 'NONE'}`);
      lines.push(`HOLD: win ${(S.winHold||0).toFixed(2)}s / ${S.grace.toFixed(2)}s   lose ${(S.blueHold||0).toFixed(2)}s / ${S.grace.toFixed(2)}s`);
      el.textContent = lines.join('\n');
    } else {
      el.textContent = '';
    }
  }

function gameOver(){
    game.over = true;
    game.running = false;
    paused = true;
    gameLockUI(false);
    gameUI.status.textContent = 'GAME OVER';
    gameUI.status.style.color = '#f44';
    gameUI.overTitle.textContent = 'GAME OVER';
    gameUI.overTitle.style.color = '#f44';
    setGameOverStats('LOSE');
    showGameEndScreen();
    if(game.locked){
      glStatus.textContent = 'GAME OVER';
      glStatus.style.color = '#f44';
    }
  }

  function gameWin(){
    game.over = true;
    game.running = false;
    paused = true;
    gameLockUI(false);
    gameUI.status.textContent = 'YOU WIN';
    gameUI.status.style.color = '#0a0';
    gameUI.overTitle.textContent = 'YOU WIN';
    gameUI.overTitle.style.color = '#0a0';
    setGameOverStats('WIN');
    showGameEndScreen();
    if(game.locked){
      glStatus.textContent = 'YOU WIN';
      glStatus.style.color = '#0a0';
    }
  }


  // field sampling: read occupancy of zone from field texture
  function gameSampleField(chanOverride){
    const bounds = 2.2;
    const x0 = Math.max(0, Math.floor(((game.cx - game.half) / bounds * 0.5 + 0.5) * FIELD_SIZE));
    const y0 = Math.max(0, Math.floor(((game.cy - game.half) / bounds * 0.5 + 0.5) * FIELD_SIZE));
    const x1 = Math.min(FIELD_SIZE, Math.ceil(((game.cx + game.half) / bounds * 0.5 + 0.5) * FIELD_SIZE));
    const y1 = Math.min(FIELD_SIZE, Math.ceil(((game.cy + game.half) / bounds * 0.5 + 0.5) * FIELD_SIZE));
    const w = x1 - x0;
    const h = y1 - y0;
    if(w < 1 || h < 1) return {fill:0, count:0, area:0};
    const buf = new Float32Array(w * h * 4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboField[fieldFlip]);
    gl.readPixels(x0, y0, w, h, gl.RGBA, gl.FLOAT, buf);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    let sum = 0;
    let sumPres = 0;
    let maxv = 0;
    const area = w * h;
    // Zone metric:
    // - default: MASS in R channel (original simulator)
    // - DUALITY on: channels mean BLUE=G(1), PINK=B(2)
    const presThr = Math.min(0.001, game.threshold * 0.10);

    const chan = (chanOverride !== undefined)
      ? chanOverride
      : (game.dualOn ? (game.modeEmpty ? 2 : 1) : 0);


    for(let i = 0; i < area; i++){
      const v = buf[i * 4 + chan];
      if(v > maxv) maxv = v;
      if(v > presThr) sumPres++;
      if(v > game.threshold) sum++;
    }
    return {fill: (sum / area), count: sum, presCount: sumPres, area: area, max: maxv, presThr: presThr};
  }


  // Robust presence: count BLUE/PINK particles inside the zone using GPU 1x1 additive pass.
  // Uses RGBA32F FBOs (max ~3.4e38) to avoid half-float overflow with large particle counts.
  function gameZoneCountParticles(){
    const prevViewport = gl.getParameter(gl.VIEWPORT);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fboZoneCount);
    gl.viewport(0,0,1,1);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE);
    gl.blendEquation(gl.FUNC_ADD);

    gl.useProgram(progZoneCount);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);  gl.uniform1i(U(progZoneCount,'u_state'), 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);     gl.uniform1i(U(progZoneCount,'u_k1'), 1);

    gl.uniform1f(U(progZoneCount,'u_cx'), game.cx);
    gl.uniform1f(U(progZoneCount,'u_cy'), game.cy);
    gl.uniform1f(U(progZoneCount,'u_half'), game.half);

    gl.bindVertexArray(vaoEmpty);
    gl.drawArrays(gl.POINTS, 0, activeN);

    gl.disable(gl.BLEND);

    const pix = new Float32Array(4);
    gl.readPixels(0,0,1,1, gl.RGBA, gl.FLOAT, pix);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    gl.viewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);

    return {blue: pix[0], pink: pix[1], total: pix[2]};
  }

  function gameTotalCountParticles(){
    if(!game.dualOn) return {blue:0, pink:0};

    const prevViewport = gl.getParameter(gl.VIEWPORT);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fboTotalCount);
    gl.viewport(0,0,1,1);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE);
    gl.blendEquation(gl.FUNC_ADD);

    gl.useProgram(progTotalCount);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]); gl.uniform1i(U(progTotalCount,'u_k1'), 0);

    gl.bindVertexArray(vaoEmpty);
    gl.drawArrays(gl.POINTS, 0, activeN);

    gl.disable(gl.BLEND);

    const pix = new Float32Array(4);
    gl.readPixels(0,0,1,1, gl.RGBA, gl.FLOAT, pix);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);

    return {blue: pix[0], pink: pix[1]};
  }

  function gameTick(){
    if(!game.running || game.over || paused) return;
    const now = performance.now();
    const dt = (now - game.lastT) / 1000;
    game.lastT = now;
    game.time += dt;
    const ts = game.time.toFixed(1) + 's';
    gameUI.timer.textContent = ts;
    if(game.locked) glTime.textContent = ts;
  }

  let lastCheckT = 0;

  function gameCheck(){
    if(!game.running || game.over) return;
    const now = performance.now();
    const dt = lastCheckT > 0 ? (now - lastCheckT) / 1000 : 0.016;
    lastCheckT = now;

    // Warmup: don't check win/lose for first 3 seconds (let field build up)
    const WARMUP = 3.0;
    const warming = (game.time < WARMUP);

    // In DUALITY mode: zone checks ENEMY only, lose checks FRIENDLY across whole sim
    if(game.dualOn){
      const pink = gameSampleField(2);  // field-based: zone ENEMY density
      const zc = gameZoneCountParticles();  // GPU particle count in zone
      const tc = gameTotalCountParticles(); // GPU particle count total

      const pinkFill = pink.fill;
      const pinkPct = (pinkFill * 100).toFixed(1);

      // === ENEMY PRESENCE IN ZONE ===
      const pinkPresent_gpu = (zc.pink > 0.5);
      const pinkPresent_field = (pink.presCount > 2);
      const pinkPresent = pinkPresent_gpu || pinkPresent_field;

      // Total enemy anywhere in sim
      const pinkTotal_gpu = (tc.pink > 2.0);

      // === FRIENDLY: check TOTAL sim only (zone is irrelevant for friendly) ===
      const blueAny = (tc.blue > 2.0);

      game.lastStats = {
        mode:'DUAL',
        pinkPct: pinkPct,
        pinkPresent: pinkPresent,
        pinkFill: pinkFill,
        pinkPresCount: pink.presCount,
        pinkZoneCount: zc.pink,
        blueTotalCount: tc.blue,
        pinkTotalCount: tc.pink,
        pinkTotalPresent: pinkTotal_gpu,
        winArea: game.winArea,
        winPresence: game.winPresence,
        covMax: game.coverageMax,
        grace: game.grace,
        winHold: game.winHold,
        blueHold: game.blueHold,
      };

      // Lose condition: no FRIENDLY left anywhere (skip during warmup)
      if(!blueAny && !warming){
        game.blueHold += dt;
        // slow down win progress but don't hard reset (counter noise protection)
        game.winHold = Math.max(0, game.winHold - dt * 0.5);
        const progL = Math.max(0, Math.min(1, game.blueHold / Math.max(game.grace, 0.01)));
        gameUI.status.textContent = `NO FRIENDLY ${(progL*100).toFixed(0)}%`;
        gameUI.status.style.color = '#f44';
        if(game.locked){
          glStatus.textContent = gameUI.status.textContent;
          glStatus.style.color = '#f44';
        }
        if(game.blueHold >= game.grace){
          gameOver();
        }
        return;
      } else {
        // fast decay: recover quickly from brief counter glitches
        game.blueHold = Math.max(0, game.blueHold - dt * 3.0);
      }


      // HUD
      gameUI.fill.textContent = 'ENEMY ' + pinkPct + '%';
      if(game.locked) glFill.textContent = 'ENEMY ' + pinkPct + '%';

      if(gameUI.areaStat){
        const want = game.coverageMax;
        const okA = (pinkFill <= want);
        const tag = game.winArea ? '' : ' (off)';
        gameUI.areaStat.textContent = `ENEMY AREA: ${pinkPct}% / ${(want*100).toFixed(1)}%${tag} ${game.winArea ? (okA?'OK':'BAD') : ''}`;
      }
      if(gameUI.presenceStat){
        const tag = game.winPresence ? '' : ' (off)';
        const bh = game.blueHold > 0 ? ` LOSE:${(game.blueHold/Math.max(game.grace,0.01)*100).toFixed(0)}%` : '';
        const epres = pinkPresent ? 'YES' : 'NO';
        const wp = game.winHold > 0 ? ` WIN:${(game.winHold/Math.max(game.grace,0.01)*100).toFixed(0)}%` : '';
        gameUI.presenceStat.textContent = `ENEMY:${epres} z=${zc.pink.toFixed(0)} t=${tc.pink.toFixed(0)} | F=${tc.blue.toFixed(0)}${wp}${bh}${tag}`;
      }

      // Win conditions (AND if both enabled)
      let ok = true;
      if(game.winArea) ok = ok && (pinkFill <= game.coverageMax);
      if(game.winPresence) ok = ok && (!pinkPresent) && (!pinkTotal_gpu);

      // During warmup: show HUD but don't advance win/lose timers
      if(warming){
        const left = (WARMUP - game.time).toFixed(1);
        gameUI.status.textContent = `WARMUP ${left}s`;
        gameUI.status.style.color = '#ff0';
        if(game.locked){
          glStatus.textContent = `WARMUP ${left}s`;
          glStatus.style.color = '#ff0';
        }
        return;
      }

      // LOSE condition: enemy area way above threshold for grace period
      let losing = false;
      if(game.winArea && pinkFill > game.coverageMax){
        losing = true;
        game.tDanger += dt;
      } else {
        game.tDanger = Math.max(0, game.tDanger - dt * 2.0);
      }

      if(game.tDanger >= game.grace){
        gameOver();
        return;
      }

      // progress-to-win uses GRACE seconds as the required continuous hold time
      if(ok){
        game.winHold += dt;
      } else {
        // slow decay: progress accumulates even with occasional counter noise
        game.winHold = Math.max(0, game.winHold - dt * 0.3);
      }

      // show progress in status
      const prog = Math.max(0, Math.min(1, game.winHold / Math.max(game.grace, 0.01)));
      const dangerProg = Math.max(0, Math.min(1, game.tDanger / Math.max(game.grace, 0.01)));
      if(losing){
        gameUI.status.textContent = `LOSING ${(dangerProg*100).toFixed(0)}%`;
        gameUI.status.style.color = '#f44';
      } else {
        gameUI.status.textContent = ok ? `CLEARING ${(prog*100).toFixed(0)}%` : 'CLEAR ENEMY';
        gameUI.status.style.color = ok ? '#0a0' : '#666';
      }
      if(game.locked){
        glStatus.textContent = gameUI.status.textContent;
        glStatus.style.color = gameUI.status.style.color;
      }

      if(game.winHold >= game.grace){
        gameWin();
      }
      return;
    }

    // Non-duality legacy: survive by keeping the zone within limits.
    const samp = gameSampleField();
    const fill = samp.fill;
    const count = samp.count;
    const pct = (fill * 100).toFixed(1);

    // GPU-based zone presence (robust, not affected by field decay)
    const zc = gameZoneCountParticles();
    const gpuPresent = (zc.total > 0.5);
    const fieldPresent = (count > 0);
    const present = gpuPresent || fieldPresent;

    if(gameUI.areaStat){
      const want = game.coverageMax;
      const ok = game.modeEmpty ? (fill <= want) : (fill >= want);
      gameUI.areaStat.textContent = `AREA: ${pct}% / ${(want*100).toFixed(1)}% ${ok?'OK':'BAD'}`;
    }
    if(gameUI.presenceStat){
      const okP = game.modeEmpty ? (!present) : (present);
      gameUI.presenceStat.textContent = `PRES: ${present?'YES':'NO'} gpu=${zc.total.toFixed(0)} fld=${count} ${okP?'OK':'BAD'}`;
    }
    gameUI.fill.textContent = pct + '%';
    if(game.locked) glFill.textContent = pct + '%';

    // During warmup: show HUD but don't check violations
    if(warming){
      const left = (WARMUP - game.time).toFixed(1);
      gameUI.fill.style.color = '#ff0';
      if(game.locked) glFill.style.color = '#ff0';
      return;
    }

    let violated = false;
    if(game.winArea){
      violated = violated || (game.modeEmpty ? (fill > game.coverageMax) : (fill < game.coverageMax));
    }
    if(game.winPresence){
      violated = violated || (game.modeEmpty ? present : !present);
    }

    if(violated){
      game.tDanger += 1/15;
      gameUI.fill.style.color = '#f44';
      if(game.locked) glFill.style.color = '#f44';
      if(game.tDanger >= game.grace){
        gameOver();
      }
    } else {
      game.tDanger = Math.max(0, game.tDanger - 2/15);
      gameUI.fill.style.color = '#666';
      if(game.locked) glFill.style.color = '#666';
    }
  }

  // game panel toggle
  document.getElementById('gameBtn').addEventListener('click', () => {
    const showing = gameWrap.style.display !== 'none';
    gameWrap.style.display = showing ? 'none' : '';
    slidersWrap.style.display = showing ? (slidersVisible ? '' : 'none') : 'none';
  });

  gameUI.back.addEventListener('click', () => {
    gameWrap.style.display = 'none';
    slidersWrap.style.display = slidersVisible ? '' : 'none';
  });

  gameUI.enabled.addEventListener('change', () => {
    gameReadUI();
    if(!game.enabled && game.running) gameStop();
  });
  gameUI.showZone.addEventListener('change', () => { game.showZone = gameUI.showZone.checked; });
  if(gameUI.dualOn){
    gameUI.dualOn.addEventListener('change', () => {
      gameReadUI();
      // Duality uses the field g/b channels for two particle species (PINK/BLUE).
      // Clear the field to avoid mixing with any previous +/- charge content.
      clearField();
      clearTrail();
      syncUI();
    });
  }
  [gameUI.modeEmpty, gameUI.modeNotEmpty, gameUI.x, gameUI.y, gameUI.size,
   gameUI.thresh, gameUI.coverage, gameUI.grace,
   gameUI.winArea, gameUI.winPresence,
   gameUI.dualRate, gameUI.dualEq, gameUI.dualCoh, gameUI.initBalance,
   gameUI.reinfFlow, gameUI.reinfBlue, gameUI.reinfPink, gameUI.colors].filter(Boolean).forEach(el => {
    el.addEventListener('input', gameReadUI);
  });
  if(gameUI.reinfWaves){ gameUI.reinfWaves.addEventListener('change', gameReadUI); }
  if(gameUI.powerEats){ gameUI.powerEats.addEventListener('change', gameReadUI); }
  if(gameUI.energyTransfer){ gameUI.energyTransfer.addEventListener('change', gameReadUI); }


  gameUI.start.addEventListener('click', gameStart);
  gameUI.stop.addEventListener('click', gameStop);
  gameUI.retry.addEventListener('click', () => {
    gameStart();
  });

  gameUI.playBtn.addEventListener('click', () => {
    gameStart();
  });

  function showGameStartScreen(){
    gameUI.startScreen.style.display = '';
    gameUI.endScreen.style.display = 'none';
    gameUI.overlay.classList.remove('game-ended');
    // Set button text based on actual game mode
    if(game.dualOn){
      let objectives = [];
      if(game.winArea) objectives.push('AREA');
      if(game.winPresence) objectives.push('PRESENCE');
      const obj = objectives.length > 0 ? objectives.join(' + ') : 'SURVIVE';
      gameUI.playBtn.textContent = 'ELIMINATE ENEMY (' + obj + ')';
    } else {
      gameUI.playBtn.textContent = game.modeEmpty ? 'DEFEND THE ZONE' : 'FILL THE ZONE';
    }
    gameUI.overlay.style.display = '';
  }

  function showGameEndScreen(){
    gameUI.startScreen.style.display = 'none';
    gameUI.endScreen.style.display = '';
    gameUI.overTime.textContent = game.time.toFixed(1) + 's';
    gameUI.overlay.style.display = '';
    gameUI.overlay.classList.add('game-ended');
  }

  function enterLockedMode(){
    game.locked = true;
    document.body.classList.add('game-locked');
    // read game state from UI (already decoded from URL)
    gameReadUI();
    game.enabled = true;
    gameUI.enabled.checked = true;
    // respect showZone from URL settings (don't force it on)
    game.showZone = gameUI.showZone.checked;
    // ensure field and mouse are on (game needs them)
    ui.tglField.checked = true;
    ui.tglMouse.checked = true;
    syncUI();
    needLayout = true;
    // show start dialogue
    showGameStartScreen();
  }

  document.getElementById('gameLock').addEventListener('click', () => {
    gameReadUI();
    // build locked URL
    let parts = [];
    let tg = '';
    for(const [k, id] of TOGGLE_MAP){
      tg += k + (ui[id].checked ? '1' : '0');
    }
    parts.push(tg);
    parts.push('M' + (ui.mouseAttract.checked ? 'a' : 'r'));
    for(const [k, id] of SLIDER_MAP){
      parts.push(k + ui[id].value);
    }
    // game params
    parts.push('g1');
    parts.push('gs' + (gameUI.showZone.checked ? '1' : '0'));
    parts.push('gm' + (gameUI.modeEmpty.checked ? '0' : '1'));
    parts.push('gx' + gameUI.x.value);
    parts.push('gy' + gameUI.y.value);
    parts.push('gh' + gameUI.size.value);
    parts.push('gt' + gameUI.thresh.value);
    parts.push('gC' + gameUI.coverage.value);
    parts.push('gg' + gameUI.grace.value);
    parts.push('gW' + ((gameUI.winArea && gameUI.winArea.checked) ? '1' : '0') + ((gameUI.winPresence && gameUI.winPresence.checked) ? '1' : '0'));
    if(gameUI.reinfBlue) parts.push('gRb' + gameUI.reinfBlue.value);
    if(gameUI.reinfPink) parts.push('gRp' + gameUI.reinfPink.value);
    if(gameUI.reinfFlow && parseFloat(gameUI.reinfFlow.value) > 0) parts.push('gRf' + gameUI.reinfFlow.value);
    if(gameUI.reinfWaves && gameUI.reinfWaves.checked) parts.push('gRw1');
    if(gameUI.powerEats && gameUI.powerEats.checked) parts.push('gPE1');
    if(gameUI.energyTransfer && !gameUI.energyTransfer.checked) parts.push('gET0');
    if(gameUI.dualOn && gameUI.dualOn.checked){
      parts.push('gd1');
      parts.push('gD' + gameUI.dualRate.value);
      if(gameUI.dualEq) parts.push('gE' + gameUI.dualEq.value);
      if(gameUI.dualCoh) parts.push('gA' + gameUI.dualCoh.value);
      if(gameUI.initBalance && parseFloat(gameUI.initBalance.value) !== 0.5) parts.push('gB' + gameUI.initBalance.value);
      if(gameUI.colors && parseInt(gameUI.colors.value) > 0) parts.push('gCo' + gameUI.colors.value);
    }
    parts.push('gL1');
    if(VRAM_BUDGET > (isDesktop ? 800 : 300)){
      parts.push('vm' + VRAM_BUDGET);
    }
    const hash = parts.join('~');
    // use canonical URL for sharing, current page for local test
    const shareUrl = BASE_URL + '#' + hash;
    const localHash = '#' + hash;

    // copy canonical URL
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(shareUrl).then(() => {
        // apply locally and enter locked mode
        try { history.replaceState(null, '', localHash); } catch(e){}
        enterLockedMode();
        needLayout = true;
      });
    } else {
      prompt('Copy this URL:', shareUrl);
      try { history.replaceState(null, '', localHash); } catch(e){}
      enterLockedMode();
      needLayout = true;
    }
  });

  // =========================
  // Keyboard
  // =========================
  const helpEl = document.getElementById('helpOverlay');

  helpEl.addEventListener('click', (e) => {
    if(e.target === helpEl) helpEl.classList.remove('show');
  });

  function nudge(slider, delta){
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const step = parseFloat(slider.step) || 0.001;
    let v = parseFloat(slider.value) + delta * step;
    v = Math.min(max, Math.max(min, v));
    const dec = (slider.step.split('.')[1] || '').length;
    slider.value = v.toFixed(dec);
  }

  window.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    const k = e.key;
    const S = 5;

    switch(k){
      case 'h': case 'H':
        helpEl.classList.toggle('show');
        break;
      case 'Escape':
        helpEl.classList.remove('show');
        paused = !paused;
        document.getElementById('pause').innerHTML = paused ? 'RESUME <small>(ESC)</small>' : 'PAUSE <small>(ESC)</small>';
        if(paused) setInvert(false);
        break;
      case 'u': case 'U':
        document.body.classList.toggle('ui-hidden');
        // In locked game, also toggle audio button visibility
        if(game.locked){
          const ab = document.getElementById('audioBtn');
          if(ab) ab.classList.toggle('audio-hidden');
        }
        needLayout = true;
        break;
      case 'Tab':
        e.preventDefault();
        togglePanel();
        break;
      case 'c': case 'C':
        shareURL();
        break;
      case ' ':
        e.preventDefault();
        setInvert(true);
        break;
      case 'r': case 'R':
        reset();
        break;
      case 'b': case 'B':
        restoreDefaults();
        break;
      case '1':
        ui.tglKernel.checked = !ui.tglKernel.checked;
        syncUI();
        break;
      case '2':
        ui.tglField.checked = !ui.tglField.checked;
        syncUI();
        break;
      case '3':
        ui.tglMouse.checked = !ui.tglMouse.checked;
        syncUI();
        break;
      case '4':
        ui.tglChaos.checked = !ui.tglChaos.checked;
        syncUI();
        break;
      case '5':
        ui.tglPump.checked = !ui.tglPump.checked;
        syncUI();
        break;
      case '6':
        ui.tglExact.checked = !ui.tglExact.checked;
        syncUI();
        break;
      case '7':
        nudge(ui.palette, -1);
        break;
      case '8':
        nudge(ui.palette, 1);
        break;
      case 'm': case 'M':
        if(ui.mouseRepel.checked) ui.mouseAttract.checked = true;
        else ui.mouseRepel.checked = true;
        syncUI();
        break;
      case 'p':
        nudge(ui.particles, S);
        break;
      case 'P':
        {
          const cur = parseInt(ui.particles.value);
          const curMax = parseInt(ui.particles.max);
          if(cur >= curMax && curMax < MAX_POW){
            ui.particles.max = String(curMax + 1);
            nudge(ui.particles, 1);
          } else if(cur >= curMax && curMax >= MAX_POW){
            console.log('CEILING: N=' + N.toLocaleString() + ' (2^' + MAX_POW + ').' +
              ' Add ~vm2000 (22M), ~vm8000 (87M), or ~vm16000 (175M) to URL, then reload.');
            break;
          } else {
            nudge(ui.particles, 1);
          }
          const pw = parseInt(ui.particles.value);
          const actual = Math.min(N, 2 ** pw);
          console.log('CHEAT: 2^' + pw + ' = ' + actual.toLocaleString() +
            ' / ' + N.toLocaleString() + ' allocated');
        }
        break;
      case 'n':
        nudge(ui.particles, -S);
        break;
      case 'N':
        {
          nudge(ui.particles, -1);
          const cur = parseInt(ui.particles.value);
          const curMax = parseInt(ui.particles.max);
          if(curMax > 24 && cur < curMax){
            ui.particles.max = String(Math.max(24, cur + 1));
          }
        }
        break;
      case '+': case '=':
        nudge(ui.scale, S * 5);
        break;
      case '-': case '_':
        nudge(ui.scale, -S * 5);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        nudge(ui.spin, -S);
        break;
      case 'ArrowRight':
        e.preventDefault();
        nudge(ui.spin, S);
        break;
      case '0':
        if(ui.tglReact.checked){
          nudge(ui.react, S);
        } else {
          viewRot = 0.0;
          panX = 0; panY = 0;
          ui.spin.value = '0.000';
        }
        break;
      case '9':
        nudge(ui.react, -S);
        break;
      case 'ArrowUp':
        e.preventDefault();
        nudge(ui.grav, S);
        break;
      case 'ArrowDown':
        e.preventDefault();
        nudge(ui.grav, -S);
        break;
      case '[':
        nudge(ui.damping, -S);
        break;
      case ']':
        nudge(ui.damping, S);
        break;
      case ';':
        nudge(ui.force, -S);
        break;
      case "'":
        nudge(ui.force, S);
        break;
      case ',':
        nudge(ui.pressure, -S);
        break;
      case '.':
        nudge(ui.pressure, S);
        break;
      case 'q':
        nudge(ui.charge, -S);
        break;
      case 'a':
        nudge(ui.charge, S);
        break;
      case '<':
        nudge(ui.vortex, -S);
        break;
      case '>':
        nudge(ui.vortex, S);
        break;
      case 'w':
        nudge(ui.timeK, -S);
        break;
      case 's':
        nudge(ui.timeK, S);
        break;
      case 'e':
        nudge(ui.timeMin, -S);
        break;
      case 'd':
        nudge(ui.timeMin, S);
        break;
      case 't':
        nudge(ui.pump, -S);
        break;
      case 'g':
        nudge(ui.pump, S);
        break;
      case 'f':
        nudge(ui.deposit, -S);
        break;
      case 'v':
        nudge(ui.deposit, S);
        break;
      case 'z':
        nudge(ui.chaos, -S);
        break;
      case 'x':
        nudge(ui.chaos, S);
        break;
      case 'i':
        nudge(ui.fade, -S);
        break;
      case 'k':
        nudge(ui.fade, S);
        break;
      case 'o':
        nudge(ui.ffield, -S);
        break;
      case 'l':
        nudge(ui.ffield, S);
        break;
      case 'j':
        nudge(ui.tempo, -S);
        break;
      case 'y':
        nudge(ui.tempo, S);
        break;
    }
  });

  window.addEventListener('keyup', (e) => {
    if(e.key === ' '){
      setInvert(false);
    }
  });

  window.addEventListener('blur', () => {
    setInvert(false);
  });

  // =========================
  // Invert button (mobile + visual feedback)
  // =========================
  const invertBtn = document.getElementById('invertBtn');
  const invertHud = document.getElementById('invertHud');
  invertHud.textContent = 'INVERT';

  function setInvert(on){
    invertHold = on;
    invertBtn.classList.toggle('active', on);
    invertHud.classList.toggle('show', on);
  }

  // Mobile: toggle mode (tap on/off). Desktop: hold mode (SPACE key).
  const isMobileInvert = window.matchMedia('(pointer:coarse)').matches;

  // Block touch events on invert button so canvas doesn't see them
  invertBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); }, {passive:false});
  invertBtn.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); }, {passive:false});
  invertBtn.addEventListener('touchmove', (e) => { e.preventDefault(); e.stopPropagation(); }, {passive:false});

  if(isMobileInvert){
    invertBtn.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      setInvert(!invertHold);
    });
    invertBtn.addEventListener('pointerup', (e) => { e.preventDefault(); e.stopPropagation(); });
    invertBtn.addEventListener('pointercancel', (e) => { e.preventDefault(); e.stopPropagation(); });
  } else {
    invertBtn.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      invertBtn.setPointerCapture(e.pointerId);
      setInvert(true);
    });
    invertBtn.addEventListener('pointerup', (e) => {
      e.preventDefault();
      setInvert(false);
    });
    invertBtn.addEventListener('pointercancel', (e) => {
      e.preventDefault();
      setInvert(false);
    });
  }

  // =========================
  // FPS
  // =========================
  let lastT = performance.now(), acc=0, frames=0;

  // start
  reset();

  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.CULL_FACE);

  // =========================
  // Main loop
  // =========================

  // =========================
  // Duality reinforcements (BALANCE slider)
  // =========================
  let reinfFramesLeft = 0;
  let reinfTimer = 0.0;
  let reinfDirX = 1.0, reinfDirY = 0.0;
  let reinfSide = 1; // 0=BLUE, 1=PINK
  let reinfProb = 0.0;
  let reinfSeed = 1 >>> 0;
  let reinfSpeed = 0.05;
  let reinfSpread = 0.02;

  const REINF_SAMPLE_SIZE = 32;
  const reinfBuf = new Float32Array(REINF_SAMPLE_SIZE * REINF_SAMPLE_SIZE * 4);

  function sampleDualDominance(){
    const s = REINF_SAMPLE_SIZE;
    const x0 = (FIELD_SIZE - s) >> 1;
    const y0 = (FIELD_SIZE - s) >> 1;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur[fieldFlip]);
    gl.readPixels(x0, y0, s, s, gl.RGBA, gl.FLOAT, reinfBuf);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    let sumG = 0, sumB = 0;
    const n = s * s;
    for(let i=0;i<n;i++){
      sumG += reinfBuf[i*4 + 1];
      sumB += reinfBuf[i*4 + 2];
    }
    const den = sumG + sumB + 1e-9;
    return (sumG - sumB) / den; // -1..+1 (pink..blue)
  }

  function startReinforcement(balance, activeN){
    // decide which side gets reinforcements: the weaker one (by field dominance)
    let dom = 0.0;
    try { dom = sampleDualDominance(); } catch(e){ dom = 0.0; }
    const absDom = Math.abs(dom);

    if(absDom < 0.02){
      reinfSide = (Math.random() < 0.5) ? 0 : 1;
    } else {
      reinfSide = (dom > 0.0) ? 1 : 0; // blue dominates => reinforce pink
    }

    // random inward direction
    const ang = Math.random() * Math.PI * 2;
    reinfDirX = Math.cos(ang);
    reinfDirY = Math.sin(ang);

    const b2 = balance * balance;
    const duration = Math.round(6 + 10 * balance);
    reinfFramesLeft = duration;

    // target spawns per frame, scaled by imbalance and balance
    const targetPerFrame = (120 + 1400 * b2) * (0.6 + 0.8 * absDom);
    reinfProb = Math.min(0.02, targetPerFrame / Math.max(1, activeN));

    reinfSeed = (Math.random() * 4294967295) >>> 0;
    reinfSpeed = 0.03 + 0.08 * b2;
    reinfSpread = 0.01 + 0.05 * balance;
  }

  // =========================
  // AUDIO BRIDGE: TwistJ â†” simulation physics
  // =========================
  const audioEngine = TwistJ({ tempo: 84, reverb: 0.77, breath: 0.65, silence: 0.50, wander: false });
  let audioPlaying = false;
  let audioMuted = true;   // start muted
  const audioBtn = document.getElementById('audioBtn');

  // Per-palette audio style presets
  // DUALITY palette styles (used when duality is on)
  const AUDIO_STYLES_DUAL = [
    { // 0: BLUE/PINK â€” cinematic
      name: 'cinematic', seed: 0,  wander: false,
      tempoBase: 84,
      reverbBase: 0.72, breathBase: 0.55, silenceBase: 0.40,
      registerBase: 2, wanderThresh: 0.45,
      voices: { lead: 0.70, counter: 0.45, bass: 0.60, pad: 0.30, pulse: 0.15 },
      tempoRange: [20, 400],
    },
    { // 1: AMBER/GREEN (CRT) â€” electronic
      name: 'electronic', seed: 10000,  wander: true,
      tempoBase: 110,
      reverbBase: 0.35, breathBase: 0.20, silenceBase: 0.15,
      registerBase: 3, wanderThresh: 0.30,
      voices: { lead: 0.50, counter: 0.30, bass: 0.75, pad: 0.12, pulse: 0.45 },
      tempoRange: [20, 440],
    },
    { // 2: WHITE/DARK BLUE â€” ambient
      name: 'ambient', seed: 31416,  wander: false,
      tempoBase: 56,
      reverbBase: 0.92, breathBase: 0.80, silenceBase: 0.60,
      registerBase: 2, wanderThresh: 0.60,
      voices: { lead: 0.55, counter: 0.50, bass: 0.35, pad: 0.60, pulse: 0.06 },
      tempoRange: [20, 300],
    },
    { // 3: MIL BLUE/RED â€” martial
      name: 'martial', seed: 77777,  wander: true,
      tempoBase: 120,
      reverbBase: 0.25, breathBase: 0.10, silenceBase: 0.05,
      registerBase: 2, wanderThresh: 0.55,
      voices: { lead: 0.75, counter: 0.20, bass: 0.80, pad: 0.10, pulse: 0.40 },
      tempoRange: [20, 480],
    },
    { // 4: WHITE/GREY â€” minimal
      name: 'minimal', seed: 161803,  wander: false,
      tempoBase: 66,
      reverbBase: 0.55, breathBase: 0.70, silenceBase: 0.55,
      registerBase: 1, wanderThresh: 0.70,
      voices: { lead: 0.70, counter: 0.15, bass: 0.40, pad: 0.40, pulse: 0.04 },
      tempoRange: [20, 340],
    },
  ];

  // MAIN palette styles (used when duality is off, palette 0-10)
  const AUDIO_STYLES_MAIN = [
    { // 0: default cool
      name: 'flow', seed: 500,  wander: false,
      tempoBase: 78,
      reverbBase: 0.65, breathBase: 0.50, silenceBase: 0.35,
      registerBase: 2, wanderThresh: 0.50,
      voices: { lead: 0.60, counter: 0.40, bass: 0.50, pad: 0.30, pulse: 0.12 },
      tempoRange: [20, 380],
    },
    { // 1: warm
      name: 'warm', seed: 1618,  wander: false,
      tempoBase: 80,
      reverbBase: 0.70, breathBase: 0.55, silenceBase: 0.40,
      registerBase: 2, wanderThresh: 0.50,
      voices: { lead: 0.65, counter: 0.40, bass: 0.55, pad: 0.35, pulse: 0.10 },
      tempoRange: [20, 380],
    },
    { // 2: earth
      name: 'earth', seed: 2718,  wander: false,
      tempoBase: 72,
      reverbBase: 0.60, breathBase: 0.60, silenceBase: 0.40,
      registerBase: 2, wanderThresh: 0.55,
      voices: { lead: 0.55, counter: 0.35, bass: 0.65, pad: 0.25, pulse: 0.15 },
      tempoRange: [20, 360],
    },
    { // 3: cold
      name: 'frost', seed: 3141,  wander: false,
      tempoBase: 68,
      reverbBase: 0.80, breathBase: 0.65, silenceBase: 0.50,
      registerBase: 2, wanderThresh: 0.60,
      voices: { lead: 0.55, counter: 0.50, bass: 0.40, pad: 0.45, pulse: 0.08 },
      tempoRange: [20, 340],
    },
    { // 4: pastel
      name: 'dream', seed: 4669,  wander: false,
      tempoBase: 74,
      reverbBase: 0.75, breathBase: 0.60, silenceBase: 0.45,
      registerBase: 2, wanderThresh: 0.55,
      voices: { lead: 0.60, counter: 0.45, bass: 0.45, pad: 0.40, pulse: 0.08 },
      tempoRange: [20, 360],
    },
    { // 5: dark
      name: 'shadow', seed: 5813,  wander: false,
      tempoBase: 76,
      reverbBase: 0.55, breathBase: 0.45, silenceBase: 0.30,
      registerBase: 2, wanderThresh: 0.45,
      voices: { lead: 0.65, counter: 0.35, bass: 0.60, pad: 0.20, pulse: 0.18 },
      tempoRange: [20, 380],
    },
    { // 6: vivid Red/Blue/Green â€” charged, tense
      name: 'charged', seed: 60000,  wander: false,
      tempoBase: 92,
      reverbBase: 0.50, breathBase: 0.35, silenceBase: 0.25,
      registerBase: 3, wanderThresh: 0.40,
      voices: { lead: 0.70, counter: 0.35, bass: 0.65, pad: 0.20, pulse: 0.25 },
      tempoRange: [20, 420],
    },
    { // 7: Neon Pink/Cyan/Yellow â€” rave, electric, wandering
      name: 'rave', seed: 70707,  wander: true,
      tempoBase: 126,
      reverbBase: 0.30, breathBase: 0.15, silenceBase: 0.10,
      registerBase: 3, wanderThresh: 0.25,
      voices: { lead: 0.55, counter: 0.35, bass: 0.80, pad: 0.10, pulse: 0.50 },
      tempoRange: [20, 480],
    },
    { // 8: Pure RGB â€” digital, glitchy, wandering
      name: 'digital', seed: 88888,  wander: true,
      tempoBase: 115,
      reverbBase: 0.20, breathBase: 0.10, silenceBase: 0.05,
      registerBase: 4, wanderThresh: 0.30,
      voices: { lead: 0.50, counter: 0.25, bass: 0.70, pad: 0.08, pulse: 0.55 },
      tempoRange: [20, 460],
    },
    { // 9: Fire â€” tribal, primal, intense
      name: 'fire', seed: 99099,  wander: true,
      tempoBase: 132,
      reverbBase: 0.35, breathBase: 0.20, silenceBase: 0.08,
      registerBase: 2, wanderThresh: 0.35,
      voices: { lead: 0.75, counter: 0.20, bass: 0.85, pad: 0.12, pulse: 0.40 },
      tempoRange: [20, 500],
    },
    { // 10: Ocean â€” deep, tidal, flowing
      name: 'ocean', seed: 141421,  wander: false,
      tempoBase: 54,
      reverbBase: 0.90, breathBase: 0.75, silenceBase: 0.55,
      registerBase: 1, wanderThresh: 0.65,
      voices: { lead: 0.50, counter: 0.55, bass: 0.35, pad: 0.65, pulse: 0.04 },
      tempoRange: [20, 280],
    },
  ];

  let currentAudioStyle = AUDIO_STYLES_MAIN[1];
  let lastAudioPalette = -1;  // track for palette switch detection
  let lastAudioDualMode = false; // track duality mode changes

  // Smoothed physics values for audio (avoid jitter)
  const audioSmooth = {
    tempo: 84,
    masterVol: 0.70,
    reverb: 0.77,
    breath: 0.65,
    silence: 0.50,
    leadVol: 0.50,
    counterVol: 0.30,
    bassVol: 0.45,
    padVol: 0.18,
    pulseVol: 0.12,
  };

  function audioLerp(current, target, rate) {
    return current + (target - current) * rate;
  }

  function audioToggle() {
    if (audioMuted) {
      audioMuted = false;
      let sty;
      if (game.dualOn) {
        const idx = game.dualColors || 0;
        sty = AUDIO_STYLES_DUAL[Math.min(idx, AUDIO_STYLES_DUAL.length - 1)];
        lastAudioPalette = 100 + idx;
      } else {
        const idx = parseInt(ui.palette.value) || 0;
        sty = AUDIO_STYLES_MAIN[Math.min(idx, AUDIO_STYLES_MAIN.length - 1)];
        lastAudioPalette = idx;
      }
      lastAudioDualMode = game.dualOn;
      if (!audioPlaying) {
        audioEngine.set({
          reverb: sty.reverbBase, breath: sty.breathBase,
          silence: sty.silenceBase, register: sty.registerBase,
          tempo: sty.tempoBase, wander: sty.wander,
        });
        audioEngine.start(sty.seed);
        audioPlaying = true;
      } else {
        audioEngine.resume();
      }
      audioBtn.textContent = 'ðŸ”Š';
      audioBtn.classList.add('playing');
    } else {
      audioMuted = true;
      audioEngine.pause();
      audioBtn.textContent = 'ðŸ”‡';
      audioBtn.classList.remove('playing');
    }
  }

  audioBtn.addEventListener('click', audioToggle);

  // M key toggles audio
  document.addEventListener('keydown', (e) => {
    if (e.key === 'm' || e.key === 'M') {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      audioToggle();
    }
  });

  // =========================
  // FULLSCREEN
  // =========================
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  function toggleFullscreen(){
    if(document.fullscreenElement){
      document.exitFullscreen().catch(()=>{});
    } else {
      document.documentElement.requestFullscreen().catch(()=>{});
    }
  }
  fullscreenBtn.addEventListener('click', () => {
    if(demoActive){
      demoStop();
    } else {
      toggleFullscreen();
    }
  });

  // =========================
  // DEMO MODE
  // =========================
  let demoActive = false;
  let demoTimer = null;
  let demoStep = 0;
  let demoSectionCount = 0;
  let demoLastChange = 0;

  function demoRand(lo, hi){ return lo + Math.random() * (hi - lo); }
  function demoRandInt(lo, hi){ return lo + Math.floor(Math.random() * (hi - lo + 1)); }
  function demoSet(el, val){
    if(!el) return;
    const step = el.getAttribute('step') || '1';
    const dec = step.includes('.') ? step.split('.')[1].length : 0;
    el.value = Number(val).toFixed(dec);
  }

  const DEMO_PRESETS = [
    // Each is a function that randomizes settings for visual variety
    () => { // flowing organic
      demoSet(ui.pressure, demoRand(0.5, 3.0));
      demoSet(ui.chaos, demoRand(0.5, 2.5));
      demoSet(ui.damping, demoRand(0.3, 0.8));
      demoSet(ui.force, demoRand(0.1, 0.6));
      demoSet(ui.charge, demoRand(0, 6));
      demoSet(ui.vortex, demoRand(-0.5, 0.5));
      demoSet(ui.tempo, demoRand(0.5, 1.5));
      demoSet(ui.fade, demoRand(0.4, 0.85));
      demoSet(ui.grav, demoRand(0, 3));
      demoSet(ui.ffield, demoRand(0.85, 0.98));
      demoSet(ui.deposit, demoRandInt(1, 10));
      ui.tglChaos.checked = true;
      ui.tglPump.checked = Math.random() > 0.5;
      ui.tglReact.checked = false;
      ui.spin.value = (Math.random() > 0.5 ? demoRand(-0.004, -0.001) : demoRand(0.001, 0.004)).toFixed(3);
    },
    () => { // high energy vortex
      demoSet(ui.pressure, demoRand(2.0, 5.0));
      demoSet(ui.chaos, demoRand(1.5, 3.0));
      demoSet(ui.damping, demoRand(0.2, 0.5));
      demoSet(ui.force, demoRand(0.2, 0.8));
      demoSet(ui.charge, demoRand(3, 10));
      demoSet(ui.vortex, demoRand(0.3, 2.0) * (Math.random()>0.5?1:-1));
      demoSet(ui.tempo, demoRand(1.0, 2.5));
      demoSet(ui.fade, demoRand(0.5, 0.75));
      demoSet(ui.grav, demoRand(0, 5));
      demoSet(ui.ffield, demoRand(0.88, 1.0));
      demoSet(ui.deposit, demoRandInt(2, 15));
      ui.tglChaos.checked = true;
      ui.tglPump.checked = true;
      ui.spin.value = demoRand(0.002, 0.008).toFixed(3);
    },
    () => { // calm ethereal
      demoSet(ui.pressure, demoRand(0.1, 1.5));
      demoSet(ui.chaos, demoRand(0.0, 1.0));
      demoSet(ui.damping, demoRand(0.6, 0.95));
      demoSet(ui.force, demoRand(0.05, 0.3));
      demoSet(ui.charge, demoRand(0, 3));
      demoSet(ui.vortex, demoRand(-0.2, 0.2));
      demoSet(ui.tempo, demoRand(0.3, 0.8));
      demoSet(ui.fade, demoRand(0.55, 0.92));
      demoSet(ui.grav, demoRand(0, 2));
      demoSet(ui.ffield, demoRand(0.90, 0.97));
      demoSet(ui.deposit, demoRandInt(1, 5));
      ui.tglChaos.checked = Math.random() > 0.3;
      ui.tglPump.checked = false;
      ui.spin.value = demoRand(-0.002, 0.002).toFixed(3);
    },
    () => { // plasma storm
      demoSet(ui.pressure, demoRand(1.0, 4.0));
      demoSet(ui.chaos, demoRand(2.0, 3.0));
      demoSet(ui.damping, demoRand(0.1, 0.4));
      demoSet(ui.force, demoRand(0.3, 1.0));
      demoSet(ui.charge, demoRand(5, 10));
      demoSet(ui.vortex, demoRand(-1.5, 1.5));
      demoSet(ui.tempo, demoRand(1.5, 3.0));
      demoSet(ui.fade, demoRand(0.3, 0.65));
      demoSet(ui.grav, demoRand(1, 5));
      demoSet(ui.ffield, demoRand(0.85, 0.96));
      demoSet(ui.deposit, demoRandInt(5, 20));
      ui.tglChaos.checked = true;
      ui.tglPump.checked = true;
      ui.spin.value = demoRand(0.003, 0.012).toFixed(3);
    },
    () => { // crystalline minimal
      demoSet(ui.pressure, demoRand(0.5, 2.0));
      demoSet(ui.chaos, demoRand(0.0, 0.5));
      demoSet(ui.damping, demoRand(0.7, 0.9));
      demoSet(ui.force, demoRand(0.1, 0.4));
      demoSet(ui.charge, demoRand(0, 2));
      demoSet(ui.vortex, 0);
      demoSet(ui.tempo, demoRand(0.5, 1.0));
      demoSet(ui.fade, demoRand(0.6, 0.85));
      demoSet(ui.grav, demoRand(0, 1));
      demoSet(ui.ffield, demoRand(0.92, 1.005));
      demoSet(ui.deposit, demoRandInt(1, 4));
      ui.tglChaos.checked = false;
      ui.tglPump.checked = false;
      ui.tglReact.checked = Math.random() > 0.6;
      ui.spin.value = '0.000';
    },
  ];

  function demoTransition(){
    if(!demoActive) return;
    demoStep++;

    // Change palette
    const maxPal = parseInt(ui.palette.max) || 10;
    ui.palette.value = String(demoRandInt(0, maxPal));

    // Pick random preset and apply
    const preset = DEMO_PRESETS[demoStep % DEMO_PRESETS.length];
    preset();

    // Sometimes reset particles for fresh start
    if(Math.random() > 0.65){
      reset();
    }

    demoLastChange = performance.now();
  }

  function demoStart(){
    if(demoActive) return;
    demoActive = true;
    demoStep = 0;
    demoLastChange = performance.now();

    // Enter fullscreen
    document.documentElement.requestFullscreen().catch(()=>{});

    // Hide all UI, show demo mode
    document.body.classList.add('demo-mode');

    // Unpause
    paused = false;

    // Start audio if not playing
    if(audioMuted) audioToggle();

    // Apply first transition
    demoTransition();

    // Listen for section changes from audio engine
    demoSectionCount = 0;
    audioEngine.on('section', demoOnSection);

    fullscreenBtn.textContent = 'âœ•';
    fullscreenBtn.title = 'Exit demo';
  }

  function demoOnSection(){
    if(!demoActive) return;
    demoSectionCount++;
    const elapsed = (performance.now() - demoLastChange) / 1000;
    // Transition at section boundaries, but only after ~18-25s
    if(elapsed > 18 + Math.random() * 7){
      demoTransition();
    }
  }

  function demoStop(){
    if(!demoActive) return;
    demoActive = false;
    audioEngine._listeners['section'] = (audioEngine._listeners['section']||[]).filter(fn => fn !== demoOnSection);

    document.body.classList.remove('demo-mode');

    // Exit fullscreen
    if(document.fullscreenElement){
      document.exitFullscreen().catch(()=>{});
    }

    fullscreenBtn.textContent = 'â›¶';
    fullscreenBtn.title = 'Fullscreen';
  }

  document.getElementById('demoBtn').addEventListener('click', demoStart);

  // Also exit demo on ESC (fullscreen exit)
  document.addEventListener('fullscreenchange', () => {
    if(!document.fullscreenElement && demoActive){
      demoStop();
    }
  });

  // Physics â†’ Audio mapping (called every ~6 frames from render loop)
  function audioUpdateFromPhysics() {
    if (audioMuted || !audioPlaying) return;

    // Pause/resume audio with simulation
    if (paused) {
      if (audioEngine.playing) audioEngine.pause();
      return;
    } else {
      if (!audioEngine.playing) audioEngine.resume();
    }

    // Pick style: duality mode â†’ dual palette, otherwise â†’ main palette
    const isDual = game.dualOn;
    let paletteIdx, sty;
    if (isDual) {
      paletteIdx = game.dualColors || 0;
      sty = AUDIO_STYLES_DUAL[Math.min(paletteIdx, AUDIO_STYLES_DUAL.length - 1)];
    } else {
      paletteIdx = parseInt(ui.palette.value) || 0;
      sty = AUDIO_STYLES_MAIN[Math.min(paletteIdx, AUDIO_STYLES_MAIN.length - 1)];
    }
    currentAudioStyle = sty;

    // Palette or mode changed â†’ restart engine from this style's seed
    const styleKey = (isDual ? 100 : 0) + paletteIdx;
    if (styleKey !== lastAudioPalette || isDual !== lastAudioDualMode) {
      lastAudioPalette = styleKey;
      lastAudioDualMode = isDual;
      audioEngine.stop();
      audioEngine.set({
        reverb:   sty.reverbBase,
        breath:   sty.breathBase,
        silence:  sty.silenceBase,
        register: sty.registerBase,
        tempo:    sty.tempoBase,
        wander:   sty.wander,
      });
      audioEngine.start(sty.seed);
      // Reset smoothing to style defaults
      audioSmooth.tempo   = sty.tempoBase;
      audioSmooth.masterVol = 0.70;
      audioSmooth.reverb  = sty.reverbBase;
      audioSmooth.breath  = sty.breathBase;
      audioSmooth.silence = sty.silenceBase;
      audioSmooth.leadVol    = sty.voices.lead;
      audioSmooth.counterVol = sty.voices.counter;
      audioSmooth.bassVol    = sty.voices.bass;
      audioSmooth.padVol     = sty.voices.pad;
      audioSmooth.pulseVol   = sty.voices.pulse;
    }

    // Read simulation parameters
    const pressure = parseFloat(ui.pressure.value);   // 0-5
    const chaos    = parseFloat(ui.chaos.value);       // 0-1
    const ffield   = parseFloat(ui.ffield.value);      // 0.5-1.005
    const deposit  = parseFloat(ui.deposit.value);     // 1-50
    const force    = parseFloat(ui.force.value);       // 0-1
    const simTempo = parseFloat(ui.tempo.value);       // 0.01-5
    const damping  = parseFloat(ui.damping.value);     // 0-0.05
    const charge   = parseFloat(ui.charge.value);      // 0-10
    const vortex   = parseFloat(ui.vortex.value);      // 0-?

    // === TEMPO â† DIRECTLY from tempo slider ===
    // slider=1 â†’ 1Ã— base BPM, slider=5 â†’ 4Ã— base BPM
    // Linear: mul = 1 + (simTempo - 1) * 0.75
    const tempoMul = Math.max(0.1, 1.0 + (simTempo - 1.0) * 0.75);
    const targetTempo = Math.max(20, Math.min(sty.tempoRange[1], sty.tempoBase * tempoMul));

    // === ENERGY: for volume/dynamics (NOT tempo) ===
    const dampFactor = Math.max(0.08, 1.0 - damping * 15.0);
    const chaosFactor = 1.0 + chaos * 1.5;
    const pressureFactor = 0.4 + pressure * 0.5;
    const vortexFactor = 1.0 + Math.abs(vortex) * 0.3;
    const energy = tempoMul * pressureFactor * chaosFactor * dampFactor * vortexFactor;
    const energyNorm = Math.min(energy / 4.0, 1.0);

    // === PARTICLE COUNT â†’ volume scaling ===
    // More particles = louder, fewer = quieter
    // activeN ranges from ~1024 (2^10) to ~16M (2^24)
    // Reference point: 2^18 = 262144 â†’ 1.0 (no change)
    // 2^14 = 16384 â†’ 0.5, 2^22 = 4M â†’ 1.5
    const partPow = parseInt(ui.particles.value) || 18;
    const partScale = Math.max(0.25, Math.min(2.0, 0.5 + (partPow - 14) * 0.125));
    // partScale: 14â†’0.5, 16â†’0.75, 18â†’1.0, 20â†’1.25, 22â†’1.5, 24â†’1.75

    // === MASTER VOLUME â† energy Ã— particle scale ===
    const targetMasterVol = Math.min(1.0, (0.15 + energyNorm * 0.85) * partScale);

    // === REVERB â† field persistence + style base ===
    const fieldReverb = (ffield - 0.5) * 1.6;
    const targetReverb = Math.max(0.05, Math.min(0.95, sty.reverbBase * 0.5 + fieldReverb * 0.5 + sty.reverbBase * 0.3));

    // === BREATH â† style + inverse energy (fast = no pauses) ===
    const targetBreath = Math.max(0.0, Math.min(1.0, sty.breathBase * Math.max(0, 1.0 - energyNorm * 1.5)));

    // === SILENCE â† only when truly calm ===
    const calmness = Math.max(0, 1.0 - energyNorm * 2.0);
    const targetSilence = Math.max(0.0, Math.min(0.8, sty.silenceBase * calmness * calmness));

    // === WANDER â† style default + chaos can activate it ===
    const wander = sty.wander || (chaos > sty.wanderThresh);

    // Smooth: tempo and volume track FAST, texture slower
    const rFast = 0.25;
    const rMed  = 0.12;
    const rSlow = 0.06;
    audioSmooth.tempo     = audioLerp(audioSmooth.tempo,     targetTempo,     rFast);
    audioSmooth.masterVol = audioLerp(audioSmooth.masterVol, targetMasterVol, rFast);
    audioSmooth.reverb    = audioLerp(audioSmooth.reverb,    targetReverb,    rSlow);
    audioSmooth.breath    = audioLerp(audioSmooth.breath,    targetBreath,    rSlow);
    audioSmooth.silence   = audioLerp(audioSmooth.silence,   targetSilence,   rSlow);

    // Voice volume targets: style base SCALED by energy Ã— particle count
    const volScale = (0.4 + energyNorm * 0.6) * Math.min(1.5, partScale);
    let leadT    = sty.voices.lead * volScale;
    let counterT = sty.voices.counter * volScale;
    let bassT    = sty.voices.bass * volScale;
    let padT     = sty.voices.pad * (0.6 + energyNorm * 0.4) * Math.min(1.3, partScale);
    let pulseT   = sty.voices.pulse * (0.2 + energyNorm * 1.5) * Math.min(1.5, partScale);
    let regTarget = sty.registerBase;

    // === DUALITY: species balance modulates voices ===
    if (game.dualOn && game.lastStats) {
      const S = game.lastStats;
      const pinkT = S.pinkTotalCount || 1;
      const blueT = S.blueTotalCount || 1;
      const total = pinkT + blueT;
      const blueRatio = blueT / total;
      const dominance = Math.abs(blueRatio - 0.5) * 2;
      const winning = blueRatio > 0.5;
      const eatRate = game.dualRate || 0;

      // Species balance modulation (stronger swings)
      leadT    *= (winning ? 1.0 + dominance * 0.5 : 1.0 - dominance * 0.3);
      counterT *= (winning ? 1.0 - dominance * 0.2 : 1.0 + dominance * 0.6);
      bassT    *= 1.0 + (1.0 - dominance) * 0.4;
      padT     *= 1.0 + dominance * 0.5;
      pulseT   *= 1.0 + eatRate * 0.08;

      // Eating intensity boosts volume (NOT tempo â€” that was causing compounding bug)
      audioSmooth.masterVol  = Math.min(1.0, audioSmooth.masterVol * (1.0 + eatRate * 0.03));

      regTarget = Math.max(1, Math.min(4, Math.round(sty.registerBase + (1.0 - dominance) * 1.5)));
    } else {
      // Non-duality: physics drives voices
      const depositNorm = Math.min(deposit / 20, 1.0);
      leadT    *= 1.0 + force * 0.3;
      bassT    *= 1.0 + depositNorm * 0.4;
      padT     *= 1.0 + (1.0 - chaos) * 0.2;
      counterT *= 1.0 + charge * 0.03;
      pulseT   *= 1.0 + chaos * 0.5;
    }

    // Clamp all volumes
    const clV = (v) => Math.max(0.0, Math.min(1.0, v));
    audioSmooth.leadVol    = audioLerp(audioSmooth.leadVol,    clV(leadT),    rMed);
    audioSmooth.counterVol = audioLerp(audioSmooth.counterVol, clV(counterT), rMed);
    audioSmooth.bassVol    = audioLerp(audioSmooth.bassVol,    clV(bassT),    rMed);
    audioSmooth.padVol     = audioLerp(audioSmooth.padVol,     clV(padT),     rMed);
    audioSmooth.pulseVol   = audioLerp(audioSmooth.pulseVol,   clV(pulseT),   rMed);

    // Clamp final tempo to style range
    audioSmooth.tempo = Math.max(sty.tempoRange[0], Math.min(sty.tempoRange[1], audioSmooth.tempo));

    // Apply master volume dynamically
    if (audioEngine._master) {
      audioEngine._master.gain.setTargetAtTime(audioSmooth.masterVol, audioEngine._ax.currentTime, 0.08);
    }

    // Apply to engine
    audioEngine.set({
      tempo:    audioSmooth.tempo,
      reverb:   audioSmooth.reverb,
      breath:   audioSmooth.breath,
      silence:  audioSmooth.silence,
      wander:   wander,
      register: Math.max(1, Math.min(4, regTarget)),
    });
    audioEngine.setVoiceVol(0, audioSmooth.leadVol);
    audioEngine.setVoiceVol(1, audioSmooth.counterVol);
    audioEngine.setVoiceVol(2, audioSmooth.bassVol);
    audioEngine.setVoiceVol(3, audioSmooth.padVol);
    audioEngine.setVoiceVol(4, audioSmooth.pulseVol);
  }

  function loop(){
    if(needLayout) layout();

    // activate locked mode on first frame (after layout and GL are ready)
    if(gameLockRequested){
      gameLockRequested = false;
      enterLockedMode();
      needLayout = true;
      layout();
    }

    const now = performance.now();
    const dt = now - lastT; lastT = now;
    acc += dt; frames++;
    if(acc > 500){
      fpsEl.textContent = String(Math.round((frames*1000)/acc));
      frames=0; acc=0;
    }

    if(paused){
      // Pause audio with simulation
      if(audioPlaying && !audioMuted && audioEngine.playing) audioEngine.pause();
      requestAnimationFrame(loop);
      return;
    }

    const tm = thueMorse32(frame);
    tmEl.textContent = String(tm);
    document.getElementById('rotv').textContent = String(Math.round(viewRot * 180 / Math.PI));

    const spinSpeed = parseFloat(ui.spin.value);
    if (Math.abs(spinSpeed) > 0.0001) {
      viewRot += spinSpeed;
      if (viewRot > Math.PI) viewRot -= 2 * Math.PI;
      if (viewRot < -Math.PI) viewRot += 2 * Math.PI;
    }

    const kernelOn = ui.tglKernel.checked ? 1 : 0;
    const fieldOn  = ui.tglField.checked  ? 1 : 0;
    const mouseOn  = ui.tglMouse.checked  ? 1 : 0;
    const chaosOn  = ui.tglChaos.checked  ? 1 : 0;
    const pumpOn   = (ui.tglPump.checked && kernelOn) ? 1 : 0;

    const baseAttract = ui.mouseAttract.checked;
    const effectiveAttract = invertHold ? !baseAttract : baseAttract;
    const mouseSign = effectiveAttract ? -1.0 : 1.0;

    const damping = parseFloat(ui.damping.value);
    const force   = parseFloat(ui.force.value);
    const chaos   = parseFloat(ui.chaos.value);
    const fade    = parseFloat(ui.fade.value);
    const scale   = parseFloat(ui.scale.value);

    // kompenzace posunu pri zmene meritka: zachovat stred pohledu
    if(prevScale > 0.001 && Math.abs(scale - prevScale) > 0.0001){
      const ratio = scale / prevScale;
      panX *= ratio;
      panY *= ratio;
    }
    prevScale = scale;

    const ffield  = parseFloat(ui.ffield.value);
    const deposit = parseFloat(ui.deposit.value);
    const grav    = parseFloat(ui.grav.value);
    const pressure = parseFloat(ui.pressure.value);
    const pump    = parseFloat(ui.pump.value);
    const react   = parseFloat(ui.react.value);
    const timeK   = parseFloat(ui.timeK.value);
    const timeMin = parseFloat(ui.timeMin.value);
    const charge  = parseFloat(ui.charge.value);
    const vortex  = parseFloat(ui.vortex.value);
    const tempo   = parseFloat(ui.tempo.value);

    activeN = Math.min(N, 2 ** parseInt(ui.particles.value));
    pcEl.textContent = activeN.toLocaleString();

    const bounds = 2.2;

    // mouse -> world coords
    {
      const aspect = viewW / viewH;
      mx = ((mouseNX - panX) * aspect) / Math.max(0.001, scale);
      my = ((mouseNY - panY)) / Math.max(0.001, scale);
      const c = Math.cos(-viewRot);
      const s = Math.sin(-viewRot);
      const wx = c * mx - s * my;
      const wy = s * mx + c * my;
      mx = wx;
      my = wy;
    }

    // pole off->on transition
    if(fieldOn === 1 && !prevFieldOn){
      clearField();
      kickFrames = 180;
    }
    prevFieldOn = (fieldOn === 1);
    if(kickFrames > 0) kickFrames--;

    // exact IFS auto-zoom
    const exactOn = ui.tglExact.checked;
    if(exactOn && !prevExact){
      savedScale = parseFloat(ui.scale.value);
      const absJ = Math.sqrt(Jre*Jre + Jim*Jim);
      const absOneMinusJ = Math.sqrt(oneMinusJ.re*oneMinusJ.re + oneMinusJ.im*oneMinusJ.im);
      const attractorR = absOneMinusJ / (1.0 - absJ);
      const autoScale = Math.min(0.7 / attractorR, 5.0);
      ui.scale.value = autoScale.toFixed(2);
      clearTrail();
    }
    if(!exactOn && prevExact && savedScale !== null){
      ui.scale.value = savedScale.toFixed(2);
      savedScale = null;
      clearTrail();
    }
    prevExact = exactOn;

    // =========================
    // 0) Field: fade + deposit + blur
    // =========================
    {
      let fieldWrite = 1 - fieldFlip;

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboField[fieldWrite]);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progFieldFade);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldFlip]);
      gl.uniform1i(uFieldFade.prev, 0);
      gl.uniform1f(uFieldFade.fade, ffield);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);

      gl.useProgram(progFieldDep);
      gl.uniform1f(uFieldDep.bounds, bounds);
      gl.uniform1i(uFieldDep.tm, tm);
      gl.uniform1ui(uFieldDep.frame, frame>>>0);
      gl.uniform1i(uFieldDep.kernelOn, kernelOn);
      gl.uniform1i(uFieldDep.dualOn, game.dualOn ? 1 : 0);
      gl.uniform1f(uFieldDep.dualEq, game.dualEq);
      gl.uniform1f(uFieldDep.deposit, deposit * Math.max(1.0 - ffield, 0.005) * (FIELD_SIZE * FIELD_SIZE) / activeN);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
      gl.uniform1i(uFieldDep.state, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
      gl.uniform1i(uFieldDep.k0, 1);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
      gl.uniform1i(uFieldDep.k1, 2);

      gl.bindVertexArray(vaoEmpty);
      gl.drawArrays(gl.POINTS, 0, activeN);
      gl.disable(gl.BLEND);

      // Optional: local field reactions (annihilation + fission) + duality (BLUE/PINK eat)
      if((fieldOn === 1 && ui.tglReact.checked && !game.dualOn) || game.dualOn){
        const reactWrite = 1 - fieldWrite;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fboField[reactWrite]);
        gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
        gl.useProgram(progFieldReact);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldWrite]);
        gl.uniform1i(uFieldReact.prev, 0);
        gl.uniform2f(uFieldReact.texel, 1.0/FIELD_SIZE, 1.0/FIELD_SIZE);
        gl.uniform1f(uFieldReact.charge, charge);
        gl.uniform1f(uFieldReact.pressure, pressure);
        gl.uniform1f(uFieldReact.react, react);
        gl.uniform1i(uFieldReact.reactOn, (fieldOn === 1 && ui.tglReact.checked && !game.dualOn) ? 1 : 0);
        gl.uniform1i(uFieldReact.dualOn, game.dualOn ? 1 : 0);
        gl.uniform1f(uFieldReact.dualRate, game.dualRate);
        gl.uniform1f(uFieldReact.dualEq, game.dualEq);
        if(uFieldReact.dualCoh) gl.uniform1f(uFieldReact.dualCoh, game.dualCoh);
        gl.uniform1f(uFieldReact.eatMulBlue, game.powerEats ? game.reinfBlue : 1.0);
        gl.uniform1f(uFieldReact.eatMulPink, game.powerEats ? game.reinfPink : 1.0);
        gl.uniform1i(uFieldReact.energyTransfer, game.energyTransfer ? 1 : 0);
        gl.bindVertexArray(vaoQuad);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        fieldWrite = reactWrite;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboTemp);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progBlur);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldWrite]);
      gl.uniform1i(uBlur.tex, 0);
      gl.uniform2f(uBlur.dir, 1.0/FIELD_SIZE, 0.0);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur[fieldWrite]);
      gl.viewport(0,0,FIELD_SIZE,FIELD_SIZE);
      gl.useProgram(progBlur);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, fieldTemp);
      gl.uniform1i(uBlur.tex, 0);
      gl.uniform2f(uBlur.dir, 0.0, 1.0/FIELD_SIZE);
      gl.bindVertexArray(vaoQuad);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      fieldFlip = fieldWrite;
    }


    // =========================
    // Duality reinforcements (BALANCE slider)
    // =========================
    let reinfOn = 0;
    // Reinforcements are driven by FLOW (independent). BALANCE only changes how adaptive it is.
    // WAVES (default off) affects PINK only: pulses that grow over time.
    if(game.dualOn && game.reinfFlow > 0.0001){
      const flow = Math.max(0.0, game.reinfFlow);          // base rate knob
      const bal  = Math.max(0.0, Math.min(1.0, game.dualEq)); // adaptive knob (0 = constant, 1 = strongly balancing)

      // measure dominance (blue - pink) from field; fallback 0
      let dom = 0.0;
      try { dom = sampleDualDominance(); } catch(e){ dom = 0.0; }
      const absDom = Math.min(1.0, Math.abs(dom));

      // base interval from flow (higher flow -> more frequent spawn windows)
      const interval = Math.max(0.05, 1.2 / (0.2 + flow)); // ~6s..0.2s range

      // adaptive gain: if blue dominates (dom>0) -> increase pink; if pink dominates -> decrease pink.
      let pinkGain = 1.0;
      if(dom > 0.0) pinkGain = 1.0 + (2.2 * bal) * absDom;
      else          pinkGain = Math.max(0.0, 1.0 - (1.4 * bal) * absDom);

      // WAVES: pulses for PINK only, with slow ramp-up over time
      // pulse in [0..1], grows in amplitude with time
      let wavePulse = 1.0;
      if(game.reinfWaves){
        const period = 4.0; // seconds
        const phase = (game.time / period) % 1.0;
        // triangular-ish pulse with smooth edges
        const tri = 1.0 - Math.abs(2.0 * phase - 1.0);
        wavePulse = tri * tri; // sharpen
        const grow = 1.0 + 0.15 * game.time; // increasing pressure
        pinkGain *= (0.35 + 0.65 * wavePulse) * grow;
      }

      reinfTimer += dt / 1000;
      if(reinfFramesLeft <= 0 && reinfTimer >= interval){
        // decide direction + seed each window (direction always inward)
        const ang = Math.random() * Math.PI * 2;
        reinfDirX = Math.cos(ang);
        reinfDirY = Math.sin(ang);

        // we keep both sides available (sliders), but by default PINK is the one that matters.
        // BALANCE changes only the dynamic scaling (pinkGain), not whether reinforcements happen.
        reinfSide = 1; // PINK side for now (requested)

        // duration in frames (short burst)
        const dur = Math.round(6 + 18 * Math.min(1.0, flow/5.0));
        reinfFramesLeft = dur;

        // spawn probability per particle per frame
        // NOTE: activeN is particles count; keep prob small
        const perFrame = (220.0 + 4200.0 * Math.min(1.0, flow/5.0)) * pinkGain;
        reinfProb = Math.min(0.12, perFrame / Math.max(1, activeN));

        reinfSeed = (Math.random() * 4294967295) >>> 0;
        reinfSpeed = 0.03 + 0.18 * Math.min(1.0, flow/5.0);
        reinfSpread = 0.01 + 0.06 * Math.min(1.0, flow/5.0);

        reinfTimer = 0.0;
      }

      if(reinfFramesLeft > 0){
        reinfFramesLeft--;
        reinfOn = 1;
      }
    } else {
      reinfFramesLeft = 0;
      reinfProb = 0.0;
      reinfTimer = 0.0;
    }

// --- Reinforcement HUD (build-up + direction) ---
    if(gameUI.reinfStat){
      const flow = game.reinfFlow || 0.0;
      if(game.dualOn && flow > 0.0001){
        const interval = Math.max(0.05, 1.2 / (0.2 + flow));
        const build = (reinfFramesLeft > 0) ? 1.0 : Math.max(0.0, Math.min(1.0, reinfTimer / interval));

        // arrow from dir
        const a = Math.atan2(reinfDirY, reinfDirX);
        const dirs = ['â†’','â†—','â†‘','â†–','â†','â†™','â†“','â†˜'];
        const di = ((Math.round(a / (Math.PI/4)) % 8) + 8) % 8;
        const arrow = dirs[di];

        const pct = Math.round(build * 100);
        const mode = game.reinfWaves ? 'WAVES' : 'BAL';
        const bal  = Math.max(0.0, Math.min(1.0, game.dualEq));
        gameUI.reinfStat.textContent = `REINF ${mode}: ${pct}% ENEMY ${arrow} | flow ${flow.toFixed(2)} | bal ${bal.toFixed(2)}`;
      } else {
        gameUI.reinfStat.textContent = 'REINF: off';
      }
    }
// =========================
    // 1) Physics step (sub-stepped for smoother motion)
    // =========================
    const reactOn = (fieldOn === 1 && ui.tglReact.checked && !game.dualOn) ? 1 : 0;
    const substeps = reactOn ? 2 : 1;
    const tempoSub = tempo / substeps;

    for(let sub = 0; sub < substeps; sub++){
    const activeRows = Math.min(TEX_SIZE, Math.ceil(activeN / TEX_SIZE));
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[1-partFlip]);
    gl.viewport(0,0,TEX_SIZE,activeRows);
    gl.useProgram(progPhys);

    gl.uniform1i(uPhys.tm, tm);
    gl.uniform1ui(uPhys.frame, (frame * substeps + sub)>>>0);
    gl.uniform1i(uPhys.kernelOn, kernelOn);
    gl.uniform1i(uPhys.fieldOn,  fieldOn);
    gl.uniform1i(uPhys.reactOn, reactOn);
    gl.uniform1f(uPhys.react, react);
    gl.uniform1i(uPhys.mouseOn,  mouseOn);
    gl.uniform1i(uPhys.chaosOn,  chaosOn);
    gl.uniform1i(uPhys.pumpOn,   (sub === 0) ? pumpOn : 0);
    gl.uniform1i(uPhys.exactIFS, ui.tglExact.checked ? 1 : 0);

    // Duality (BLUE/PINK). Player input affects BLUE only.
    gl.uniform1i(uPhys.dualOn, game.dualOn ? 1 : 0);
    gl.uniform1f(uPhys.dualRate, game.dualOn ? game.dualRate : 0.0);
    gl.uniform1f(uPhys.dualEq, game.dualOn ? game.dualEq : 0.0);
    gl.uniform1f(uPhys.dualCoh, game.dualOn ? game.dualCoh : 0.0);
    gl.uniform1f(uPhys.eatMulBlue, game.powerEats ? game.reinfBlue : 1.0);
    gl.uniform1f(uPhys.eatMulPink, game.powerEats ? game.reinfPink : 1.0);
    gl.uniform1i(uPhys.energyTransfer, game.energyTransfer ? 1 : 0);

    // Reinforcements (BALANCE slider): event-driven respawn waves
    if(uPhys.reinfOn){
      gl.uniform1i(uPhys.reinfOn, reinfOn);
      gl.uniform1f(uPhys.reinfProb, (reinfOn ? reinfProb * (reinfSide===0 ? game.reinfBlue : game.reinfPink) : 0.0));
      gl.uniform1i(uPhys.reinfSide, reinfSide);
      gl.uniform1ui(uPhys.reinfSeed, (reinfSeed ^ ((frame * 374761393)>>>0))>>>0);
      gl.uniform2f(uPhys.reinfDir, reinfDirX, reinfDirY);
      gl.uniform1f(uPhys.reinfSpeed, reinfSpeed);
      gl.uniform1f(uPhys.reinfSpread, reinfSpread);
      gl.uniform1f(uPhys.reinfMulBlue, game.reinfBlue);
      gl.uniform1f(uPhys.reinfMulPink, game.reinfPink);
    }

    gl.uniform1f(uPhys.grav, (fieldOn ? grav : 0.0));
    gl.uniform1f(uPhys.pump, (pumpOn ? pump : 0.0));
    gl.uniform1f(uPhys.charge, (fieldOn && !game.dualOn ? charge : 0.0));
    gl.uniform1f(uPhys.pressure, (fieldOn ? pressure : 0.0));

    gl.uniform2f(uPhys.mouse, mx, my);
    gl.uniform1f(uPhys.mouseDown, (mouseOn ? mDown : 0.0));
    gl.uniform1f(uPhys.mouseSign, mouseSign);

    gl.uniform1f(uPhys.chaos, (chaosOn ? chaos : 0.0));
    gl.uniform1f(uPhys.bounds, bounds);

    gl.uniform2f(uPhys.J, Jre, Jim);
    gl.uniform2fv(uPhys.ck0, CK);
    gl.uniform2f(uPhys.fieldTexel, 1.0/FIELD_SIZE, 1.0/FIELD_SIZE);
    gl.uniform1f(uPhys.timeK, fieldOn ? timeK : 0.0);
    gl.uniform1f(uPhys.timeMin, timeMin);
    gl.uniform1f(uPhys.tempo, tempoSub);
    gl.uniform1f(uPhys.vortex, vortex);

    const kickRatio = kickFrames > 0 ? kickFrames / 180.0 : 0.0;
    const kickStr = (kickRatio * 0.05) / substeps;
    gl.uniform1f(uPhys.kick, kickStr);

    const forceEff = kickFrames > 0 ? force * (1.0 - 0.9 * kickRatio) : force;
    const dampEff  = kickFrames > 0 ? Math.min(damping, 0.5 + 0.5 * (1.0 - kickRatio)) : damping;
    gl.uniform1f(uPhys.damping, dampEff);
    gl.uniform1f(uPhys.force, forceEff);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
    gl.uniform1i(uPhys.state, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
    gl.uniform1i(uPhys.k0, 1);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
    gl.uniform1i(uPhys.k1, 2);
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, fieldBlur[fieldFlip]);
    gl.uniform1i(uPhys.field, 3);
    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_2D, fieldTex[fieldFlip]);
    gl.uniform1i(uPhys.fieldRaw, 4);

    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    partFlip = 1 - partFlip;
    } // end substeps

    // =========================
    // 2) Trail: fade
    // =========================
    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFbo[1-trailFlip]);
    gl.viewport(0,0,viewW,viewH);
    gl.useProgram(progFade);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, trailTex[trailFlip]);
    gl.uniform1i(uFade.prev, 0);
    gl.uniform1f(uFade.fade, exactOn ? 1.0 : fade);
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // =========================
    // 3) Points into trail (additive)
    // =========================
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

    gl.useProgram(progPts);
    gl.uniform1f(uPts.aspect, viewW / viewH);
    gl.uniform1f(uPts.scale, scale);
    gl.uniform1f(uPts.rot, viewRot);
    gl.uniform2f(uPts.pan, panX, panY);
    gl.uniform1i(uPts.tm, tm);
    gl.uniform1ui(uPts.frame, frame>>>0);
    gl.uniform1i(uPts.kernelOn, kernelOn);
    gl.uniform1f(uPts.alphaMul, Math.sqrt(1048576.0 / activeN));
    gl.uniform1i(uPts.exactIFS, ui.tglExact.checked ? 1 : 0);
    gl.uniform1i(uPts.palette, parseInt(ui.palette.value));
    gl.uniform1f(uPts.bounds, bounds);
    gl.uniform1i(uPts.dualOn, game.dualOn ? 1 : 0);
    gl.uniform1i(uPts.dualColors, game.dualColors || 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, stateTex[partFlip]);
    gl.uniform1i(uPts.state, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, k0Tex[partFlip]);
    gl.uniform1i(uPts.k0, 1);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, k1Tex[partFlip]);
    gl.uniform1i(uPts.k1, 2);
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, fieldBlur[fieldFlip]);
    gl.uniform1i(uPts.fieldBlur, 3);

    gl.bindVertexArray(vaoEmpty);
    gl.drawArrays(gl.POINTS, 0, activeN);
    gl.disable(gl.BLEND);

    // =========================
    // 4) Blit to screen
    // =========================
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,viewW,viewH);
    gl.useProgram(progBlit);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, trailTex[1-trailFlip]);
    gl.uniform1i(uBlit.tex, 0);
    gl.uniform1i(uBlit.palette, parseInt(ui.palette.value));

    // zone overlay
    const zShow = game.enabled && game.showZone ? 1 : 0;
    gl.uniform1i(uBlit.zoneShow, zShow);
    if(zShow){
      const zAspect = viewW / viewH;
      const zCs = Math.cos(-viewRot);
      const zSn = Math.sin(-viewRot);
      const lineW = 0.008 / Math.max(scale, 0.01);
      gl.uniform4f(uBlit.zone, game.cx, game.cy, game.half, lineW);
      const danger = game.running ? Math.min(1.0, game.tDanger / Math.max(game.grace, 0.01)) : 0.0;
      gl.uniform1f(uBlit.zoneDanger, danger);
      gl.uniform1i(uBlit.zoneMode, game.modeEmpty ? 0 : 1);
      gl.uniform1f(uBlit.time, performance.now() / 1000.0);
      gl.uniform1f(uBlit.viewScale, scale);
      gl.uniform1f(uBlit.cs, zCs);
      gl.uniform1f(uBlit.sn, zSn);
      gl.uniform2f(uBlit.pan, panX, panY);
      gl.uniform1f(uBlit.aspect, zAspect);
    }
    gl.bindVertexArray(vaoQuad);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    trailFlip = 1 - trailFlip;

    // =========================
    // Histogram
    // =========================
    if(kernelOn && frame > 0 && (frame & 63) === 0){
      const SAMPLE = 256;
      const k0buf = new Float32Array(SAMPLE * 4);
      const k1buf = new Float32Array(SAMPLE * 4);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboPart[partFlip]);
      gl.readBuffer(gl.COLOR_ATTACHMENT1);
      gl.readPixels(0, 0, SAMPLE, 1, gl.RGBA, gl.FLOAT, k0buf);
      gl.readBuffer(gl.COLOR_ATTACHMENT2);
      gl.readPixels(0, 0, SAMPLE, 1, gl.RGBA, gl.FLOAT, k1buf);
      gl.readBuffer(gl.COLOR_ATTACHMENT0);

      const zH = [0,0,0,0,0];
      const iH = [0,0,0,0,0];
      for(let j = 0; j < SAMPLE; j++){
        const p1  = Math.round(k0buf[j*4+0]);
        const p4  = Math.round(k0buf[j*4+1]);
        const p1p = Math.round(k0buf[j*4+2]);
        const p4p = Math.round(k0buf[j*4+3]);
        const q   = Math.round(k1buf[j*4+0]);
        const ts  = Math.round(k1buf[j*4+1]);
        let z = (p1+p4+p1p+p4p+q+ts) % 5;
        if(z < 0) z += 5;
        zH[z]++;
        let idx = (tm === 0) ? z : (z + 2) % 5;
        iH[idx]++;
      }

      const histZEl = document.getElementById('histZ');
      const histIEl = document.getElementById('histI');
      const histDiv = document.getElementById('histDiv');
      histDiv.style.display = '';
      histZEl.textContent = zH.map((v,k) => k+':'+v).join(' ');
      histIEl.textContent = iH.map((v,k) => 'abcde'[k]+':'+v).join(' ');
    }

    // =========================
    // Game
    // =========================
    gameTick();
    if(game.running && (frame & 7) === 0){
      gameCheck();
    }

    // Audio bridge: update every ~6 frames (~10 Hz)
    if((frame & 5) === 0){
      audioUpdateFromPhysics();
    }

    frame = (frame + 1) >>> 0;
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
